(* Example:
   class Node { data : int; next : Node }
   class Stack { head : Node; ghost rep : rgn }
 *)

module CurrentEncoding
  use prelude.Prelude
  use prelude.PreRefperm

  type reftype =
    | Node
    | Stack

  type heap = {
    mutable head : M.t reference;
    mutable ghost rep : M.t rgn;
    mutable data : M.t int;
    mutable next : M.t reference;
  }

  type state = {
    mutable heap : heap;
    mutable ghost alloct : M.t reftype;
  }   
    invariant { not (M.mem null alloct) }
    
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Node ->
         M.mem p heap.data 
      /\ M.mem p heap.next 
      /\ (heap.next[p] = null
          \/ (M.mem heap.next[p] alloct /\ alloct[heap.next[p]] = Node)) }
    
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Stack ->
         M.mem p heap.head
      /\ M.mem p heap.rep
      /\ (heap.head[p] = null \/ (M.mem heap.head[p] alloct /\ alloct[heap.head[p]] = Node))
      /\ (forall q. Rgn.mem q heap.rep[p] -> q = null \/ M.mem q alloct) }
    by { heap = any heap; alloct = M.create () }

end

module Stack1
  use prelude.Prelude
  use CurrentEncoding

  val newNode (s: state) : reference
    writes { s.alloct, s.heap.data, s.heap.next }
    ensures { not (M.mem result (old s.alloct)) /\ result <> null }
    ensures { s.alloct = M.add result Node (old s.alloct) }
    ensures { s.heap.data = M.add result 0 (old s.heap.data) }
    ensures { s.heap.next = M.add result null (old s.heap.next) }

  let cons (s: state) (k: int) (self: reference) : reference
    (* self has type Node *)
    requires { self = null \/ (M.mem self s.alloct /\ s.alloct[self] = Node) }
    (* result has type Node *)
    ensures  { M.mem result s.alloct /\ s.alloct[result] = Node }
    ensures  { s.heap.data[result] = k }    (* result.data = k *)
    ensures  { s.heap.next[result] = self } (* result.next = self *)
    writes   { s.alloct, s.heap.data, s.heap.next }
  = let n = ref null in
    n := newNode s;                           (* n := new Node *)
    s.heap.data <- M.add !n k s.heap.data;    (* n.data := k *)
    s.heap.next <- M.add !n self s.heap.next; (* n.next := self *)
    !n                                        (* return n *)

  let push (s: state) (self: reference) (k: int) : unit
    requires { M.mem self s.alloct /\ s.alloct[self] = Stack }
    ensures  { s.heap.data[s.heap.head[self]] = k }
    ensures  { s.heap.next[s.heap.head[self]] = (old s.heap.head[self]) }
    ensures  { Rgn.mem s.heap.head[self] s.heap.rep[self] }
    writes   { s.alloct, s.heap.data, s.heap.next, s.heap.head, s.heap.rep }
  = (* self.head := cons(k, self.head) *)
    s.heap.head <- M.add self (cons s k s.heap.head[self]) s.heap.head;
    (* self.rep := self.rep union {self.head} *)
    s.heap.rep <- M.add self (Rgn.union s.heap.rep[self] (singleton s.heap.head[self])) s.heap.rep;
    ()

end

module AlternateEncoding
  use prelude.Prelude

  type reftype =
    | Node
    | Stack

  predicate hasNodeType (alloc: M.t reftype) (p: reference) =
    p = null \/ (M.mem p alloc /\ alloc[p] = Node)

  predicate hasStackType (alloc: M.t reftype) (p: reference) =
    p = null \/ (M.mem p alloc /\ alloc[p] = Stack)

  predicate okRgn (alloc: M.t reftype) (r: rgn) =
    forall q: reference. Rgn.mem q r -> q = null \/ M.mem q alloc

  type state = private {
    mutable head : M.t reference;
    mutable ghost rep : M.t rgn;
    mutable data : M.t int;
    mutable next : M.t reference;
    mutable ghost alloct : M.t reftype;
  } invariant { not (M.mem null alloct) }
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Node ->
      M.mem p data /\ M.mem p next /\ hasNodeType alloct next[p] }
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Stack ->
      M.mem p head /\ M.mem p rep /\ hasNodeType alloct head[p] /\ okRgn alloct rep[p] }

    (* NEW invariants -- not present in existing encoding *)
    invariant { not (M.mem null head) }
    invariant { not (M.mem null rep) }
    invariant { not (M.mem null data) }
    invariant { not (M.mem null next) }

    by { head = M.create (); rep = M.create (); data = M.create ();
         next = M.create (); alloct = M.create () }

  val newNode (s: state) : reference
    writes { s.alloct, s.data, s.next }
    ensures { not (M.mem result (old s.alloct)) /\ result <> null }
    ensures { s.alloct = M.add result Node (old s.alloct) }
    ensures { hasNodeType s.alloct result } (* generate this as well *)
    ensures { s.data = M.add result 0 (old s.data) }
    ensures { s.next = M.add result null (old s.next) }

  val set_data (s: state) (p: reference) (n: int) : unit
    requires { p <> null }
    requires { hasNodeType s.alloct p } (*guaranteed by type checking*)
    writes { s.data } ensures { s.data = M.add p n (old s.data) }

  val set_next (s: state) (p: reference) (q: reference) : unit
    requires { p <> null }
    requires { hasNodeType s.alloct p } (*guaranteed by type checking*)
    requires { hasNodeType s.alloct q } (*guaranteed by type checking*)
    writes { s.next } ensures { s.next = M.add p q (old s.next) }

  val set_head (s: state) (p: reference) (q: reference) : unit
    requires { p <> null }
    requires { hasStackType s.alloct p } (*guaranteed by type checking*)
    requires { hasNodeType s.alloct q }  (*guaranteed by type checking*)
    writes { s.head } ensures { s.head = M.add p q (old s.head) }

  val set_rep (s: state) (p: reference) (ghost r: rgn) : unit
    requires { p <> null }
    requires { hasStackType s.alloct p } (*guaranteed by type checking*)
    requires { okRgn s.alloct r }
    writes { s.rep } ensures { s.rep = M.add p r (old s.rep) }

end

module Stack2
  use prelude.Prelude
  use AlternateEncoding

  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. M.mem p pre.alloct ->
      M.mem p post.alloct /\ pre.alloct[p] = post.alloct[p]

  let cons (s: state) (k: int) (self: reference) : reference
    (* self has type Node *)
    requires { self = null \/ (M.mem self s.alloct /\ s.alloct[self] = Node) }
    (* result has type Node *)
    ensures  { M.mem result s.alloct /\ s.alloct[result] = Node }
    ensures  { s.data[result] = k }    (* result.data = k *)
    ensures  { s.next[result] = self } (* result.next = self *)
    ensures  { alloc_does_not_shrink (old s) s }
    writes   { s.alloct, s.data, s.next }
  = let n = ref null in
    n := newNode s;                 (* n := new Node *)
    set_data s !n k;                (* n.data := k *)
    set_next s !n self;             (* n.next := self *)
    !n                              (* return n *)

  let push (s: state) (self: reference) (k: int) : unit
    requires { self <> null /\ hasStackType s.alloct self }
    ensures  { s.data[s.head[self]] = k }
    ensures  { s.next[s.head[self]] = (old s.head[self]) }
    ensures  { Rgn.mem s.head[self] s.rep[self] }
    writes   { s.alloct, s.data, s.next, s.head, s.rep }
  = (* self.head := cons(k, self.head) *)
    set_head s self (cons s k s.head[self]);
    (* self.rep := self.rep union {self.head} *)
    let r = ghost (Rgn.union s.rep[self] (singleton s.head[self])) in
    set_rep s self r

end

module AlternateEncodingImplementable
  use prelude.Prelude

  type reftype =
    | Node
    | Stack

  predicate hasNodeType (alloc: M.t reftype) (p: reference) =
    p = null \/ (M.mem p alloc /\ alloc[p] = Node)

  predicate hasStackType (alloc: M.t reftype) (p: reference) =
    p = null \/ (M.mem p alloc /\ alloc[p] = Stack)

  predicate okRgn (alloc: M.t reftype) (r: rgn) =
    forall q: reference. Rgn.mem q r -> q = null \/ M.mem q alloc

  type state = {
    mutable head : M.t reference;
    mutable ghost rep : M.t rgn;
    mutable data : M.t int;
    mutable next : M.t reference;
    mutable ghost alloct : M.t reftype;
  } invariant { not (M.mem null alloct) }
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Node ->
      M.mem p data /\ M.mem p next /\ hasNodeType alloct next[p] }
    invariant { forall p: reference.
      M.mem p alloct ->
      alloct[p] = Stack ->
      M.mem p head /\ M.mem p rep /\ hasNodeType alloct head[p] /\ okRgn alloct rep[p] }
    (* NEW invariants -- not present in existing encoding *)
    invariant { not (M.mem null head) }
    invariant { not (M.mem null rep) }
    invariant { not (M.mem null data) }
    invariant { not (M.mem null next) }
    by { head = M.create (); rep = M.create (); data = M.create ();
         next = M.create (); alloct = M.create () }

  val freshRef (s: state) : reference
    ensures { not (M.mem result s.alloct) /\ result <> null }
  
  let newNode (s: state) : reference
    writes { s.alloct, s.data, s.next }
    ensures { not (M.mem result (old s.alloct)) /\ result <> null }
    ensures { s.alloct = M.add result Node (old s.alloct) }
    ensures { s.data = M.add result 0 (old s.data) }
    ensures { s.next = M.add result null (old s.next) }
  = let n = freshRef s in
    s.alloct <- M.add n Node s.alloct;
    s.data <- M.add n 0 s.data;
    s.next <- M.add n null s.next;
    n

  let set_data (s: state) (p: reference) (n: int) : unit
    requires { p <> null }
    writes { s.data } ensures { s.data = M.add p n (old s.data) }
  = s.data <- M.add p n s.data

  let set_next (s: state) (p: reference) (q: reference) : unit
    requires { p <> null }
    requires { hasNodeType s.alloct q }
    writes { s.next } ensures { s.next = M.add p q (old s.next) }
  = s.next <- M.add p q s.next

  let set_head (s: state) (p: reference) (q: reference) : unit
    requires { p <> null }
    requires { hasNodeType s.alloct q }
    writes { s.head } ensures { s.head = M.add p q (old s.head) }
  = s.head <- M.add p q s.head

  let set_rep (s: state) (p: reference) (ghost r: rgn) : unit
    requires { p <> null }
    requires { okRgn s.alloct r }
    writes { s.rep } ensures { s.rep = M.add p r (old s.rep) }
  = s.rep <- M.add p r s.rep; ()

  clone AlternateEncoding with
    type reftype,
    type state,
    val newNode,
    val set_data,
    val set_next,
    val set_head,
    val set_rep
end

