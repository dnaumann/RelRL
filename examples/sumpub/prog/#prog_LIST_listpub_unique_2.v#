(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

(* Why3 assumption *)
Definition infix_eqeq {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m1:fmap k v) (m2:fmap k v) : Prop :=
  set.Fset.infix_eqeq (domain m1) (domain m2) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))).

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v), infix_eqeq m1 m2 -> (m1 = m2).

(* Why3 assumption *)
Definition mem {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} (k1:k)
    (m:fmap k v) : Prop :=
  set.Fset.mem k1 (domain m).

(* Why3 assumption *)
Definition mapsto {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} 
    (k1:k) (v1:v) (m:fmap k v) : Prop :=
  mem k1 m /\ ((contents1 m k1) = v1).

Axiom mem_mapsto :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> mapsto k1 (contents1 m k1) m.

(* Why3 assumption *)
Definition is_empty {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Prop :=
  set.Fset.is_empty (domain m).

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  is_empty (empty : fmap k v).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

(* Why3 assumption *)
Definition size {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Numbers.BinNums.Z :=
  set.Fset.cardinal (domain m).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a),
  (0%Z <= (length self))%Z /\
  ((size (to_fmap (elts self))) = (length self)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length self))%Z ->
   mem i (to_fmap (elts self))).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (j = i) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  ((get (make n v) i) = v).

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) <-> (r1 = r2).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) <-> ~ (r1 = r2).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) <-> (b1 = b2).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) <-> (u1 = u2).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Parameter infix_bscl:
  forall {a:Type} {a_WT:WhyType a}, reference -> t1 a -> Init.Datatypes.bool.

Axiom infix_bscl'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.true)) /\
  (~ mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.false)).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom add_map_others_unchanged :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) -> forall (q:reference),
  ((infix_bscl q m) = Init.Datatypes.true) -> ~ (q = p) ->
  ((mixfix_lbrb m' q) = (mixfix_lbrb m q)).

Axiom add_map_lookup :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) ->
  ((infix_bscl p m') = Init.Datatypes.true) /\ ((mixfix_lbrb m' p) = v).

(* Why3 assumption *)
Definition rgn := set.Fset.fset reference.

Parameter eqRgn:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom eqRgn'spec :
  forall (s1:set.Fset.fset reference) (s2:set.Fset.fset reference),
  ((eqRgn s1 s2) = Init.Datatypes.true) <-> set.Fset.infix_eqeq s1 s2.

Parameter singleton: reference -> set.Fset.fset reference.

Axiom singleton'spec'0 :
  forall (x:reference),
  ((singleton x) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))).

Axiom singleton'spec :
  forall (x:reference), ((set.Fset.cardinal (singleton x)) = 1%Z).

Axiom rgn_extensionality :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (r1 = r2) <-> set.Fset.infix_eqeq r1 r2.

Axiom rgn_union_emptyRgn_id_right :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.empty : set.Fset.fset reference)) = r).

Axiom rgn_union_emptyRgn_id_left :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union (set.Fset.empty : set.Fset.fset reference) r) = r).

Axiom rgn_union_same :
  forall (r:set.Fset.fset reference), ((set.Fset.union r r) = r).

Axiom rgn_union_assoc :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union (set.Fset.union r r') r'')).

Axiom rgn_union_swap1 :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union r' (set.Fset.union r r''))).

Axiom rgn_union_comm :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference),
  ((set.Fset.union r r') = (set.Fset.union r' r)).

Axiom rgn_inter_remove_sngl :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference) (p:reference),
  (r1 = (set.Fset.union r2 (singleton p))) -> ~ set.Fset.mem p r3 ->
  ((set.Fset.inter r1 r3) = (set.Fset.inter r2 r3)).

Axiom rgn_remove_not_in :
  forall (r:set.Fset.fset reference) (x:reference), ~ set.Fset.mem x r ->
  ((set.Fset.remove x r) = r).

Parameter infix_bssh:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom infix_bssh'def :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.true)) /\
  (~ set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.false)).

Axiom rgn_disjoint_union :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.union r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh r1 r3) = Init.Datatypes.true) /\
  ((infix_bssh r2 r3) = Init.Datatypes.true).

Axiom rgn_disjoint_inter :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.inter r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) =
   Init.Datatypes.true).

Axiom rgn_disjoint_singleton :
  forall (x:reference) (r:set.Fset.fset reference), ~ (x = nullConst) ->
  ((infix_bssh (singleton x) r) = Init.Datatypes.true) <-> ~ set.Fset.mem x r.

Axiom rgn_disjoint_comm :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  ((infix_bssh r1 r2) = Init.Datatypes.true) ->
  ((infix_bssh r2 r1) = Init.Datatypes.true).

Parameter rgnSubK:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset reference -> t1 a -> a ->
  set.Fset.fset reference.

Axiom rgnSubK'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (r:reference),
  set.Fset.mem r (rgnSubK s m v) <->
  ~ (r = nullConst) /\ set.Fset.mem r s /\ ((mixfix_lbrb m r) = v).

Axiom rgnSubK_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (x:reference),
  set.Fset.mem x (rgnSubK s m v) <->
  ~ (x = nullConst) /\ set.Fset.mem x s /\ ((mixfix_lbrb m x) = v).

Axiom rgnSubK_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  set.Fset.subset (rgnSubK s m v) s.

Axiom rgnSubK_idempotent :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  ((rgnSubK (rgnSubK s m v) m v) = (rgnSubK s m v)).

Axiom rgnSubK_monotonic :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (s':set.Fset.fset reference) (m:t1 a)
    (v:a),
  set.Fset.subset s s' -> set.Fset.subset (rgnSubK s m v) (rgnSubK s' m v).

Axiom rgnSubK_twice_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((rgnSubK (rgnSubK s m v) m v') =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom rgnSubK_inter_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((set.Fset.inter (rgnSubK s m v) (rgnSubK s m v')) =
   (set.Fset.empty : set.Fset.fset reference)).

(* Why3 assumption *)
Definition partialBijection (mTo:t1 reference) (mOf:t1 reference) : Prop :=
  ((size (to_fmap1 mTo)) = (size (to_fmap1 mOf))) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mTo x) mOf) = Init.Datatypes.true)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mOf y) mTo) = Init.Datatypes.true)) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((mixfix_lbrb mOf (mixfix_lbrb mTo x)) = x)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((mixfix_lbrb mTo (mixfix_lbrb mOf y)) = y)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant :
  forall (self:t2),
  partialBijection (lor self) (rol self) /\
  ~ ((infix_bscl nullConst (lor self)) = Init.Datatypes.true) /\
  ~ ((infix_bscl nullConst (rol self)) = Init.Datatypes.true).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

(* Why3 assumption *)
Definition idRef (pi:t2) (x:reference) (y:reference) : Prop :=
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) -> idRef pi x y -> idRef pi x' y ->
  (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef pi x y' -> (y = y').

(* Why3 assumption *)
Definition idRgn (pi:t2) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h).

Axiom idRgn_left :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (x:reference), ~ (x = nullConst) ->
  set.Fset.mem x g -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) h.

Axiom idRgn_right :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (y:reference), ~ (y = nullConst) ->
  set.Fset.mem y h -> ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) g.

Axiom idRgn_empty :
  forall (pi:t2),
  idRgn pi (set.Fset.empty : set.Fset.fset reference)
  (set.Fset.empty : set.Fset.fset reference).

(* Why3 assumption *)
Definition idRgn_sub {a:Type} {a_WT:WhyType a} (pi:t2) (m:t1 a) (m':t1 a)
    (v:a) (g:set.Fset.fset reference) (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
   set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
   set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g).

Axiom idRgn_sub_rgnSubK :
  forall {a:Type} {a_WT:WhyType a},
  forall (pi:t2) (m:t1 a) (m':t1 a) (v:a) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl x m) = Init.Datatypes.true)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl y m') = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb m p) = (mixfix_lbrb m' q))) ->
  idRgn_sub pi m m' v g h <-> idRgn pi (rgnSubK g m v) (rgnSubK h m' v).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec'6 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor (updateRefperm0 pi x y))) = Init.Datatypes.true) /\
  ((infix_bscl y (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'5 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y) /\
  ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x).

Axiom updateRefperm0'spec'4 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((infix_bscl x1 (lor (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'3 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl y1 (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'2 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom updateRefperm0'spec'1 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi) y1) =
   (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1)).

Axiom updateRefperm0'spec'0 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))).

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

(* Why3 assumption *)
Definition extends (pi0:t2) (pi1:t2) : Prop :=
  forall (x:reference), ((infix_bscl x (lor pi0)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi1)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x)).

Axiom extends_refl : forall (pi0:t2), extends pi0 pi0.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2), extends pi0 pi1 -> extends pi1 pi2 ->
  extends pi0 pi2.

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) -> ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  extends pi (updateRefperm0 pi x y).

Axiom extends_idRgn :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (rho:t2), extends pi rho -> idRgn rho g h.

Axiom extends_idRef :
  forall (pi:t2) (x:reference) (y:reference), idRef pi x y ->
  forall (rho:t2), extends pi rho -> idRef rho x y.

Axiom extends_exists : forall (pi:t2), exists pi0:t2, extends pi0 pi.

Parameter invert: t2 -> t2.

Axiom invert'spec :
  forall (pi:t2),
  ((lor (invert pi)) = (rol pi)) /\ ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> idRef (invert pi) y x.

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef (invert pi) y z -> (x = z).

(* Why3 assumption *)
Definition identity (pi:t2) (g1:set.Fset.fset reference)
    (g2:set.Fset.fset reference) : Prop :=
  forall (o:reference),
  (set.Fset.mem o g1 /\ set.Fset.mem o g2 <->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true)) /\
  (((infix_bscl o (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) o) = o)).

Axiom identity_in_refperm :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> set.Fset.mem x (set.Fset.inter g1 g2) ->
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = x).

Axiom identity_in_inter :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem x (set.Fset.inter g1 g2).

Axiom identity_ref_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  (x = (mixfix_lbrb (lor pi) x)).

Axiom identity_rgn_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (h1:set.Fset.fset reference) (h2:set.Fset.fset reference),
  identity pi g1 g2 -> idRgn pi h1 h2 -> (h1 = h2).

Axiom identity_null_notin :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> ~ set.Fset.mem nullConst (set.Fset.inter g1 g2).

Axiom identity_sym :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> identity pi g2 g1.

(* Why3 assumption *)
Definition intList := Init.Datatypes.list Numbers.BinNums.Z.

Parameter nil: Init.Datatypes.list Numbers.BinNums.Z.

Axiom nil_ax : (nil = Init.Datatypes.nil).

(* Why3 assumption *)
Fixpoint sumList
  (l:Init.Datatypes.list Numbers.BinNums.Z) {struct l}: Numbers.BinNums.Z :=
  match l with
  | Init.Datatypes.nil => 0%Z
  | Init.Datatypes.cons x r => (x + (sumList r))%Z
  end.

Parameter hd: Init.Datatypes.list Numbers.BinNums.Z -> Numbers.BinNums.Z.

Axiom hd_cons :
  forall (x:Numbers.BinNums.Z) (r:Init.Datatypes.list Numbers.BinNums.Z),
  ((hd (Init.Datatypes.cons x r)) = x).

Parameter tl:
  Init.Datatypes.list Numbers.BinNums.Z ->
  Init.Datatypes.list Numbers.BinNums.Z.

Axiom tl_cons :
  forall (x:Numbers.BinNums.Z) (r:Init.Datatypes.list Numbers.BinNums.Z),
  ((tl (Init.Datatypes.cons x r)) = r).

(* Why3 assumption *)
Inductive reftype :=
  | List : reftype
  | Node : reftype.
Axiom reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter alloct: state -> t1 reftype.

Parameter value: state -> t1 Numbers.BinNums.Z.

Parameter pub: state -> t1 Init.Datatypes.bool.

Parameter nxt: state -> t1 reference.

Parameter head: state -> t1 reference.

Parameter rep: state -> t1 (set.Fset.fset reference).

Axiom state'invariant :
  forall (self:state),
  ~ mem nullConst (to_fmap1 (alloct self)) /\
  (forall (p:reference), mem p (to_fmap1 (alloct self)) ->
   ((mixfix_lbrb (alloct self) p) = List) ->
   (mem p (to_fmap1 (head self)) /\ mem p (to_fmap1 (rep self))) /\
   (((mixfix_lbrb (head self) p) = nullConst) \/
    mem (mixfix_lbrb (head self) p) (to_fmap1 (alloct self)) /\
    ((mixfix_lbrb (alloct self) (mixfix_lbrb (head self) p)) = Node)) /\
   (forall (q:reference), set.Fset.mem q (mixfix_lbrb (rep self) p) ->
    (q = nullConst) \/ mem q (to_fmap1 (alloct self)))) /\
  (forall (p:reference), mem p (to_fmap1 (alloct self)) ->
   ((mixfix_lbrb (alloct self) p) = Node) ->
   (mem p (to_fmap1 (value self)) /\
    mem p (to_fmap1 (pub self)) /\ mem p (to_fmap1 (nxt self))) /\
   (((mixfix_lbrb (nxt self) p) = nullConst) \/
    mem (mixfix_lbrb (nxt self) p) (to_fmap1 (alloct self)) /\
    ((mixfix_lbrb (alloct self) (mixfix_lbrb (nxt self) p)) = Node))) /\
  ~ mem nullConst (to_fmap1 (value self)) /\
  ~ mem nullConst (to_fmap1 (pub self)) /\
  ~ mem nullConst (to_fmap1 (nxt self)) /\
  ~ mem nullConst (to_fmap1 (head self)) /\
  ~ mem nullConst (to_fmap1 (rep self)).

(* Why3 assumption *)
Definition isAllocated (s:state) (p:reference) : Prop :=
  mem p (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition isValidRgn (s:state) (r:set.Fset.fset reference) : Prop :=
  forall (q:reference), set.Fset.mem q r ->
  (q = nullConst) \/ mem q (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition typeofRgn (s:state) (r:set.Fset.fset reference)
    (types:Init.Datatypes.list reftype) : Prop :=
  forall (p:reference), set.Fset.mem p r ->
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\
  list.Mem.mem (mixfix_lbrb (alloct s) p) types.

(* Why3 assumption *)
Definition hasListType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\ ((mixfix_lbrb (alloct s) p) = List).

(* Why3 assumption *)
Definition hasNodeType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\ ((mixfix_lbrb (alloct s) p) = Node).

(* Why3 assumption *)
Definition okRefperm (sl:state) (sr:state) (pi:t2) : Prop :=
  (forall (p:reference), mem p (to_fmap1 (lor pi)) ->
   mem p (to_fmap1 (alloct sl))) /\
  (forall (q:reference), mem q (to_fmap1 (rol pi)) ->
   mem q (to_fmap1 (alloct sr))) /\
  (forall (p:reference) (q:reference), mem p (to_fmap1 (lor pi)) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct sl) p) = (mixfix_lbrb (alloct sr) q))).

Parameter img_value:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_value_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_value s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_rep:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_rep_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_rep s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = List) /\
   set.Fset.mem q r /\ set.Fset.mem p (mixfix_lbrb (rep s) q)).

Parameter img_pub:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_pub_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_pub s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_nxt:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_nxt_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_nxt s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = Node) /\
   set.Fset.mem q r /\ (p = (mixfix_lbrb (nxt s) q))).

Parameter img_head:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_head_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_head s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = List) /\
   set.Fset.mem q r /\ (p = (mixfix_lbrb (head s) q))).

(* Why3 assumption *)
Definition alloc_does_not_shrink (pre:state) (post:state) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  mem p (to_fmap1 (alloct post)) /\
  ((mixfix_lbrb (alloct pre) p) = (mixfix_lbrb (alloct post) p)).

(* Why3 assumption *)
Definition wr_frame_head (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = List) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (head pre) p) = (mixfix_lbrb (head post) p)).

(* Why3 assumption *)
Definition wr_frame_rep (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = List) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (rep pre) p) = (mixfix_lbrb (rep post) p)).

(* Why3 assumption *)
Definition wr_frame_value (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = Node) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (value pre) p) = (mixfix_lbrb (value post) p)).

(* Why3 assumption *)
Definition wr_frame_pub (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = Node) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (pub pre) p) = (mixfix_lbrb (pub post) p)).

(* Why3 assumption *)
Definition wr_frame_nxt (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = Node) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (nxt pre) p) = (mixfix_lbrb (nxt post) p)).

(* Why3 assumption *)
Definition agree_value (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   ((mixfix_lbrb (value sl) o) =
    (mixfix_lbrb (value sr) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_rep (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasListType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRgn pi (mixfix_lbrb (rep sl) o)
   (mixfix_lbrb (rep sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_pub (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   ((mixfix_lbrb (pub sl) o) =
    (mixfix_lbrb (pub sr) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_nxt (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRef pi (mixfix_lbrb (nxt sl) o)
   (mixfix_lbrb (nxt sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_head (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasListType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRef pi (mixfix_lbrb (head sl) o)
   (mixfix_lbrb (head sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_allfields (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  agree_head sl sr pi w /\
  agree_rep sl sr pi w /\
  agree_value sl sr pi w /\ agree_pub sl sr pi w /\ agree_nxt sl sr pi w.

(* Why3 assumption *)
Definition rep_closed (s:state) (xs:reference) : Prop :=
  hasListType s xs -> ~ (xs = nullConst) ->
  let rep2 := mixfix_lbrb (rep s) xs in
  typeofRgn s rep2 (Init.Datatypes.cons Node Init.Datatypes.nil) /\
  set.Fset.subset (img_nxt s rep2) rep2 /\
  set.Fset.mem nullConst rep2 /\ set.Fset.mem (mixfix_lbrb (head s) xs) rep2.

Axiom rep_closed_prop :
  forall (s:state), forall (xs:reference), isAllocated s xs ->
  hasListType s xs -> rep_closed s xs ->
  let rep1 := mixfix_lbrb (rep s) xs in
  forall (n:reference), isAllocated s n -> hasNodeType s n ->
  set.Fset.mem n rep1 -> set.Fset.mem (mixfix_lbrb (nxt s) n) rep1.

(* Why3 assumption *)
Inductive listpub: state -> reference ->
  Init.Datatypes.list Numbers.BinNums.Z -> Prop :=
  | listpub_nil : forall (s:state), listpub s nullConst nil
  | listpub_del :
      forall (s:state),
      forall (n2:reference) (l1:Init.Datatypes.list Numbers.BinNums.Z),
      isAllocated s n2 -> hasNodeType s n2 ->
      ((mixfix_lbrb (pub s) n2) = Init.Datatypes.false) ->
      listpub s (mixfix_lbrb (nxt s) n2) l1 -> listpub s n2 l1
  | listpub_pub :
      forall (s:state),
      forall (n5:reference) (l4:Init.Datatypes.list Numbers.BinNums.Z),
      isAllocated s n5 -> hasNodeType s n5 ->
      ((mixfix_lbrb (pub s) n5) = Init.Datatypes.true) ->
      listpub s (mixfix_lbrb (nxt s) n5) l4 ->
      listpub s n5 (Init.Datatypes.cons (mixfix_lbrb (value s) n5) l4).

(* Why3 assumption *)
Definition listpubL (s:state) (xs:reference)
    (ls:Init.Datatypes.list Numbers.BinNums.Z) : Prop :=
  hasListType s xs -> ~ (xs = nullConst) ->
  listpub s (mixfix_lbrb (head s) xs) ls.

Axiom listpub_nxt :
  forall (s:state),
  forall (n:reference) (xs:Init.Datatypes.list Numbers.BinNums.Z),
  isAllocated s n -> hasNodeType s n -> listpub s n xs ->
  exists xs':Init.Datatypes.list Numbers.BinNums.Z,
  listpub s (mixfix_lbrb (nxt s) n) xs'.

Parameter s: state.

Parameter xs: Init.Datatypes.list Numbers.BinNums.Z.

Parameter n: reference.

Axiom H : isAllocated s n.

Axiom H1 : hasNodeType s n.

Axiom H2 : listpub s n xs.

Parameter ys: Init.Datatypes.list Numbers.BinNums.Z.

Axiom H3 : listpub s n ys.

(* Why3 goal *)
Theorem listpub_unique : (xs = ys).
Proof.
pose proof H2. pose proof H3.
induction H0.
+ inversion H4; auto.
  - discriminate.

Qed.

