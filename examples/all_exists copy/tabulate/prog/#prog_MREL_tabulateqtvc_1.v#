(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

(* Why3 assumption *)
Definition infix_eqeq {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m1:fmap k v) (m2:fmap k v) : Prop :=
  set.Fset.infix_eqeq (domain m1) (domain m2) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))).

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v), infix_eqeq m1 m2 -> (m1 = m2).

(* Why3 assumption *)
Definition mem {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} (k1:k)
    (m:fmap k v) : Prop :=
  set.Fset.mem k1 (domain m).

(* Why3 assumption *)
Definition mapsto {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} 
    (k1:k) (v1:v) (m:fmap k v) : Prop :=
  mem k1 m /\ ((contents1 m k1) = v1).

Axiom mem_mapsto :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> mapsto k1 (contents1 m k1) m.

(* Why3 assumption *)
Definition is_empty {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Prop :=
  set.Fset.is_empty (domain m).

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  is_empty (empty : fmap k v).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

(* Why3 assumption *)
Definition size {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Numbers.BinNums.Z :=
  set.Fset.cardinal (domain m).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a),
  (0%Z <= (length self))%Z /\
  ((size (to_fmap (elts self))) = (length self)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length self))%Z ->
   mem i (to_fmap (elts self))).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (j = i) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  ((get (make n v) i) = v).

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) <-> (r1 = r2).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) <-> ~ (r1 = r2).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) <-> (b1 = b2).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) <-> (u1 = u2).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Parameter infix_bscl:
  forall {a:Type} {a_WT:WhyType a}, reference -> t1 a -> Init.Datatypes.bool.

Axiom infix_bscl'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.true)) /\
  (~ mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.false)).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom add_map_others_unchanged :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) -> forall (q:reference),
  ((infix_bscl q m) = Init.Datatypes.true) -> ~ (q = p) ->
  ((mixfix_lbrb m' q) = (mixfix_lbrb m q)).

Axiom add_map_lookup :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) ->
  ((infix_bscl p m') = Init.Datatypes.true) /\ ((mixfix_lbrb m' p) = v).

(* Why3 assumption *)
Definition rgn := set.Fset.fset reference.

Parameter eqRgn:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom eqRgn'spec :
  forall (s1:set.Fset.fset reference) (s2:set.Fset.fset reference),
  ((eqRgn s1 s2) = Init.Datatypes.true) <-> set.Fset.infix_eqeq s1 s2.

Parameter singleton: reference -> set.Fset.fset reference.

Axiom singleton'spec'0 :
  forall (x:reference),
  ((singleton x) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))).

Axiom singleton'spec :
  forall (x:reference), ((set.Fset.cardinal (singleton x)) = 1%Z).

Axiom rgn_extensionality :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (r1 = r2) <-> set.Fset.infix_eqeq r1 r2.

Axiom rgn_union_emptyRgn_id_right :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.empty : set.Fset.fset reference)) = r).

Axiom rgn_union_emptyRgn_id_left :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union (set.Fset.empty : set.Fset.fset reference) r) = r).

Axiom rgn_union_same :
  forall (r:set.Fset.fset reference), ((set.Fset.union r r) = r).

Axiom rgn_union_assoc :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union (set.Fset.union r r') r'')).

Axiom rgn_union_swap1 :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union r' (set.Fset.union r r''))).

Axiom rgn_union_comm :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference),
  ((set.Fset.union r r') = (set.Fset.union r' r)).

Axiom rgn_inter_remove_sngl :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference) (p:reference),
  (r1 = (set.Fset.union r2 (singleton p))) -> ~ set.Fset.mem p r3 ->
  ((set.Fset.inter r1 r3) = (set.Fset.inter r2 r3)).

Axiom rgn_remove_not_in :
  forall (r:set.Fset.fset reference) (x:reference), ~ set.Fset.mem x r ->
  ((set.Fset.remove x r) = r).

Parameter infix_bssh:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom infix_bssh'def :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.true)) /\
  (~ set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.false)).

Axiom rgn_disjoint_union :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.union r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh r1 r3) = Init.Datatypes.true) /\
  ((infix_bssh r2 r3) = Init.Datatypes.true).

Axiom rgn_disjoint_inter :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.inter r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) =
   Init.Datatypes.true).

Axiom rgn_disjoint_singleton :
  forall (x:reference) (r:set.Fset.fset reference), ~ (x = nullConst) ->
  ((infix_bssh (singleton x) r) = Init.Datatypes.true) <-> ~ set.Fset.mem x r.

Axiom rgn_disjoint_comm :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  ((infix_bssh r1 r2) = Init.Datatypes.true) ->
  ((infix_bssh r2 r1) = Init.Datatypes.true).

Parameter rgnSubK:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset reference -> t1 a -> a ->
  set.Fset.fset reference.

Axiom rgnSubK'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (r:reference),
  set.Fset.mem r (rgnSubK s m v) <->
  ~ (r = nullConst) /\ set.Fset.mem r s /\ ((mixfix_lbrb m r) = v).

Axiom rgnSubK_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (x:reference),
  set.Fset.mem x (rgnSubK s m v) <->
  ~ (x = nullConst) /\ set.Fset.mem x s /\ ((mixfix_lbrb m x) = v).

Axiom rgnSubK_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  set.Fset.subset (rgnSubK s m v) s.

Axiom rgnSubK_idempotent :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  ((rgnSubK (rgnSubK s m v) m v) = (rgnSubK s m v)).

Axiom rgnSubK_monotonic :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (s':set.Fset.fset reference) (m:t1 a)
    (v:a),
  set.Fset.subset s s' -> set.Fset.subset (rgnSubK s m v) (rgnSubK s' m v).

Axiom rgnSubK_twice_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((rgnSubK (rgnSubK s m v) m v') =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom rgnSubK_inter_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((set.Fset.inter (rgnSubK s m v) (rgnSubK s m v')) =
   (set.Fset.empty : set.Fset.fset reference)).

(* Why3 assumption *)
Definition partialBijection (mTo:t1 reference) (mOf:t1 reference) : Prop :=
  ((size (to_fmap1 mTo)) = (size (to_fmap1 mOf))) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mTo x) mOf) = Init.Datatypes.true)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mOf y) mTo) = Init.Datatypes.true)) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((mixfix_lbrb mOf (mixfix_lbrb mTo x)) = x)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((mixfix_lbrb mTo (mixfix_lbrb mOf y)) = y)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant :
  forall (self:t2),
  partialBijection (lor self) (rol self) /\
  ~ ((infix_bscl nullConst (lor self)) = Init.Datatypes.true) /\
  ~ ((infix_bscl nullConst (rol self)) = Init.Datatypes.true).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

(* Why3 assumption *)
Definition idRef (pi:t2) (x:reference) (y:reference) : Prop :=
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) -> idRef pi x y -> idRef pi x' y ->
  (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef pi x y' -> (y = y').

(* Why3 assumption *)
Definition idRgn (pi:t2) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h).

Axiom idRgn_left :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (x:reference), ~ (x = nullConst) ->
  set.Fset.mem x g -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) h.

Axiom idRgn_right :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (y:reference), ~ (y = nullConst) ->
  set.Fset.mem y h -> ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) g.

Axiom idRgn_empty :
  forall (pi:t2),
  idRgn pi (set.Fset.empty : set.Fset.fset reference)
  (set.Fset.empty : set.Fset.fset reference).

(* Why3 assumption *)
Definition idRgn_sub {a:Type} {a_WT:WhyType a} (pi:t2) (m:t1 a) (m':t1 a)
    (v:a) (g:set.Fset.fset reference) (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
   set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
   set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g).

Axiom idRgn_sub_rgnSubK :
  forall {a:Type} {a_WT:WhyType a},
  forall (pi:t2) (m:t1 a) (m':t1 a) (v:a) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl x m) = Init.Datatypes.true)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl y m') = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb m p) = (mixfix_lbrb m' q))) ->
  idRgn_sub pi m m' v g h <-> idRgn pi (rgnSubK g m v) (rgnSubK h m' v).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec'6 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor (updateRefperm0 pi x y))) = Init.Datatypes.true) /\
  ((infix_bscl y (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'5 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y) /\
  ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x).

Axiom updateRefperm0'spec'4 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((infix_bscl x1 (lor (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'3 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl y1 (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'2 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom updateRefperm0'spec'1 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi) y1) =
   (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1)).

Axiom updateRefperm0'spec'0 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))).

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

(* Why3 assumption *)
Definition extends (pi0:t2) (pi1:t2) : Prop :=
  forall (x:reference), ((infix_bscl x (lor pi0)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi1)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x)).

Axiom extends_refl : forall (pi0:t2), extends pi0 pi0.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2), extends pi0 pi1 -> extends pi1 pi2 ->
  extends pi0 pi2.

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) -> ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  extends pi (updateRefperm0 pi x y).

Axiom extends_idRgn :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (rho:t2), extends pi rho -> idRgn rho g h.

Axiom extends_idRef :
  forall (pi:t2) (x:reference) (y:reference), idRef pi x y ->
  forall (rho:t2), extends pi rho -> idRef rho x y.

Axiom extends_exists : forall (pi:t2), exists pi0:t2, extends pi0 pi.

Parameter invert: t2 -> t2.

Axiom invert'spec :
  forall (pi:t2),
  ((lor (invert pi)) = (rol pi)) /\ ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> idRef (invert pi) y x.

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef (invert pi) y z -> (x = z).

(* Why3 assumption *)
Definition identity (pi:t2) (g1:set.Fset.fset reference)
    (g2:set.Fset.fset reference) : Prop :=
  forall (o:reference),
  (set.Fset.mem o g1 /\ set.Fset.mem o g2 <->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true)) /\
  (((infix_bscl o (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) o) = o)).

Axiom identity_in_refperm :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> set.Fset.mem x (set.Fset.inter g1 g2) ->
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = x).

Axiom identity_in_inter :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem x (set.Fset.inter g1 g2).

Axiom identity_ref_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  (x = (mixfix_lbrb (lor pi) x)).

Axiom identity_rgn_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (h1:set.Fset.fset reference) (h2:set.Fset.fset reference),
  identity pi g1 g2 -> idRgn pi h1 h2 -> (h1 = h2).

Axiom identity_null_notin :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> ~ set.Fset.mem nullConst (set.Fset.inter g1 g2).

Axiom identity_sym :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> identity pi g2 g1.

(* Why3 assumption *)
Inductive reftype :=
  | List : reftype
  | Node : reftype.
Axiom reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter alloct: state -> t1 reftype.

Parameter value: state -> t1 Numbers.BinNums.Z.

Parameter nxt: state -> t1 reference.

Parameter head: state -> t1 reference.

Parameter rep: state -> t1 (set.Fset.fset reference).

Axiom state'invariant :
  forall (self:state),
  ~ mem nullConst (to_fmap1 (alloct self)) /\
  (forall (p:reference), mem p (to_fmap1 (alloct self)) ->
   ((mixfix_lbrb (alloct self) p) = List) ->
   (mem p (to_fmap1 (head self)) /\ mem p (to_fmap1 (rep self))) /\
   (((mixfix_lbrb (head self) p) = nullConst) \/
    mem (mixfix_lbrb (head self) p) (to_fmap1 (alloct self)) /\
    ((mixfix_lbrb (alloct self) (mixfix_lbrb (head self) p)) = Node)) /\
   (forall (q:reference), set.Fset.mem q (mixfix_lbrb (rep self) p) ->
    (q = nullConst) \/ mem q (to_fmap1 (alloct self)))) /\
  (forall (p:reference), mem p (to_fmap1 (alloct self)) ->
   ((mixfix_lbrb (alloct self) p) = Node) ->
   (mem p (to_fmap1 (value self)) /\ mem p (to_fmap1 (nxt self))) /\
   (((mixfix_lbrb (nxt self) p) = nullConst) \/
    mem (mixfix_lbrb (nxt self) p) (to_fmap1 (alloct self)) /\
    ((mixfix_lbrb (alloct self) (mixfix_lbrb (nxt self) p)) = Node))) /\
  ~ mem nullConst (to_fmap1 (value self)) /\
  ~ mem nullConst (to_fmap1 (nxt self)) /\
  ~ mem nullConst (to_fmap1 (head self)) /\
  ~ mem nullConst (to_fmap1 (rep self)).

(* Why3 assumption *)
Definition isAllocated (s:state) (p:reference) : Prop :=
  mem p (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition isValidRgn (s:state) (r:set.Fset.fset reference) : Prop :=
  forall (q:reference), set.Fset.mem q r ->
  (q = nullConst) \/ mem q (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition typeofRgn (s:state) (r:set.Fset.fset reference)
    (types:Init.Datatypes.list reftype) : Prop :=
  forall (p:reference), set.Fset.mem p r ->
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\
  list.Mem.mem (mixfix_lbrb (alloct s) p) types.

(* Why3 assumption *)
Definition hasListType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\ ((mixfix_lbrb (alloct s) p) = List).

(* Why3 assumption *)
Definition hasNodeType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\ ((mixfix_lbrb (alloct s) p) = Node).

(* Why3 assumption *)
Definition okRefperm (sl:state) (sr:state) (pi:t2) : Prop :=
  (forall (p:reference), mem p (to_fmap1 (lor pi)) ->
   mem p (to_fmap1 (alloct sl))) /\
  (forall (q:reference), mem q (to_fmap1 (rol pi)) ->
   mem q (to_fmap1 (alloct sr))) /\
  (forall (p:reference) (q:reference), mem p (to_fmap1 (lor pi)) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct sl) p) = (mixfix_lbrb (alloct sr) q))).

Parameter img_value:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_value_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_value s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_rep:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_rep_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_rep s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = List) /\
   set.Fset.mem q r /\ set.Fset.mem p (mixfix_lbrb (rep s) q)).

Parameter img_nxt:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_nxt_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_nxt s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = Node) /\
   set.Fset.mem q r /\ (p = (mixfix_lbrb (nxt s) q))).

Parameter img_head:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_head_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_head s r) <->
  (exists q:reference,
   mem q (to_fmap1 (alloct s)) /\
   ((mixfix_lbrb (alloct s) q) = List) /\
   set.Fset.mem q r /\ (p = (mixfix_lbrb (head s) q))).

(* Why3 assumption *)
Definition alloc_does_not_shrink (pre:state) (post:state) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  mem p (to_fmap1 (alloct post)) /\
  ((mixfix_lbrb (alloct pre) p) = (mixfix_lbrb (alloct post) p)).

(* Why3 assumption *)
Definition wr_frame_head (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = List) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (head pre) p) = (mixfix_lbrb (head post) p)).

(* Why3 assumption *)
Definition wr_frame_rep (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = List) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (rep pre) p) = (mixfix_lbrb (rep post) p)).

(* Why3 assumption *)
Definition wr_frame_value (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = Node) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (value pre) p) = (mixfix_lbrb (value post) p)).

(* Why3 assumption *)
Definition wr_frame_nxt (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  ((mixfix_lbrb (alloct post) p) = Node) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (nxt pre) p) = (mixfix_lbrb (nxt post) p)).

(* Why3 assumption *)
Definition agree_value (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   ((mixfix_lbrb (value sl) o) =
    (mixfix_lbrb (value sr) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_rep (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasListType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRgn pi (mixfix_lbrb (rep sl) o)
   (mixfix_lbrb (rep sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_nxt (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRef pi (mixfix_lbrb (nxt sl) o)
   (mixfix_lbrb (nxt sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_head (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasListType sl o ->
   set.Fset.mem o w ->
   mem o (to_fmap1 (lor pi)) /\
   idRef pi (mixfix_lbrb (head sl) o)
   (mixfix_lbrb (head sr) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_allfields (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  agree_head sl sr pi w /\
  agree_rep sl sr pi w /\ agree_value sl sr pi w /\ agree_nxt sl sr pi w.

(* Why3 assumption *)
Definition rep_closed (s:state) (xs:reference) : Prop :=
  hasListType s xs -> ~ (xs = nullConst) ->
  let rep1 := mixfix_lbrb (rep s) xs in
  typeofRgn s rep1 (Init.Datatypes.cons Node Init.Datatypes.nil) /\
  set.Fset.subset (img_nxt s rep1) rep1 /\
  set.Fset.mem nullConst rep1 /\ set.Fset.mem (mixfix_lbrb (head s) xs) rep1.

Axiom rep_closed_def :
  forall (s:state), forall (xs:reference), isAllocated s xs ->
  hasListType s xs -> rep_closed s xs ->
  let rep1 := mixfix_lbrb (rep s) xs in
  forall (n:reference), isAllocated s n -> hasNodeType s n ->
  set.Fset.mem n rep1 -> set.Fset.mem (mixfix_lbrb (nxt s) n) rep1.

Parameter l_s: state.

Parameter r_s: state.

Parameter pi4: t2.

Parameter l_n: Numbers.BinNums.Z.

Parameter r_n: Numbers.BinNums.Z.

Axiom Requires : okRefperm l_s r_s pi4.

Axiom Requires1 : (l_n = r_n).

Axiom H : (0%Z < l_n)%Z.

Axiom H1 : (0%Z < r_n)%Z.

Parameter l_s1: state.

Axiom H2 : ((value l_s1) = (value l_s)).

Axiom H3 : ((nxt l_s1) = (nxt l_s)).

Axiom Ensures :
  forall (p:reference), mem p (to_fmap1 (alloct l_s)) ->
  mem p (to_fmap1 (alloct l_s1)) /\
  ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct l_s1) p)).

Parameter l_l: reference.

Axiom Ensures1 : ~ mem l_l (to_fmap1 (alloct l_s)).

Axiom Ensures2 :
  ((to_fmap1 (alloct l_s1)) = (add l_l List (to_fmap1 (alloct l_s)))).

Axiom Ensures3 : ~ (l_l = nullConst).

Axiom Ensures4 : hasListType l_s1 l_l.

Axiom Ensures5 :
  ((to_fmap1 (head l_s1)) = (add l_l nullConst (to_fmap1 (head l_s)))).

Axiom Ensures6 :
  ((to_fmap1 (rep l_s1)) =
   (add l_l (set.Fset.empty : set.Fset.fset reference) (to_fmap1 (rep l_s)))).

Parameter r_s1: state.

Axiom H4 : ((value r_s1) = (value r_s)).

Axiom H5 : ((nxt r_s1) = (nxt r_s)).

Axiom Ensures7 :
  forall (p:reference), mem p (to_fmap1 (alloct r_s)) ->
  mem p (to_fmap1 (alloct r_s1)) /\
  ((mixfix_lbrb (alloct r_s) p) = (mixfix_lbrb (alloct r_s1) p)).

Parameter r_l: reference.

Axiom Ensures8 : ~ mem r_l (to_fmap1 (alloct r_s)).

Axiom Ensures9 :
  ((to_fmap1 (alloct r_s1)) = (add r_l List (to_fmap1 (alloct r_s)))).

Axiom Ensures10 : ~ (r_l = nullConst).

Axiom Ensures11 : hasListType r_s1 r_l.

Axiom Ensures12 :
  ((to_fmap1 (head r_s1)) = (add r_l nullConst (to_fmap1 (head r_s)))).

Axiom Ensures13 :
  ((to_fmap1 (rep r_s1)) =
   (add r_l (set.Fset.empty : set.Fset.fset reference) (to_fmap1 (rep r_s)))).

Parameter pi41: t2.

Axiom Ensures14 : ((infix_bscl l_l (lor pi41)) = Init.Datatypes.true).

Axiom Ensures15 : ((infix_bscl r_l (rol pi41)) = Init.Datatypes.true).

Axiom Ensures16 : ((mixfix_lbrb (lor pi41) l_l) = r_l).

Axiom Ensures17 : ((mixfix_lbrb (rol pi41) r_l) = l_l).

Axiom Ensures18 :
  forall (x:reference), ((infix_bscl x (lor pi4)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi41)) = Init.Datatypes.true).

Axiom Ensures19 :
  forall (y:reference), ((infix_bscl y (rol pi4)) = Init.Datatypes.true) ->
  ((infix_bscl y (rol pi41)) = Init.Datatypes.true).

Axiom Ensures20 :
  forall (x:reference), ((infix_bscl x (lor pi4)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi4) x) = (mixfix_lbrb (lor pi41) x)).

Axiom Ensures21 :
  forall (y:reference), ((infix_bscl y (rol pi4)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi4) y) = (mixfix_lbrb (rol pi41) y)).

Axiom Ensures22 :
  ((to_fmap1 (lor pi41)) = (add l_l r_l (to_fmap1 (lor pi4)))).

Axiom Ensures23 :
  ((to_fmap1 (rol pi41)) = (add r_l l_l (to_fmap1 (rol pi4)))).

Axiom Ensures24 : idRef pi41 l_l r_l.

Parameter r_s2: state.

Parameter l_s2: state.

Axiom H6 : ((alloct r_s2) = (alloct r_s1)).

Axiom H7 : ((value r_s2) = (value r_s1)).

Axiom H8 : ((nxt r_s2) = (nxt r_s1)).

Axiom H9 : ((alloct l_s2) = (alloct l_s1)).

Axiom H10 : ((value l_s2) = (value l_s1)).

Axiom H11 : ((nxt l_s2) = (nxt l_s1)).

Axiom Ensures25 : wr_frame_head l_s1 l_s2 (singleton l_l).

Axiom Ensures26 : wr_frame_rep l_s1 l_s2 (singleton l_l).

Axiom Ensures27 : wr_frame_head r_s1 r_s2 (singleton r_l).

Axiom Ensures28 : wr_frame_rep r_s1 r_s2 (singleton r_l).

Axiom Ensures29 : okRefperm l_s2 r_s2 pi41.

Axiom H12 : agree_rep l_s2 r_s2 pi41 (singleton l_l).

Axiom H13 : agree_rep r_s2 l_s2 (invert pi41) (singleton r_l).

Axiom H14 : agree_head l_s2 r_s2 pi41 (singleton l_l).

Axiom H15 : agree_head r_s2 l_s2 (invert pi41) (singleton r_l).

Axiom H16 : rep_closed l_s2 l_l.

Axiom H17 : rep_closed r_s2 r_l.

Axiom H18 : ((mixfix_lbrb (rep l_s2) l_l) = (singleton nullConst)).

Axiom H19 : ((mixfix_lbrb (rep r_s2) r_l) = (singleton nullConst)).

Axiom H20 : ((mixfix_lbrb (head l_s2) l_l) = nullConst).

Axiom H21 : ((mixfix_lbrb (head r_s2) r_l) = nullConst).

Parameter l_i: Numbers.BinNums.Z.

Axiom Ensures30 : (l_i = 0%Z).

Parameter r_i: Numbers.BinNums.Z.

Axiom Ensures31 : (r_i = 1%Z).

Parameter r_i1: Numbers.BinNums.Z.

Parameter l_i1: Numbers.BinNums.Z.

Parameter r_p: reference.

Parameter l_p: reference.

Parameter pi42: t2.

Parameter r_s3: state.

Parameter l_s3: state.

Axiom H22 : hasListType l_s3 l_l.

Axiom H23 : hasNodeType l_s3 l_p.

Axiom H24 : hasListType l_s3 nullConst.

Axiom H25 : hasListType r_s3 r_l.

Axiom H26 : hasNodeType r_s3 r_p.

Axiom H27 : hasListType r_s3 nullConst.

Axiom LoopInvariant : wr_frame_nxt l_s l_s3 (mixfix_lbrb (rep l_s3) l_l).

Axiom LoopInvariant1 : wr_frame_head l_s l_s3 (mixfix_lbrb (rep l_s3) l_l).

Axiom LoopInvariant2 :
  wr_frame_rep l_s l_s3
  (set.Fset.union (singleton l_l) (mixfix_lbrb (rep l_s3) l_l)).

Axiom LoopInvariant3 : wr_frame_value l_s l_s3 (mixfix_lbrb (rep l_s3) l_l).

Axiom LoopInvariant4 : alloc_does_not_shrink l_s l_s3.

Axiom LoopInvariant5 : wr_frame_nxt r_s r_s3 (mixfix_lbrb (rep r_s3) r_l).

Axiom LoopInvariant6 : wr_frame_head r_s r_s3 (mixfix_lbrb (rep r_s3) r_l).

Axiom LoopInvariant7 :
  wr_frame_rep r_s r_s3
  (set.Fset.union (singleton r_l) (mixfix_lbrb (rep r_s3) r_l)).

Axiom LoopInvariant8 : wr_frame_value r_s r_s3 (mixfix_lbrb (rep r_s3) r_l).

Axiom LoopInvariant9 : alloc_does_not_shrink r_s r_s3.

Axiom LoopInvariant10 : okRefperm l_s3 r_s3 pi42.

Axiom H28 : (0%Z <= l_i1)%Z.

Axiom H29 : (l_i1 <= l_n)%Z.

Axiom H30 : (1%Z <= r_i1)%Z.

Axiom H31 : (r_i1 <= (r_n + 1%Z)%Z)%Z.

Axiom H32 : rep_closed l_s3 l_l.

Axiom H33 : rep_closed r_s3 r_l.

Axiom H34 : True.

Axiom H35 : set.Fset.mem l_p (mixfix_lbrb (rep l_s3) l_l).

Axiom H36 : True.

Axiom H37 : set.Fset.mem r_p (mixfix_lbrb (rep r_s3) r_l).

Axiom H38 : True.

Axiom H39 : True.

Axiom H40 :
  ((infix_bssh (mixfix_lbrb (rep l_s3) l_l) (domain (to_fmap1 (alloct l_s))))
   = Init.Datatypes.true).

Axiom H41 : True.

Axiom H42 : True.

Axiom H43 :
  ((infix_bssh (mixfix_lbrb (rep r_s3) r_l) (domain (to_fmap1 (alloct r_s))))
   = Init.Datatypes.true).

Axiom LoopInvariant11 : ((l_i1 + 1%Z)%Z = r_i1).

Axiom H44 : idRef pi42 l_l r_l.

Axiom H45 : agree_rep l_s3 r_s3 pi42 (singleton l_l).

Axiom H46 : agree_rep r_s3 l_s3 (invert pi42) (singleton r_l).

Axiom H47 : agree_head l_s3 r_s3 pi42 (singleton l_l).

Axiom H48 : agree_head r_s3 l_s3 (invert pi42) (singleton r_l).

Axiom H49 : True.

Axiom H50 : True.

Axiom H51 :
  agree_head l_s3 r_s3 pi42
  (set.Fset.diff (domain (to_fmap1 (alloct l_s3)))
   (domain (to_fmap1 (alloct l_s)))).

Axiom H52 :
  agree_rep l_s3 r_s3 pi42
  (set.Fset.diff (domain (to_fmap1 (alloct l_s3)))
   (domain (to_fmap1 (alloct l_s)))).

Axiom H53 :
  agree_value l_s3 r_s3 pi42
  (set.Fset.diff (domain (to_fmap1 (alloct l_s3)))
   (domain (to_fmap1 (alloct l_s)))).

Axiom H54 :
  agree_nxt l_s3 r_s3 pi42
  (set.Fset.diff (domain (to_fmap1 (alloct l_s3)))
   (domain (to_fmap1 (alloct l_s)))).

Axiom H55 :
  agree_head r_s3 l_s3 (invert pi42)
  (set.Fset.diff (domain (to_fmap1 (alloct r_s3)))
   (domain (to_fmap1 (alloct r_s)))).

Axiom H56 :
  agree_rep r_s3 l_s3 (invert pi42)
  (set.Fset.diff (domain (to_fmap1 (alloct r_s3)))
   (domain (to_fmap1 (alloct r_s)))).

Axiom H57 :
  agree_value r_s3 l_s3 (invert pi42)
  (set.Fset.diff (domain (to_fmap1 (alloct r_s3)))
   (domain (to_fmap1 (alloct r_s)))).

Axiom H58 :
  agree_nxt r_s3 l_s3 (invert pi42)
  (set.Fset.diff (domain (to_fmap1 (alloct r_s3)))
   (domain (to_fmap1 (alloct r_s)))).

Axiom H59 : agree_head l_s3 r_s3 pi42 (mixfix_lbrb (rep l_s3) l_l).

Axiom H60 : agree_rep l_s3 r_s3 pi42 (mixfix_lbrb (rep l_s3) l_l).

Axiom H61 : agree_value l_s3 r_s3 pi42 (mixfix_lbrb (rep l_s3) l_l).

Axiom H62 : agree_nxt l_s3 r_s3 pi42 (mixfix_lbrb (rep l_s3) l_l).

Axiom H63 : agree_head r_s3 l_s3 (invert pi42) (mixfix_lbrb (rep r_s3) r_l).

Axiom H64 : agree_rep r_s3 l_s3 (invert pi42) (mixfix_lbrb (rep r_s3) r_l).

Axiom H65 : agree_value r_s3 l_s3 (invert pi42) (mixfix_lbrb (rep r_s3) r_l).

Axiom H66 : agree_nxt r_s3 l_s3 (invert pi42) (mixfix_lbrb (rep r_s3) r_l).

Axiom H67 : True.

Axiom H68 : True.

Axiom H69 :
  set.Fset.subset
  (set.Fset.diff
   (set.Fset.diff (domain (to_fmap1 (alloct l_s3)))
    (domain (to_fmap1 (alloct l_s))))
   (singleton l_l))
  (mixfix_lbrb (rep l_s3) l_l).

Axiom H70 :
  set.Fset.subset
  (set.Fset.diff
   (set.Fset.diff (domain (to_fmap1 (alloct r_s3)))
    (domain (to_fmap1 (alloct r_s))))
   (singleton r_l))
  (mixfix_lbrb (rep r_s3) r_l).

Axiom LoopInvariant12 : (l_i1 < l_n)%Z <-> (r_i1 <= r_n)%Z.

Axiom H71 : (l_i1 < l_n)%Z.

Parameter l_i2: Numbers.BinNums.Z.

Axiom Ensures32 : (l_i2 = (l_i1 + 1%Z)%Z).

Axiom Assert : (l_i2 = r_i1).

Axiom Ensures33 : okRefperm l_s3 r_s3 pi42.

Parameter l_k: Numbers.BinNums.Z.

Parameter r_k: Numbers.BinNums.Z.

Axiom Ensures34 : (l_k = r_k).

Axiom Assert1 : (l_k = r_k).

Parameter l_s4: state.

Axiom H72 : ((head l_s4) = (head l_s3)).

Axiom H73 : ((rep l_s4) = (rep l_s3)).

Axiom Ensures35 :
  forall (p:reference), mem p (to_fmap1 (alloct l_s3)) ->
  mem p (to_fmap1 (alloct l_s4)) /\
  ((mixfix_lbrb (alloct l_s3) p) = (mixfix_lbrb (alloct l_s4) p)).

Parameter l_p1: reference.

Axiom Ensures36 : ~ mem l_p1 (to_fmap1 (alloct l_s3)).

Axiom Ensures37 :
  ((to_fmap1 (alloct l_s4)) = (add l_p1 Node (to_fmap1 (alloct l_s3)))).

Axiom Ensures38 : ~ (l_p1 = nullConst).

Axiom Ensures39 : hasNodeType l_s4 l_p1.

Axiom Ensures40 :
  ((to_fmap1 (value l_s4)) = (add l_p1 0%Z (to_fmap1 (value l_s3)))).

Axiom Ensures41 :
  ((to_fmap1 (nxt l_s4)) = (add l_p1 nullConst (to_fmap1 (nxt l_s3)))).

Parameter r_s4: state.

Axiom H74 : ((head r_s4) = (head r_s3)).

Axiom H75 : ((rep r_s4) = (rep r_s3)).

Axiom Ensures42 :
  forall (p:reference), mem p (to_fmap1 (alloct r_s3)) ->
  mem p (to_fmap1 (alloct r_s4)) /\
  ((mixfix_lbrb (alloct r_s3) p) = (mixfix_lbrb (alloct r_s4) p)).

Parameter r_p1: reference.

Axiom Ensures43 : ~ mem r_p1 (to_fmap1 (alloct r_s3)).

Axiom Ensures44 :
  ((to_fmap1 (alloct r_s4)) = (add r_p1 Node (to_fmap1 (alloct r_s3)))).

Axiom Ensures45 : ~ (r_p1 = nullConst).

Axiom Ensures46 : hasNodeType r_s4 r_p1.

Axiom Ensures47 :
  ((to_fmap1 (value r_s4)) = (add r_p1 0%Z (to_fmap1 (value r_s3)))).

Axiom Ensures48 :
  ((to_fmap1 (nxt r_s4)) = (add r_p1 nullConst (to_fmap1 (nxt r_s3)))).

Parameter pi43: t2.

Axiom Ensures49 : ((infix_bscl l_p1 (lor pi43)) = Init.Datatypes.true).

Axiom Ensures50 : ((infix_bscl r_p1 (rol pi43)) = Init.Datatypes.true).

Axiom Ensures51 : ((mixfix_lbrb (lor pi43) l_p1) = r_p1).

Axiom Ensures52 : ((mixfix_lbrb (rol pi43) r_p1) = l_p1).

Axiom Ensures53 :
  forall (x:reference), ((infix_bscl x (lor pi42)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi43)) = Init.Datatypes.true).

Axiom Ensures54 :
  forall (y:reference), ((infix_bscl y (rol pi42)) = Init.Datatypes.true) ->
  ((infix_bscl y (rol pi43)) = Init.Datatypes.true).

Axiom Ensures55 :
  forall (x:reference), ((infix_bscl x (lor pi42)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi42) x) = (mixfix_lbrb (lor pi43) x)).

Axiom Ensures56 :
  forall (y:reference), ((infix_bscl y (rol pi42)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi42) y) = (mixfix_lbrb (rol pi43) y)).

Axiom Ensures57 :
  ((to_fmap1 (lor pi43)) = (add l_p1 r_p1 (to_fmap1 (lor pi42)))).

Axiom Ensures58 :
  ((to_fmap1 (rol pi43)) = (add r_p1 l_p1 (to_fmap1 (rol pi42)))).

Axiom Ensures59 : idRef pi43 l_p1 r_p1.

Parameter r_s5: state.

Parameter l_s5: state.

Axiom H76 : ((alloct r_s5) = (alloct r_s4)).

Axiom H77 : ((nxt r_s5) = (nxt r_s4)).

Axiom H78 : ((head r_s5) = (head r_s4)).

Axiom H79 : ((rep r_s5) = (rep r_s4)).

Axiom H80 : ((alloct l_s5) = (alloct l_s4)).

Axiom H81 : ((nxt l_s5) = (nxt l_s4)).

Axiom H82 : ((head l_s5) = (head l_s4)).

Axiom H83 : ((rep l_s5) = (rep l_s4)).

Axiom Ensures60 : wr_frame_value l_s4 l_s5 (singleton l_p1).

Axiom Ensures61 : wr_frame_value r_s4 r_s5 (singleton r_p1).

Axiom Ensures62 : okRefperm l_s5 r_s5 pi43.

Axiom H84 : agree_value l_s5 r_s5 pi43 (singleton l_p1).

Axiom H85 : agree_value r_s5 l_s5 (invert pi43) (singleton r_p1).

Axiom H86 : ((mixfix_lbrb (value l_s5) l_p1) = l_k).

Axiom H87 : ((mixfix_lbrb (value r_s5) r_p1) = r_k).

Axiom H88 : ((mixfix_lbrb (nxt l_s5) l_p1) = nullConst).

Axiom H89 : ((mixfix_lbrb (nxt r_s5) r_p1) = nullConst).

Axiom H90 : agree_allfields l_s5 r_s5 pi43 (singleton l_p1).

Axiom H91 : agree_allfields r_s5 l_s5 (invert pi43) (singleton r_p1).

Axiom Ensures63 :
  ((mixfix_lbrb (head l_s5) l_l) = (find l_l (to_fmap1 (head l_s5)))).

Parameter l_hd: reference.

Axiom Ensures64 : (l_hd = (mixfix_lbrb (head l_s5) l_l)).

Axiom Ensures65 :
  ((mixfix_lbrb (head r_s5) r_l) = (find r_l (to_fmap1 (head r_s5)))).

Parameter r_hd: reference.

Axiom Ensures66 : (r_hd = (mixfix_lbrb (head r_s5) r_l)).

Parameter l_s6: state.

Axiom H92 : ((alloct l_s6) = (alloct l_s5)).

Axiom H93 : ((value l_s6) = (value l_s5)).

Axiom H94 : ((head l_s6) = (head l_s5)).

Axiom H95 : ((rep l_s6) = (rep l_s5)).

Axiom Ensures67 :
  ((to_fmap1 (nxt l_s6)) = (add l_p1 l_hd (to_fmap1 (nxt l_s5)))).

Parameter r_s6: state.

Axiom H96 : ((alloct r_s6) = (alloct r_s5)).

Axiom H97 : ((value r_s6) = (value r_s5)).

Axiom H98 : ((head r_s6) = (head r_s5)).

Axiom H99 : ((rep r_s6) = (rep r_s5)).

Axiom Ensures68 :
  ((to_fmap1 (nxt r_s6)) = (add r_p1 r_hd (to_fmap1 (nxt r_s5)))).

Parameter l_s7: state.

Axiom H100 : ((alloct l_s7) = (alloct l_s6)).

Axiom H101 : ((value l_s7) = (value l_s6)).

Axiom H102 : ((nxt l_s7) = (nxt l_s6)).

Axiom H103 : ((rep l_s7) = (rep l_s6)).

Axiom Ensures69 :
  ((to_fmap1 (head l_s7)) = (add l_l l_p1 (to_fmap1 (head l_s6)))).

Parameter r_s7: state.

Axiom H104 : ((alloct r_s7) = (alloct r_s6)).

Axiom H105 : ((value r_s7) = (value r_s6)).

Axiom H106 : ((nxt r_s7) = (nxt r_s6)).

Axiom H107 : ((rep r_s7) = (rep r_s6)).

Axiom Ensures70 :
  ((to_fmap1 (head r_s7)) = (add r_l r_p1 (to_fmap1 (head r_s6)))).

Axiom H108 : agree_head l_s7 r_s7 pi43 (singleton l_l).

Axiom H109 : agree_head r_s7 l_s7 (invert pi43) (singleton r_l).

Axiom H110 : agree_rep l_s7 r_s7 pi43 (singleton l_l).

Axiom H111 : agree_rep r_s7 l_s7 (invert pi43) (singleton r_l).

Axiom H112 : True.

Axiom H113 : True.

Axiom H114 : True.

Axiom H115 : True.

Parameter o: reference.

Axiom H116 : isAllocated l_s7 o.

Axiom H117 : hasNodeType l_s7 o.

Axiom H118 : set.Fset.mem o (mixfix_lbrb (rep l_s7) l_l).

(* Why3 goal *)
Theorem tabulate'vc :
  ((mixfix_lbrb (value l_s7) o) =
   (mixfix_lbrb (value r_s7) (mixfix_lbrb (lor pi43) o))).
Proof.

Qed.

