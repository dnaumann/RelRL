module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
    | List
    | Node
  
  type heap = {
    mutable nxt : M.t reference ;
    mutable pub : M.t bool ;
    mutable value : M.t int ;
    mutable ghost rep : M.t rgn ;
    mutable head : M.t reference
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = List) ->
           (((p \: heap.rep) /\ (p \: heap.head)) /\
              ((((heap.head[p]) = null) \/
                  (((heap.head[p]) \: alloct) /\
                     ((alloct[heap.head[p]]) = Node))) /\
                 (forall q: reference.
                    (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct)))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.pub) /\ ((p \: heap.nxt) /\ (p \: heap.value))) /\
              (((heap.nxt[p]) = null) \/
                 (((heap.nxt[p]) \: alloct) /\ ((alloct[heap.nxt[p]]) = Node))))) }
   by { heap = (any heap) ;
  alloct = (M.create ()) }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference.
      (Rgn.mem p r) ->
        ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasListType (s: state) (p: reference) =
    (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = List))
  
  predicate hasNodeType (s: state) (p: reference) =
    (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference.
            (p \: pi.lor) ->
              (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_List (s: state) : reference
    writes { s.alloct }
    writes { s.heap.rep }
    writes { s.heap.head }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result List (old s.alloct)) }
    ensures { forall p: reference.
                (p \: (old s.alloct)) ->
                  ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasListType s result }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.nxt }
    writes { s.heap.pub }
    writes { s.heap.value }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference.
                (p \: (old s.alloct)) ->
                  ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.nxt = (M.add result null (old s.heap.nxt)) }
    ensures { s.heap.pub = (M.add result false (old s.heap.pub)) }
    ensures { s.heap.value = (M.add result 0 (old s.heap.value)) }
  
  function img_value : state -> (rgn -> rgn)
  
  axiom img_value_ax = forall s: state, r: rgn. (img_value s r) = emptyRgn
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax = forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\
                              (((s.alloct[q]) = List) /\
                                 ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_pub : state -> (rgn -> rgn)
  
  axiom img_pub_ax = forall s: state, r: rgn. (img_pub s r) = emptyRgn
  
  function img_nxt : state -> (rgn -> rgn)
  
  axiom img_nxt_ax = forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_nxt s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\
                              (((s.alloct[q]) = Node) /\
                                 ((Rgn.mem q r) /\ (p = (s.heap.nxt[q])))))
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax = forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\
                               (((s.alloct[q]) = List) /\
                                  ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference.
      (p \: pre.alloct) ->
        ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = List) ->
           ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = List) ->
           ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate wrs_to_nxt_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = Node) ->
           ((not (Rgn.mem p r)) -> ((pre.heap.nxt[p]) = (post.heap.nxt[p]))))
  
  predicate wrs_to_pub_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = Node) ->
           ((not (Rgn.mem p r)) -> ((pre.heap.pub[p]) = (post.heap.pub[p]))))
  
  predicate wrs_to_value_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = Node) ->
           ((not (Rgn.mem p r)) -> ((pre.heap.value[p]) = (post.heap.value[p]))))
  
  predicate agree_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\
                    ([@expl:sl(o) ~ sr(pi(o))]
                     (sl.heap.value[o]) = (sr.heap.value[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasListType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\
                    ([@expl:sl(o) ~ sr(pi(o))]
                     PreRefperm.idRgn
                        pi
                        (sl.heap.rep[o])
                        (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_pub (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\
                    ([@expl:sl(o) ~ sr(pi(o))]
                     (sl.heap.pub[o]) = (sr.heap.pub[pi.lor[o]]))))))
  
  predicate agree_nxt (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\
                    ([@expl:sl(o) ~ sr(pi(o))]
                     PreRefperm.idRef
                        pi
                        (sl.heap.nxt[o])
                        (sr.heap.nxt[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasListType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\
                    ([@expl:sl(o) ~ sr(pi(o))]
                     PreRefperm.idRef
                        pi
                        (sl.heap.head[o])
                        (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_pub sl sr pi w) /\
      ((agree_nxt sl sr pi w) /\
         ((agree_head sl sr pi w) /\
            ((agree_rep sl sr pi w) /\ (agree_value sl sr pi w))))
end
module LISTPUB
  
  use prelude.Prelude
  use State
  use export listpub_theory.Listpub_theory
  
  predicate rep_closed (s: state) (xs: reference) =
    (hasListType s xs) ->
      ((xs <> null) ->
         (let hd1 = s.heap.head[xs] in
          let rep2 = s.heap.rep[xs] in
          (typeofRgn s rep2 (L.Cons Node L.Nil)) /\
            ((Rgn.subset (img_nxt s rep2) rep2) /\
               ((Rgn.mem null rep2) /\ (Rgn.mem hd1 rep2)))))
  
  lemma rep_closed_prop = forall s: state.
                            forall xs: reference.
                              (isAllocated s xs) ->
                                ((hasListType s xs) ->
                                   ((rep_closed s xs) ->
                                      (let rep1 = s.heap.rep[xs] in
                                       forall n: reference.
                                         (isAllocated s n) ->
                                           ((hasNodeType s n) ->
                                              ((Rgn.mem n rep1) ->
                                                 (let nxt2 = s.heap.nxt[n] in
                                                  Rgn.mem nxt2 rep1))))))
  
  predicate sim (s: state) (n: reference) (l: intList) =
    (hasNodeType s n) -> false
  
  predicate simL (s: state) (xs: reference) (ls: intList) =
    (hasListType s xs) ->
      ((xs <> null) -> (let hd1 = s.heap.head[xs] in
                        sim s hd1 ls))
  
  lemma sim_nxt = forall s: state.
                    forall n: reference, xs: intList.
                      (isAllocated s n) ->
                        ((hasNodeType s n) ->
                           ((sim s n xs) ->
                              (let nxt1 = s.heap.nxt[n] in
                               exists xs': intList. sim s nxt1 xs')))
  
  lemma sim_unique = forall s: state.
                       forall xs: intList, n: reference.
                         (isAllocated s n) ->
                           ((hasNodeType s n) ->
                              ((sim s n xs) ->
                                 (forall ys: intList. (sim s n ys) -> (xs = ys))))
  
  lemma sim_nexists = forall s: state.
                        forall n: reference.
                          (isAllocated s n) ->
                            ((hasNodeType s n) ->
                               (((s.heap.nxt[n]) = n) ->
                                  (not (exists ls: intList. sim s n ls))))
  
  val sum (s: state) (self: reference) : int
    requires { hasListType s self }
    requires { self <> null }
    requires { exists l: intList. simL s self l }
    requires { rep_closed s self }
    ensures { rep_closed s self }
    ensures { exists l: intList. (simL s self l) /\ (result = (sumList l)) }
end

module ListPub
  
  use prelude.Prelude
  use State
  use LISTPUB
  
  let sum (s: state) (self: reference) : int
    requires { hasListType s self }
    requires { self <> null }
    requires { exists l: intList. LISTPUB.simL s self l }
    requires { LISTPUB.rep_closed s self }
    ensures { LISTPUB.rep_closed s self }
    ensures { exists l: intList.
                (LISTPUB.simL s self l) /\ (result = (LISTPUB.sumList l)) } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (let ghost wit = ref (any intList) in
        (let ghost seg = ref (any intList) in
         (((assume { LISTPUB.simL s (! self) (! wit) });
           (seg := ([@expl:seg := wit] ! wit));
           (let p = ref null in
            (((assert { hasNodeType s (! p) });
              (p := ([@expl:p := self.head] s.heap.head[! self]));
              (result := ([@expl:result := 0] 0));
              (while (! p) <>. null do
                 invariant {
                   [@expl:locals type invariant]
                   (hasNodeType s (! p)) /\ (hasListType s (! self)) }
                 invariant { alloc_does_not_shrink (old s) s }
                 invariant {
                   let rep1 = s.heap.rep[! self] in
                   Rgn.mem (! p) rep1 }
                 invariant { LISTPUB.sim s (! p) (! seg) }
                 invariant {
                   let sum2 = LISTPUB.sumList (! wit) in
                   let cur = LISTPUB.sumList (! seg) in
                   (! result) = (sum2 - cur) }
                 let pub3 = ref false in
                 (((pub3 := ([@expl:pub := p.pub] s.heap.pub[! p]));
                   (if (! pub3)
                    then (let v = ref 0 in
                          (((v := ([@expl:v := p.value] s.heap.value[! p]));
                            (result
                               := ([@expl:result := result + v]
                                   (! result) + (! v)));
                            (seg := ([@expl:seg := tl(seg)] LISTPUB.tl (! seg))))))
                    else ());
                   (p := ([@expl:p := p.nxt] s.heap.nxt[! p]))))
               done);
              (! result)))))))))
end

module BiList
  
  use prelude.Prelude
  use State
  use ListPub
  use ListPub
  use export listpub_theory.Listpub_theory
  
  let sum (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (int,
     int)
    requires { hasListType l_s l_self }
    requires { l_self <> null }
    requires { hasListType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { exists l_l: intList, r_l: intList.
                 ((ListPub.LISTPUB.simL l_s l_self l_l) /\
                    (ListPub.LISTPUB.simL r_s r_self r_l)) /\
                   (l_l = r_l) }
    requires { (ListPub.LISTPUB.rep_closed l_s l_self) /\
                 (ListPub.LISTPUB.rep_closed r_s r_self) }
    requires { (exists l: intList. ListPub.LISTPUB.simL l_s l_self l) /\
                 (exists l: intList. ListPub.LISTPUB.simL r_s r_self l) }
    ensures { okRefperm l_s r_s pi }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result)
              end }
    ensures { (exists l: intList. ListPub.LISTPUB.simL l_s l_self l) /\
                (exists l: intList. ListPub.LISTPUB.simL r_s r_self l) }
    ensures { (ListPub.LISTPUB.rep_closed l_s l_self) /\
                (ListPub.LISTPUB.rep_closed r_s r_self) } =
    label INIT in
      let l_result = ref 0 in
      (let r_result = ref 0 in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let ghost l_wit = ref (any intList) in
          (let ghost r_wit = ref (any intList) in
           (let ghost l_seg = ref (any intList) in
            (let ghost r_seg = ref (any intList) in
             (((assume {
                  (ListPub.LISTPUB.simL l_s (! l_self) (! l_wit)) /\
                    (ListPub.LISTPUB.simL r_s (! r_self) (! r_wit)) });
               (((l_seg := ([@expl:seg := wit] ! l_wit));
                 (r_seg := ([@expl:seg := wit] ! r_wit))));
               (let l_p = ref null in
                (let r_p = ref null in
                 (((((l_p := ([@expl:p := self.head] l_s.heap.head[! l_self]));
                     (r_p := ([@expl:p := self.head] r_s.heap.head[! r_self]))));
                   (((l_result := ([@expl:result := 0] 0));
                     (r_result := ([@expl:result := 0] 0))));
                   (while ((! l_p) <>. null)  || ((! r_p) <>. null) do
                      invariant { okRefperm l_s r_s pi }
                      invariant {
                        (let rep4 = l_s.heap.rep[! l_self] in
                         Rgn.mem (! l_p) rep4) /\
                          (let rep5 = r_s.heap.rep[! r_self] in
                           Rgn.mem (! r_p) rep5) }
                      invariant {
                        (ListPub.LISTPUB.sim l_s (! l_p) (! l_seg)) /\
                          (ListPub.LISTPUB.sim r_s (! r_p) (! r_seg)) }
                      invariant { (! l_result) = (! r_result) }
                      invariant { (! l_seg) = (! r_seg) }
                      invariant {
                        [@expl:alignment condition]
                        (((! l_p) <> null) /\ ((l_s.heap.pub[! l_p]) = false)) \/
                          ((((! r_p) <> null) /\
                              ((r_s.heap.pub[! r_p]) = false)) \/
                             ((((! l_p) <> null) /\ ((! r_p) <> null)) \/
                                ((not ((! l_p) <> null)) /\
                                   (not ((! r_p) <> null))))) }
                      if ([@expl:Left step]
                          ((! l_p) <>. null)
                           && (eqBool (l_s.heap.pub[! l_p]) false))
                      then (let pub6 = ref false in
                            (((pub6
                                 := ([@expl:pub := p.pub] l_s.heap.pub[! l_p]));
                              (if (! pub6)
                               then (let v = ref 0 in
                                     (((v
                                          := ([@expl:v := p.value]
                                              l_s.heap.value[! l_p]));
                                       (assert {
                                          (! v)
                                             = (ListPub.LISTPUB.hd (! l_seg)) });
                                       (l_result
                                          := ([@expl:result := result + v]
                                              (! l_result) + (! v)));
                                       (l_seg
                                          := ([@expl:seg := tl(seg)]
                                              ListPub.LISTPUB.tl (! l_seg))))))
                               else ());
                              (l_p := ([@expl:p := p.nxt] l_s.heap.nxt[! l_p])))))
                      else (if ([@expl:Right step]
                                ((! r_p) <>. null)
                                 && (eqBool (r_s.heap.pub[! r_p]) false))
                            then (let pub7 = ref false in
                                  (((pub7
                                       := ([@expl:pub := p.pub]
                                           r_s.heap.pub[! r_p]));
                                    (if (! pub7)
                                     then (let v = ref 0 in
                                           (((v
                                                := ([@expl:v := p.value]
                                                    r_s.heap.value[! r_p]));
                                             (assert {
                                                (! v)
                                                   = (ListPub.LISTPUB.hd
                                                         (! r_seg)) });
                                             (r_result
                                                := ([@expl:result := result + v]
                                                    (! r_result) + (! v)));
                                             (r_seg
                                                := ([@expl:seg := tl(seg)]
                                                    ListPub.LISTPUB.tl
                                                       (! r_seg))))))
                                     else ());
                                    (r_p
                                       := ([@expl:p := p.nxt]
                                           r_s.heap.nxt[! r_p])))))
                            else (let l_pub = ref false in
                                  (let r_pub = ref false in
                                   (((((l_pub
                                          := ([@expl:pub := p.pub]
                                              l_s.heap.pub[! l_p]));
                                       (r_pub
                                          := ([@expl:pub := p.pub]
                                              r_s.heap.pub[! r_p]))));
                                     (((if (! l_pub)
                                        then (let v = ref 0 in
                                              (((v
                                                   := ([@expl:v := p.value]
                                                       l_s.heap.value[! l_p]));
                                                (assert {
                                                   (! v)
                                                      = (ListPub.LISTPUB.hd
                                                            (! l_seg)) });
                                                (l_result
                                                   := ([@expl:result := result + v]
                                                       (! l_result) + (! v)));
                                                (l_seg
                                                   := ([@expl:seg := tl(seg)]
                                                       ListPub.LISTPUB.tl
                                                          (! l_seg))))))
                                        else ());
                                       (l_p
                                          := ([@expl:p := p.nxt]
                                              l_s.heap.nxt[! l_p]))));
                                     (if (! r_pub)
                                      then (let v = ref 0 in
                                            (((v
                                                 := ([@expl:v := p.value]
                                                     r_s.heap.value[! r_p]));
                                              (assert {
                                                 (! v)
                                                    = (ListPub.LISTPUB.hd
                                                          (! r_seg)) });
                                              (r_result
                                                 := ([@expl:result := result + v]
                                                     (! r_result) + (! v)));
                                              (r_seg
                                                 := ([@expl:seg := tl(seg)]
                                                     ListPub.LISTPUB.tl
                                                        (! r_seg))))))
                                      else ());
                                     (r_p
                                        := ([@expl:p := p.nxt]
                                            r_s.heap.nxt[! r_p])))))))
                    done);
                   (! l_result, ! r_result))))))))))))))
  
  let sum2 (l_s: state) (r_s: state) (pi8: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (int,
     int)
    requires { hasListType l_s l_self }
    requires { l_self <> null }
    requires { hasListType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi8 }
    requires { exists l_l: intList, r_l: intList.
                 ((ListPub.LISTPUB.simL l_s l_self l_l) /\
                    (ListPub.LISTPUB.simL r_s r_self r_l)) /\
                   (l_l = r_l) }
    requires { (ListPub.LISTPUB.rep_closed l_s l_self) /\
                 (ListPub.LISTPUB.rep_closed r_s r_self) }
    requires { (exists l: intList. ListPub.LISTPUB.simL l_s l_self l) /\
                 (exists l: intList. ListPub.LISTPUB.simL r_s r_self l) }
    ensures { okRefperm l_s r_s pi8 }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result)
              end }
    ensures { (exists l: intList. ListPub.LISTPUB.simL l_s l_self l) /\
                (exists l: intList. ListPub.LISTPUB.simL r_s r_self l) }
    ensures { (ListPub.LISTPUB.rep_closed l_s l_self) /\
                (ListPub.LISTPUB.rep_closed r_s r_self) } =
    label INIT in
      let l_result = ref 0 in
      (let r_result = ref 0 in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let ghost l_wit = ref (any intList) in
          (let ghost r_wit = ref (any intList) in
           (let ghost l_seg = ref (any intList) in
            (let ghost r_seg = ref (any intList) in
             (((assume {
                  (ListPub.LISTPUB.simL l_s (! l_self) (! l_wit)) /\
                    (ListPub.LISTPUB.simL r_s (! r_self) (! r_wit)) });
               (((l_seg := ([@expl:seg := wit] ! l_wit));
                 (r_seg := ([@expl:seg := wit] ! r_wit))));
               (let l_p = ref null in
                (let r_p = ref null in
                 (((((l_p := ([@expl:p := self.head] l_s.heap.head[! l_self]));
                     (r_p := ([@expl:p := self.head] r_s.heap.head[! r_self]))));
                   (((l_result := ([@expl:result := 0] 0));
                     (r_result := ([@expl:result := 0] 0))));
                   (while ((! l_p) <>. null)  || ((! r_p) <>. null) do
                      invariant { okRefperm l_s r_s pi8 }
                      invariant {
                        (let rep9 = l_s.heap.rep[! l_self] in
                         Rgn.mem (! l_p) rep9) /\
                          (let rep10 = r_s.heap.rep[! r_self] in
                           Rgn.mem (! r_p) rep10) }
                      invariant {
                        (ListPub.LISTPUB.sim l_s (! l_p) (! l_seg)) /\
                          (ListPub.LISTPUB.sim r_s (! r_p) (! r_seg)) }
                      invariant { (! l_result) = (! r_result) }
                      invariant { (! l_seg) = (! r_seg) }
                      invariant {
                        [@expl:alignment condition]
                        (((! l_p) <> null) /\
                           (((l_s.heap.pub[! l_p]) = false) /\
                              (((! r_p) <> null) ->
                                 ((r_s.heap.pub[! r_p]) = true)))) \/
                          ((((! r_p) <> null) /\
                              (((r_s.heap.pub[! r_p]) = false) /\
                                 (((! l_p) <> null) ->
                                    ((l_s.heap.pub[! l_p]) = true)))) \/
                             ((((! l_p) <> null) /\ ((! r_p) <> null)) \/
                                ((not ((! l_p) <> null)) /\
                                   (not ((! r_p) <> null))))) }
                      if ([@expl:Left step]
                          ((! l_p) <>. null)
                           &&
                            ((eqBool (l_s.heap.pub[! l_p]) false)
                              &&
                               ((not ((! r_p) <>. null))
                                 || (eqBool (r_s.heap.pub[! r_p]) true))))
                      then (let pub11 = ref false in
                            (((pub11
                                 := ([@expl:pub := p.pub] l_s.heap.pub[! l_p]));
                              (if (! pub11)
                               then (let v = ref 0 in
                                     (((v
                                          := ([@expl:v := p.value]
                                              l_s.heap.value[! l_p]));
                                       (assert {
                                          (! v)
                                             = (ListPub.LISTPUB.hd (! l_seg)) });
                                       (l_result
                                          := ([@expl:result := result + v]
                                              (! l_result) + (! v)));
                                       (l_seg
                                          := ([@expl:seg := tl(seg)]
                                              ListPub.LISTPUB.tl (! l_seg))))))
                               else ());
                              (l_p := ([@expl:p := p.nxt] l_s.heap.nxt[! l_p])))))
                      else (if ([@expl:Right step]
                                ((! r_p) <>. null)
                                 &&
                                  ((eqBool (r_s.heap.pub[! r_p]) false)
                                    &&
                                     ((not ((! l_p) <>. null))
                                       || (eqBool (l_s.heap.pub[! l_p]) true))))
                            then (let pub12 = ref false in
                                  (((pub12
                                       := ([@expl:pub := p.pub]
                                           r_s.heap.pub[! r_p]));
                                    (if (! pub12)
                                     then (let v = ref 0 in
                                           (((v
                                                := ([@expl:v := p.value]
                                                    r_s.heap.value[! r_p]));
                                             (assert {
                                                (! v)
                                                   = (ListPub.LISTPUB.hd
                                                         (! r_seg)) });
                                             (r_result
                                                := ([@expl:result := result + v]
                                                    (! r_result) + (! v)));
                                             (r_seg
                                                := ([@expl:seg := tl(seg)]
                                                    ListPub.LISTPUB.tl
                                                       (! r_seg))))))
                                     else ());
                                    (r_p
                                       := ([@expl:p := p.nxt]
                                           r_s.heap.nxt[! r_p])))))
                            else (let l_pub = ref false in
                                  (let r_pub = ref false in
                                   (((((l_pub
                                          := ([@expl:pub := p.pub]
                                              l_s.heap.pub[! l_p]));
                                       (r_pub
                                          := ([@expl:pub := p.pub]
                                              r_s.heap.pub[! r_p]))));
                                     (((if (! l_pub)
                                        then (let v = ref 0 in
                                              (((v
                                                   := ([@expl:v := p.value]
                                                       l_s.heap.value[! l_p]));
                                                (assert {
                                                   (! v)
                                                      = (ListPub.LISTPUB.hd
                                                            (! l_seg)) });
                                                (l_result
                                                   := ([@expl:result := result + v]
                                                       (! l_result) + (! v)));
                                                (l_seg
                                                   := ([@expl:seg := tl(seg)]
                                                       ListPub.LISTPUB.tl
                                                          (! l_seg))))))
                                        else ());
                                       (l_p
                                          := ([@expl:p := p.nxt]
                                              l_s.heap.nxt[! l_p]))));
                                     (if (! r_pub)
                                      then (let v = ref 0 in
                                            (((v
                                                 := ([@expl:v := p.value]
                                                     r_s.heap.value[! r_p]));
                                              (assert {
                                                 (! v)
                                                    = (ListPub.LISTPUB.hd
                                                          (! r_seg)) });
                                              (r_result
                                                 := ([@expl:result := result + v]
                                                     (! r_result) + (! v)));
                                              (r_seg
                                                 := ([@expl:seg := tl(seg)]
                                                     ListPub.LISTPUB.tl
                                                        (! r_seg))))))
                                      else ());
                                     (r_p
                                        := ([@expl:p := p.nxt]
                                            r_s.heap.nxt[! r_p])))))))
                    done);
                   (! l_result, ! r_result))))))))))))))
end

