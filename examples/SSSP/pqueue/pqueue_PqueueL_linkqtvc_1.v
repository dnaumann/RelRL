(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require set.Fset.
Require set.SetApp.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) -> (r1 = r2).

Axiom infix_eqdt'spec1 :
  forall (r1:reference) (r2:reference), (r1 = r2) ->
  ((infix_eqdt r1 r2) = Init.Datatypes.true).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) -> ~ (r1 = r2).

Axiom infix_lsgtdt'spec1 :
  forall (r1:reference) (r2:reference), ~ (r1 = r2) ->
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) -> (b1 = b2).

Axiom eqBool'spec1 :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool), (b1 = b2) ->
  ((eqBool b1 b2) = Init.Datatypes.true).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) -> (u1 = u2).

Axiom eqUnit'spec1 :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit), (u1 = u2) ->
  ((eqUnit u1 u2) = Init.Datatypes.true).

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

(* Why3 assumption *)
Definition infix_eqeq {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m1:fmap k v) (m2:fmap k v) : Prop :=
  set.Fset.infix_eqeq (domain m1) (domain m2) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))).

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v), infix_eqeq m1 m2 -> (m1 = m2).

(* Why3 assumption *)
Definition mem {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} (k1:k)
    (m:fmap k v) : Prop :=
  set.Fset.mem k1 (domain m).

(* Why3 assumption *)
Definition mapsto {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} 
    (k1:k) (v1:v) (m:fmap k v) : Prop :=
  mem k1 m /\ ((contents1 m k1) = v1).

Axiom mem_mapsto :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> mapsto k1 (contents1 m k1) m.

(* Why3 assumption *)
Definition is_empty {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Prop :=
  set.Fset.is_empty (domain m).

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  is_empty (empty : fmap k v).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

(* Why3 assumption *)
Definition size {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Numbers.BinNums.Z :=
  set.Fset.cardinal (domain m).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), (0%Z <= (length self))%Z.

Axiom array'invariant1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), ((size (to_fmap (elts self))) = (length self)).

Axiom array'invariant2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a), forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length self))%Z -> mem i (to_fmap (elts self)).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom set'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (j = i) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom set'spec2 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  ((get (make n v) i) = v).

Axiom make'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Axiom set1 : Type.
Parameter set1_WhyType : WhyType set1.
Existing Instance set1_WhyType.

Parameter to_fset: set1 -> set.Fset.fset reference.

Parameter mk1: set.Fset.fset reference -> set1.

Axiom mk'spec : forall (s:set.Fset.fset reference), ((to_fset (mk1 s)) = s).

Parameter choose: set1 -> reference.

Axiom choose'spec :
  forall (s:set1), ~ set.Fset.is_empty (to_fset s) ->
  set.Fset.mem (choose s) (to_fset s).

(* Why3 assumption *)
Definition rgn := set1.

Parameter emptyRgn: set1.

Axiom emptyRgn'def :
  ((to_fset emptyRgn) = (set.Fset.empty : set.Fset.fset reference)).

Parameter singleton: reference -> set1.

Axiom singleton'spec :
  forall (x:reference),
  ((to_fset (singleton x)) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))).

Axiom singleton'spec1 :
  forall (x:reference), ((set.Fset.cardinal (to_fset (singleton x))) = 1%Z).

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Parameter infix_bscl:
  forall {a:Type} {a_WT:WhyType a}, reference -> t1 a -> Init.Datatypes.bool.

Axiom infix_bscl'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.true)) /\
  (~ mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.false)).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a), ((infix_bscl k m) = Init.Datatypes.true) ->
  mem k (to_fmap1 m).

Axiom infix_bscl'spec1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a), mem k (to_fmap1 m) ->
  ((infix_bscl k m) = Init.Datatypes.true).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  mem k (to_fmap1 m).

Axiom mem_syntax1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((infix_bscl k m) = Init.Datatypes.true).

(* Why3 assumption *)
Definition partialBijection (mTo:t1 reference) (mOf:t1 reference) : Prop :=
  ((size (to_fmap1 mTo)) = (size (to_fmap1 mOf))) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mTo x) mOf) = Init.Datatypes.true)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mOf y) mTo) = Init.Datatypes.true)) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((mixfix_lbrb mOf (mixfix_lbrb mTo x)) = x)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((mixfix_lbrb mTo (mixfix_lbrb mOf y)) = y)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant : forall (self:t2), partialBijection (lor self) (rol self).

Axiom t'invariant1 :
  forall (self:t2),
  ~ ((infix_bscl nullConst (lor self)) = Init.Datatypes.true).

Axiom t'invariant2 :
  forall (self:t2),
  ~ ((infix_bscl nullConst (rol self)) = Init.Datatypes.true).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

(* Why3 assumption *)
Definition idRef (pi:t2) (x:reference) (y:reference) : Prop :=
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) -> idRef pi x y -> idRef pi x' y ->
  (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef pi x y' -> (y = y').

(* Why3 assumption *)
Definition idRgn (pi:t2) (g:set1) (h:set1) : Prop :=
  (forall (x:reference),
   set.Fset.mem x (set.Fset.remove nullConst (to_fset g)) <->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true)) /\
  (forall (y:reference),
   set.Fset.mem y (set.Fset.remove nullConst (to_fset h)) <->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true)).

Axiom idRgn_left :
  forall (pi:t2) (g:set1) (h:set1), idRgn pi g h -> forall (x:reference),
  ~ (x = nullConst) -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) (to_fset h).

Axiom idRgn_right :
  forall (pi:t2) (g:set1) (h:set1), idRgn pi g h -> forall (y:reference),
  ~ (y = nullConst) -> ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) (to_fset g).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec1 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl y (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec2 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y).

Axiom updateRefperm0'spec3 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x).

Axiom updateRefperm0'spec4 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((infix_bscl x1 (lor (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec5 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl y1 (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec6 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom updateRefperm0'spec7 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi) y1) =
   (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1)).

Axiom updateRefperm0'spec8 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))).

Axiom updateRefperm0'spec9 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

(* Why3 assumption *)
Definition extends (pi0:t2) (pi1:t2) : Prop :=
  forall (x:reference), ((infix_bscl x (lor pi0)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi1)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x)).

Axiom extends_refl : forall (pi0:t2), extends pi0 pi0.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2), extends pi0 pi1 -> extends pi1 pi2 ->
  extends pi0 pi2.

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) -> ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  extends pi (updateRefperm0 pi x y).

Axiom extends_exists : forall (pi:t2), exists pi0:t2, extends pi0 pi.

Parameter invert: t2 -> t2.

Axiom invert'spec : forall (pi:t2), ((lor (invert pi)) = (rol pi)).

Axiom invert'spec1 : forall (pi:t2), ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> idRef (invert pi) y x.

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef (invert pi) y z -> (x = z).

(* Why3 assumption *)
Inductive reftype :=
  | Node : reftype
  | NodeArray : reftype
  | Pqueue : reftype.
Axiom reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

(* Why3 assumption *)
Inductive heap :=
  | heap'mk : t1 set1 -> t1 Numbers.BinNums.Z -> t1 reference ->
      t1 Numbers.BinNums.Z -> t1 (array reference) -> t1 reference ->
      t1 reference -> t1 reference -> t1 Numbers.BinNums.Z ->
      t1 Numbers.BinNums.Z -> heap.
Axiom heap_WhyType : WhyType heap.
Existing Instance heap_WhyType.

(* Why3 assumption *)
Definition tag (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x9
  end.

(* Why3 assumption *)
Definition key (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x8
  end.

(* Why3 assumption *)
Definition prev (v:heap) : t1 reference :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x7
  end.

(* Why3 assumption *)
Definition sibling (v:heap) : t1 reference :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x6
  end.

(* Why3 assumption *)
Definition child (v:heap) : t1 reference :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x5
  end.

(* Why3 assumption *)
Definition slots (v:heap) : t1 (array reference) :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x4
  end.

(* Why3 assumption *)
Definition length1 (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x3
  end.

(* Why3 assumption *)
Definition head (v:heap) : t1 reference :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x2
  end.

(* Why3 assumption *)
Definition size1 (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x1
  end.

(* Why3 assumption *)
Definition rep (v:heap) : t1 set1 :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 x6 x7 x8 x9 => x
  end.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter heap1: state -> heap.

Parameter alloct: state -> t1 reftype.

Parameter pool: state -> set1.

Axiom state'invariant :
  forall (self:state),
  ~ ((infix_bscl nullConst (alloct self)) = Init.Datatypes.true).

Axiom state'invariant1 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((infix_bscl p (key (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant2 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((infix_bscl p (prev (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant3 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((infix_bscl p (sibling (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant4 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((infix_bscl p (child (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant5 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((infix_bscl p (tag (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant6 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (sibling (heap1 self)) p) = nullConst) \/
  ((infix_bscl (mixfix_lbrb (sibling (heap1 self)) p) (alloct self)) =
   Init.Datatypes.true).

Axiom state'invariant7 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (sibling (heap1 self)) p) = nullConst) \/
  ((mixfix_lbrb (alloct self) (mixfix_lbrb (sibling (heap1 self)) p)) = Node).

Axiom state'invariant8 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (child (heap1 self)) p) = nullConst) \/
  ((infix_bscl (mixfix_lbrb (child (heap1 self)) p) (alloct self)) =
   Init.Datatypes.true).

Axiom state'invariant9 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (child (heap1 self)) p) = nullConst) \/
  ((mixfix_lbrb (alloct self) (mixfix_lbrb (child (heap1 self)) p)) = Node).

Axiom state'invariant10 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (prev (heap1 self)) p) = nullConst) \/
  ((infix_bscl (mixfix_lbrb (prev (heap1 self)) p) (alloct self)) =
   Init.Datatypes.true).

Axiom state'invariant11 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Node) ->
  ((mixfix_lbrb (prev (heap1 self)) p) = nullConst) \/
  ((mixfix_lbrb (alloct self) (mixfix_lbrb (prev (heap1 self)) p)) = Node).

Axiom state'invariant12 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = NodeArray) ->
  ((infix_bscl p (length1 (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant13 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = NodeArray) ->
  ((infix_bscl p (slots (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant14 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = NodeArray) ->
  (0%Z <= (mixfix_lbrb (length1 (heap1 self)) p))%Z.

Axiom state'invariant15 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = NodeArray) ->
  ((mixfix_lbrb (length1 (heap1 self)) p) =
   (length (mixfix_lbrb (slots (heap1 self)) p))).

Axiom state'invariant16 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Pqueue) ->
  ((infix_bscl p (size1 (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant17 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Pqueue) ->
  ((infix_bscl p (rep (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant18 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Pqueue) ->
  ((infix_bscl p (head (heap1 self))) = Init.Datatypes.true).

Axiom state'invariant19 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Pqueue) ->
  ((mixfix_lbrb (head (heap1 self)) p) = nullConst) \/
  ((infix_bscl (mixfix_lbrb (head (heap1 self)) p) (alloct self)) =
   Init.Datatypes.true).

Axiom state'invariant20 :
  forall (self:state), forall (p:reference),
  ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct self) p) = Pqueue) ->
  ((mixfix_lbrb (head (heap1 self)) p) = nullConst) \/
  ((mixfix_lbrb (alloct self) (mixfix_lbrb (head (heap1 self)) p)) = Node).

(* Why3 assumption *)
Definition isAllocated (s:state) (p:reference) : Prop :=
  ((infix_bscl p (alloct s)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition typeofRgn (s:state) (r:set1) (t3:reftype) : Prop :=
  forall (p:reference), set.Fset.mem p (to_fset r) ->
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = t3).

(* Why3 assumption *)
Definition hasNodeType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = Node) /\
  (((infix_bscl p (key (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (prev (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (sibling (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (child (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (tag (heap1 s))) = Init.Datatypes.true)) /\
  (((mixfix_lbrb (sibling (heap1 s)) p) = nullConst) \/
   ((infix_bscl (mixfix_lbrb (sibling (heap1 s)) p) (alloct s)) =
    Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) (mixfix_lbrb (sibling (heap1 s)) p)) = Node)) /\
  (((mixfix_lbrb (child (heap1 s)) p) = nullConst) \/
   ((infix_bscl (mixfix_lbrb (child (heap1 s)) p) (alloct s)) =
    Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) (mixfix_lbrb (child (heap1 s)) p)) = Node)) /\
  (((mixfix_lbrb (prev (heap1 s)) p) = nullConst) \/
   ((infix_bscl (mixfix_lbrb (prev (heap1 s)) p) (alloct s)) =
    Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) (mixfix_lbrb (prev (heap1 s)) p)) = Node)).

(* Why3 assumption *)
Definition hasNodeArrayType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = NodeArray) /\
  ((infix_bscl p (length1 (heap1 s))) = Init.Datatypes.true) /\
  ((infix_bscl p (slots (heap1 s))) = Init.Datatypes.true).

(* Why3 assumption *)
Definition hasPqueueType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = Pqueue) /\
  (((infix_bscl p (size1 (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (rep (heap1 s))) = Init.Datatypes.true) /\
   ((infix_bscl p (head (heap1 s))) = Init.Datatypes.true)) /\
  (((mixfix_lbrb (head (heap1 s)) p) = nullConst) \/
   ((infix_bscl (mixfix_lbrb (head (heap1 s)) p) (alloct s)) =
    Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) (mixfix_lbrb (head (heap1 s)) p)) = Node)).

(* Why3 assumption *)
Definition okRefperm (sl:state) (sr:state) (pi:t2) : Prop :=
  (forall (p:reference), ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl p (alloct sl)) = Init.Datatypes.true)) /\
  (forall (q:reference), ((infix_bscl q (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl q (alloct sr)) = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct sl) p) = (mixfix_lbrb (alloct sr) q))).

Parameter img_tag: state -> set1 -> set1.

Axiom img_tag_ax : forall (s:state) (r:set1), ((img_tag s r) = emptyRgn).

Parameter img_slots: state -> set1 -> set1.

Axiom img_slots_ax : forall (s:state) (r:set1), ((img_slots s r) = emptyRgn).

Parameter img_size: state -> set1 -> set1.

Axiom img_size_ax : forall (s:state) (r:set1), ((img_size s r) = emptyRgn).

Parameter img_sibling: state -> set1 -> set1.

Axiom img_sibling_ax :
  forall (s:state) (r:set1) (p:reference),
  set.Fset.mem p (to_fset (img_sibling s r)) ->
  exists q:reference,
  ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) q) = Node) /\
  set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (sibling (heap1 s)) q)).

Axiom img_sibling_ax1 :
  forall (s:state) (r:set1) (p:reference),
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Node) /\
   set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (sibling (heap1 s)) q))) ->
  set.Fset.mem p (to_fset (img_sibling s r)).

Parameter img_rep: state -> set1 -> set1.

Axiom img_rep_ax :
  forall (s:state) (r:set1) (p:reference),
  set.Fset.mem p (to_fset (img_rep s r)) ->
  exists q:reference,
  ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) q) = Pqueue) /\
  set.Fset.mem q (to_fset r) /\
  set.Fset.mem p (to_fset (mixfix_lbrb (rep (heap1 s)) q)).

Axiom img_rep_ax1 :
  forall (s:state) (r:set1) (p:reference),
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Pqueue) /\
   set.Fset.mem q (to_fset r) /\
   set.Fset.mem p (to_fset (mixfix_lbrb (rep (heap1 s)) q))) ->
  set.Fset.mem p (to_fset (img_rep s r)).

Parameter img_prev: state -> set1 -> set1.

Axiom img_prev_ax :
  forall (s:state) (r:set1) (p:reference),
  set.Fset.mem p (to_fset (img_prev s r)) ->
  exists q:reference,
  ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) q) = Node) /\
  set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (prev (heap1 s)) q)).

Axiom img_prev_ax1 :
  forall (s:state) (r:set1) (p:reference),
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Node) /\
   set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (prev (heap1 s)) q))) ->
  set.Fset.mem p (to_fset (img_prev s r)).

Parameter img_length: state -> set1 -> set1.

Axiom img_length_ax :
  forall (s:state) (r:set1), ((img_length s r) = emptyRgn).

Parameter img_key: state -> set1 -> set1.

Axiom img_key_ax : forall (s:state) (r:set1), ((img_key s r) = emptyRgn).

Parameter img_head: state -> set1 -> set1.

Axiom img_head_ax :
  forall (s:state) (r:set1) (p:reference),
  set.Fset.mem p (to_fset (img_head s r)) ->
  exists q:reference,
  ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) q) = Pqueue) /\
  set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (head (heap1 s)) q)).

Axiom img_head_ax1 :
  forall (s:state) (r:set1) (p:reference),
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Pqueue) /\
   set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (head (heap1 s)) q))) ->
  set.Fset.mem p (to_fset (img_head s r)).

Parameter img_child: state -> set1 -> set1.

Axiom img_child_ax :
  forall (s:state) (r:set1) (p:reference),
  set.Fset.mem p (to_fset (img_child s r)) ->
  exists q:reference,
  ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) q) = Node) /\
  set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (child (heap1 s)) q)).

Axiom img_child_ax1 :
  forall (s:state) (r:set1) (p:reference),
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Node) /\
   set.Fset.mem q (to_fset r) /\ (p = (mixfix_lbrb (child (heap1 s)) q))) ->
  set.Fset.mem p (to_fset (img_child s r)).

(* Why3 assumption *)
Definition agree_tag (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (tag (heap1 sl)) o) =
    (mixfix_lbrb (tag (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_slots (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeArrayType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (slots (heap1 sl)) o) =
    (mixfix_lbrb (slots (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_size (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasPqueueType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (size1 (heap1 sl)) o) =
    (mixfix_lbrb (size1 (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_sibling (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRef pi (mixfix_lbrb (sibling (heap1 sl)) o)
   (mixfix_lbrb (sibling (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_rep (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasPqueueType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRgn pi (mixfix_lbrb (rep (heap1 sl)) o)
   (mixfix_lbrb (rep (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_prev (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRef pi (mixfix_lbrb (prev (heap1 sl)) o)
   (mixfix_lbrb (prev (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_length (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeArrayType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (length1 (heap1 sl)) o) =
    (mixfix_lbrb (length1 (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_key (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (key (heap1 sl)) o) =
    (mixfix_lbrb (key (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_head (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasPqueueType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRef pi (mixfix_lbrb (head (heap1 sl)) o)
   (mixfix_lbrb (head (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_child (sl:state) (sr:state) (pi:t2) (w:set1) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasNodeType sl o ->
   set.Fset.mem o (to_fset w) ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRef pi (mixfix_lbrb (child (heap1 sl)) o)
   (mixfix_lbrb (child (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition pqueuePub (s:state) (pl:set1) : Prop :=
  forall (p:reference) (q:reference), isAllocated s p -> hasPqueueType s p ->
  set.Fset.mem p (to_fset pl) -> isAllocated s q -> hasPqueueType s q ->
  set.Fset.mem q (to_fset pl) -> ~ (p = q) ->
  set.Fset.subset
  (set.Fset.inter (to_fset (mixfix_lbrb (rep (heap1 s)) p))
   (to_fset (mixfix_lbrb (rep (heap1 s)) q)))
  (to_fset (singleton nullConst)).

(* Why3 assumption *)
Definition repClosed (s:state) (rep1:set1) : Prop :=
  typeofRgn s rep1 Node /\
  set.Fset.mem nullConst (to_fset rep1) /\
  set.Fset.subset (to_fset (img_sibling s rep1)) (to_fset rep1) /\
  set.Fset.subset (to_fset (img_child s rep1)) (to_fset rep1) /\
  set.Fset.subset (to_fset (img_prev s rep1)) (to_fset rep1).

Axiom repClosed_DEF :
  forall (s:state), forall (r:set1), repClosed s r -> typeofRgn s r Node.

Axiom repClosed_DEF1 :
  forall (s:state), forall (r:set1), repClosed s r ->
  set.Fset.mem nullConst (to_fset r).

Axiom repClosed_DEF2 :
  forall (s:state), forall (r:set1), repClosed s r -> forall (n:reference),
  isAllocated s n -> hasNodeType s n -> set.Fset.mem n (to_fset r) ->
  set.Fset.mem (mixfix_lbrb (sibling (heap1 s)) n) (to_fset r).

Axiom repClosed_DEF3 :
  forall (s:state), forall (r:set1), repClosed s r -> forall (n:reference),
  isAllocated s n -> hasNodeType s n -> set.Fset.mem n (to_fset r) ->
  set.Fset.mem (mixfix_lbrb (prev (heap1 s)) n) (to_fset r).

Axiom repClosed_DEF4 :
  forall (s:state), forall (r:set1), repClosed s r -> forall (n:reference),
  isAllocated s n -> hasNodeType s n -> set.Fset.mem n (to_fset r) ->
  set.Fset.mem (mixfix_lbrb (child (heap1 s)) n) (to_fset r).

Axiom repClosed_DEF5 :
  forall (s:state), forall (r:set1),
  typeofRgn s r Node /\
  set.Fset.mem nullConst (to_fset r) /\
  (forall (n:reference), isAllocated s n -> hasNodeType s n ->
   set.Fset.mem n (to_fset r) ->
   set.Fset.mem (mixfix_lbrb (sibling (heap1 s)) n) (to_fset r) /\
   set.Fset.mem (mixfix_lbrb (prev (heap1 s)) n) (to_fset r) /\
   set.Fset.mem (mixfix_lbrb (child (heap1 s)) n) (to_fset r)) ->
  repClosed s r.

(* Why3 assumption *)
Definition nodeP (s:state) (r:set1) : Prop :=
  forall (n:reference), isAllocated s n -> hasNodeType s n ->
  set.Fset.mem n (to_fset r) ->
  (0%Z <= (mixfix_lbrb (key (heap1 s)) n))%Z /\
  (0%Z <= (mixfix_lbrb (tag (heap1 s)) n))%Z.

(* Why3 assumption *)
Definition strongDisjoint (s:state) (r:set1) : Prop :=
  forall (p:reference) (q:reference), isAllocated s p -> hasPqueueType s p ->
  set.Fset.mem p (to_fset r) -> isAllocated s q -> hasPqueueType s q ->
  set.Fset.mem q (to_fset r) -> ~ (p = q) ->
  ((set.Fset.inter (to_fset (mixfix_lbrb (rep (heap1 s)) p))
    (to_fset (mixfix_lbrb (rep (heap1 s)) q)))
   = (to_fset (singleton nullConst))).

(* Why3 assumption *)
Definition pqueueI (s:state) (r:set1) : Prop :=
  forall (p:reference), isAllocated s p -> hasPqueueType s p ->
  set.Fset.mem p (to_fset r) ->
  let rep1 := mixfix_lbrb (rep (heap1 s)) p in
  let sz := mixfix_lbrb (size1 (heap1 s)) p in
  let hd := mixfix_lbrb (head (heap1 s)) p in
  repClosed s rep1 /\
  (0%Z <= sz)%Z /\
  set.Fset.mem hd (to_fset rep1) /\
  ((sz = 0%Z) <-> (hd = nullConst)) /\ nodeP s rep1 /\ strongDisjoint s r.

Parameter s: state.

Parameter s_pool: set1.

Parameter s_alloct: t1 reftype.

Parameter s_heap: heap.

Parameter self: reference.

Parameter first: reference.

Parameter second: reference.

Axiom H : (s_pool = (pool s)).

Axiom H1 : (s_alloct = (alloct s)).

Axiom H2 : (s_heap = (heap1 s)).

Axiom Requires : hasPqueueType s self.

Axiom Requires1 : ~ (self = nullConst).

Axiom Requires2 : hasNodeType s first.

Axiom Requires3 : ~ (first = nullConst).

Axiom Requires4 : hasNodeType s second.

Axiom Requires5 : ~ (second = nullConst).

Axiom Requires6 : set.Fset.mem self (to_fset (pool s)).

Axiom Requires7 :
  set.Fset.mem first (to_fset (mixfix_lbrb (rep (heap1 s)) self)).

Axiom Requires8 :
  set.Fset.mem second (to_fset (mixfix_lbrb (rep (heap1 s)) self)).

Axiom Requires9 : pqueuePub s (pool s).

Axiom Requires10 : pqueueI s (pool s).

Axiom Ensures :
  ((mixfix_lbrb (key (heap1 s)) first) =
   (find first (to_fmap1 (key (heap1 s))))).

Parameter fkey: Numbers.BinNums.Z.

Axiom Ensures1 : (fkey = (mixfix_lbrb (key (heap1 s)) first)).

Axiom Ensures2 :
  ((mixfix_lbrb (key (heap1 s)) second) =
   (find second (to_fmap1 (key (heap1 s))))).

Parameter skey: Numbers.BinNums.Z.

Axiom Ensures3 : (skey = (mixfix_lbrb (key (heap1 s)) second)).

Axiom Assert : repClosed s (mixfix_lbrb (rep (heap1 s)) self).

Axiom H3 : (skey < fkey)%Z.

Axiom Ensures4 :
  ((mixfix_lbrb (prev (heap1 s)) first) =
   (find first (to_fmap1 (prev (heap1 s))))).

Parameter tmp: reference.

Axiom Ensures5 : (tmp = (mixfix_lbrb (prev (heap1 s)) first)).

Axiom Assert1 :
  set.Fset.mem tmp (to_fset (mixfix_lbrb (rep (heap1 s)) self)).

Parameter s1: state.

Parameter s_heap1: heap.

Axiom Ensures6 :
  ((to_fmap1 (prev s_heap1)) = (add second tmp (to_fmap1 (prev (heap1 s))))).

Axiom H4 : ((rep s_heap1) = (rep (heap1 s))).

Axiom H5 : ((size1 s_heap1) = (size1 (heap1 s))).

Axiom H6 : ((head s_heap1) = (head (heap1 s))).

Axiom H7 : ((length1 s_heap1) = (length1 (heap1 s))).

Axiom H8 : ((slots s_heap1) = (slots (heap1 s))).

Axiom H9 : ((child s_heap1) = (child (heap1 s))).

Axiom H10 : ((sibling s_heap1) = (sibling (heap1 s))).

Axiom H11 : ((key s_heap1) = (key (heap1 s))).

Axiom H12 : ((tag s_heap1) = (tag (heap1 s))).

Axiom Assert2 :
  set.Fset.mem (mixfix_lbrb (prev s_heap1) second)
  (to_fset (mixfix_lbrb (rep s_heap1) self)).

Axiom H13 : ((pool s) = (pool s1)).

Axiom H14 : ((alloct s) = (alloct s1)).

Axiom H15 : (s_heap1 = (heap1 s1)).

(* Why3 goal *)
Theorem link'vc :
  set.Fset.subset (to_fset (img_prev s1 (mixfix_lbrb (rep (heap1 s1)) self)))
  (to_fset (mixfix_lbrb (rep (heap1 s1)) self)).
Proof.
  unfold Fset.subset.
  intros x H.
  pose proof img_prev_ax as HAX.
  specialize (HAX s1 (mixfix_lbrb (rep (heap1 s1)) self) x).
  apply HAX in H.
  destruct H as (y & (H1 & H2 & H3 & H4)).
  clear HAX.
  subst.
  rewrite mixfix_lbrb'def.
  simpl.

Qed.

