module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
    | DistArray
    | Node
    | NodeArray
    | Pqueue
  
  type heap = {
    mutable sntl : M.t reference ;
    mutable ghost rep : M.t rgn ;
    mutable size : M.t int ;
    mutable head : M.t reference ;
    mutable slots : M.t (A.array reference) ;
    mutable length : M.t int ;
    mutable child : M.t reference ;
    mutable sibling : M.t reference ;
    mutable prev : M.t reference ;
    mutable key : M.t int ;
    mutable tag : M.t int ;
    mutable dLength : M.t int ;
    mutable dSlots : M.t (A.array int)
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = DistArray) ->
           (((p \: heap.dLength) /\ (p \: heap.dSlots)) /\
              (((heap.dLength[p]) >= 0) /\ ((heap.dLength[p]) = (A.length (heap.dSlots[p])))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.key) /\ ((p \: heap.prev) /\ ((p \: heap.sibling) /\ ((p \: heap.child) /\ (p \: heap.tag))))) /\
              ((((heap.sibling[p]) = null) \/ (((heap.sibling[p]) \: alloct) /\ ((alloct[heap.sibling[p]]) = Node))) /\
                 ((((heap.child[p]) = null) \/ (((heap.child[p]) \: alloct) /\ ((alloct[heap.child[p]]) = Node))) /\
                    (((heap.prev[p]) = null) \/ (((heap.prev[p]) \: alloct) /\ ((alloct[heap.prev[p]]) = Node))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = NodeArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\
              (((heap.length[p]) = (A.length (heap.slots[p]))) /\
                 (((heap.length[p]) >= 0) /\
                    (let arr = heap.slots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr)) -> (let v = A.get arr i in
                                                   (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Node))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Pqueue) ->
           (((p \: heap.size) /\ ((p \: heap.rep) /\ ((p \: heap.sntl) /\ (p \: heap.head)))) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 ((((heap.sntl[p]) = null) \/ (((heap.sntl[p]) \: alloct) /\ ((alloct[heap.sntl[p]]) = Node))) /\
                    (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct))))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasDistArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = DistArray))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasNodeArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = NodeArray))
  
  predicate hasPqueueType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Pqueue))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_DistArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result DistArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { s.heap.dLength = (M.add result 0 (old s.heap.dLength)) }
    ensures { s.heap.dSlots = (M.add result (A.make 0 0) (old s.heap.dSlots)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.child = (M.add result null (old s.heap.child)) }
    ensures { s.heap.sibling = (M.add result null (old s.heap.sibling)) }
    ensures { s.heap.prev = (M.add result null (old s.heap.prev)) }
    ensures { s.heap.key = (M.add result 0 (old s.heap.key)) }
    ensures { s.heap.tag = (M.add result 0 (old s.heap.tag)) }
  
  val mk_NodeArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result NodeArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 null) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_Pqueue (s: state) : reference
    writes { s.alloct }
    writes { s.heap.sntl }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.head }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Pqueue (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasPqueueType s result }
    ensures { s.heap.sntl = (M.add result null (old s.heap.sntl)) }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.size = (M.add result 0 (old s.heap.size)) }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
  
  function img_tag : state -> (rgn -> rgn)
  
  axiom img_tag_ax : forall s: state, r: rgn. (img_tag s r) = emptyRgn
  
  function img_sntl : state -> (rgn -> rgn)
  
  axiom img_sntl_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_sntl s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.sntl[q])))))
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn. (img_slots s r) = emptyRgn
  
  function img_size : state -> (rgn -> rgn)
  
  axiom img_size_ax : forall s: state, r: rgn. (img_size s r) = emptyRgn
  
  function img_sibling : state -> (rgn -> rgn)
  
  axiom img_sibling_ax : forall s: state, r: rgn, p: reference.
                           (Rgn.mem p (img_sibling s r)) <->
                             (exists q: reference.
                                (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.sibling[q])))))
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_prev : state -> (rgn -> rgn)
  
  axiom img_prev_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_prev s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.prev[q])))))
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_key : state -> (rgn -> rgn)
  
  axiom img_key_ax : forall s: state, r: rgn. (img_key s r) = emptyRgn
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  function img_dSlots : state -> (rgn -> rgn)
  
  axiom img_dSlots_ax : forall s: state, r: rgn. (img_dSlots s r) = emptyRgn
  
  function img_dLength : state -> (rgn -> rgn)
  
  axiom img_dLength_ax : forall s: state, r: rgn. (img_dLength s r) = emptyRgn
  
  function img_child : state -> (rgn -> rgn)
  
  axiom img_child_ax : forall s: state, r: rgn, p: reference.
                         (Rgn.mem p (img_child s r)) <->
                           (exists q: reference.
                              (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.child[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. (p \: pre.alloct) -> ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_dLength_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = DistArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.dLength[p]) = (post.heap.dLength[p]))))
  
  predicate wrs_to_dSlots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = DistArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.dSlots[p]) = (post.heap.dSlots[p]))))
  
  predicate wrs_to_child_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.child[p]) = (post.heap.child[p]))))
  
  predicate wrs_to_sibling_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.sibling[p]) = (post.heap.sibling[p]))))
  
  predicate wrs_to_prev_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.prev[p]) = (post.heap.prev[p]))))
  
  predicate wrs_to_key_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.key[p]) = (post.heap.key[p]))))
  
  predicate wrs_to_tag_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.tag[p]) = (post.heap.tag[p]))))
  
  predicate wrs_to_slots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = NodeArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.slots[p]) = (post.heap.slots[p]))))
  
  predicate wrs_to_length_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = NodeArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.length[p]) = (post.heap.length[p]))))
  
  predicate wrs_to_sntl_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.sntl[p]) = (post.heap.sntl[p]))))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_size_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.size[p]) = (post.heap.size[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate agree_tag (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.tag[o]) = (sr.heap.tag[pi.lor[o]]))))))
  
  predicate agree_sntl (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sntl[o]) (sr.heap.sntl[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_size (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.size[o]) = (sr.heap.size[pi.lor[o]]))))))
  
  predicate agree_sibling (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sibling[o]) (sr.heap.sibling[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_prev (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.prev[o]) (sr.heap.prev[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_key (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.key[o]) = (sr.heap.key[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_dSlots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dSlots[o]) = (sr.heap.dSlots[pi.lor[o]]))))))
  
  predicate agree_dLength (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dLength[o]) = (sr.heap.dLength[pi.lor[o]]))))))
  
  predicate agree_child (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.child[o]) (sr.heap.child[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_size sl sr pi w) /\
      ((agree_rep sl sr pi w) /\
         ((agree_sntl sl sr pi w) /\
            ((agree_length sl sr pi w) /\
               ((agree_slots sl sr pi w) /\
                  ((agree_tag sl sr pi w) /\
                     ((agree_key sl sr pi w) /\
                        ((agree_prev sl sr pi w) /\
                           ((agree_sibling sl sr pi w) /\
                              ((agree_child sl sr pi w) /\
                                 ((agree_dSlots sl sr pi w) /\ ((agree_dLength sl sr pi w) /\ (agree_head sl sr pi w))))))))))))
end
module PQUEUE
  
  use prelude.Prelude
  use State
  
  predicate pqueuePub (s: state) =
    (typeofRgn s s.pool (L.Cons Node (L.Cons Pqueue L.Nil))) /\
      ((typeofRgn s (img_rep s s.pool) (L.Cons Node L.Nil)) /\
         (forall p: reference, q: reference.
            (isAllocated s p) ->
              ((hasPqueueType s p) ->
                 ((Rgn.mem p s.pool) ->
                    ((isAllocated s q) ->
                       ((hasPqueueType s q) ->
                          ((Rgn.mem q s.pool) -> (let prep = s.heap.rep[p] in
                                                  let qrep = s.heap.rep[q] in
                                                  (p <> q) -> (prep \# qrep)))))))))
  
  val init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    writes { s.heap.tag }
    writes { s.heap.key }
    writes { s.alloct }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`tag] wrs_to_tag_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`key] wrs_to_key_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
  
  val getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.tag[self]) = result }
  
  val getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = result }
  
  val init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { pqueuePub s }
    requires { not (Rgn.mem self s.pool) }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { Rgn.mem self s.pool }
    ensures { pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
  
  val isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { pqueuePub s }
  
  val findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { pqueuePub s }
    ensures { let hd = s.heap.head[self] in
              result = hd }
  
  val insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr {self}`rep`tag] wrs_to_tag_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`key] wrs_to_key_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
  
  val deleteMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { pqueuePub s }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
  
  val decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    ensures { result = () }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r1 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r1 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { pqueuePub s }
    ensures { (s.heap.key[handle]) = k }
end

module PqueueL
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repClosed (s: state) (rep1: rgn) =
    (typeofRgn s rep1 (L.Cons Node L.Nil)) /\
      ((Rgn.mem null rep1) /\
         ((Rgn.subset (img_sibling s rep1) rep1) /\ ((Rgn.subset (img_child s rep1) rep1) /\ (Rgn.subset (img_prev s rep1) rep1))))
  
  lemma repClosed_DEF : forall s: state.
                          forall r: rgn.
                            (repClosed s r) <->
                              ((typeofRgn s r (L.Cons Node L.Nil)) /\
                                 ((Rgn.mem null r) /\
                                    (forall n: reference.
                                       (isAllocated s n) ->
                                         ((hasNodeType s n) ->
                                            ((Rgn.mem n r) ->
                                               (let sib = s.heap.sibling[n] in
                                                let pre = s.heap.prev[n] in
                                                let chl = s.heap.child[n] in
                                                (Rgn.mem sib r) /\ ((Rgn.mem pre r) /\ (Rgn.mem chl r))))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = (singleton null))))))))
  
  predicate pqueueI (s: state) =
    forall p: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p s.pool) ->
              (let rep1 = s.heap.rep[p] in
               let sz = s.heap.size[p] in
               let hd = s.heap.head[p] in
               (repClosed s rep1) /\ ((sz >= 0) /\ ((Rgn.mem hd rep1) /\ (((sz = 0) <-> (hd = null)) /\ (nodeP s rep1)))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p s.pool) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q s.pool) ->
                                               ((PQUEUE.pqueuePub s) ->
                                                  ((p <> q) ->
                                                     (let prep = s.heap.rep[p] in
                                                      let qrep = s.heap.rep[q] in
                                                      forall n: reference.
                                                        (isAllocated s n) ->
                                                          ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    requires { (s.heap.sibling[self]) = null }
    requires { (s.heap.prev[self]) = null }
    requires { (s.heap.child[self]) = null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`tag] wrs_to_tag_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`key] wrs_to_key_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
    ensures { (s.heap.sibling[self]) = null }
    ensures { (s.heap.prev[self]) = null }
    ensures { (s.heap.child[self]) = null } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
           (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
           (! result))))))
  
  let getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.tag[self]) = result } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((result := ([@expl:result := self.tag] s.heap.tag[! self]));
         (! result))))
  
  let getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = result } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((result := ([@expl:result := self.key] s.heap.key[! self]));
         (! result))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { PQUEUE.pqueuePub s }
    requires { not (Rgn.mem self s.pool) }
    requires { pqueueI s }
    writes { s.pool }
    writes { s.heap.rep }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { Rgn.mem self s.pool }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (((s.heap.rep <- ([@expl:self.rep := {null}] M.add (! self) (singleton null) s.heap.rep));
         (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
         (! result))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert { not ((s.heap.head[! self]) = null) });
         (result := ([@expl:result := self.head] s.heap.head[! self]));
         (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let first = ref first in
        (let second = ref second in
         (let fkey = ref 0 in
          (let skey = ref 0 in
           (let tmp = ref null in
            (((assert { hasNodeType s (! tmp) });
              (let ghost rep3 = ref emptyRgn in
               (((assert { isValidRgn s (! rep3) });
                 (rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                 (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
                 (skey := ([@expl:skey := second.key] s.heap.key[! second]));
                 (if ((! skey) < (! fkey))
                  then (((tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                         (assert { Rgn.mem (! tmp) (! rep3) });
                         (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                         (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                         (assert { let p = s.heap.prev[! first] in
                                   Rgn.mem p (! rep3) });
                         (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                         (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                 (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (assert { let p = s.heap.prev[! tmp] in
                                           Rgn.mem p (! rep3) });
                                 (assert { repClosed s (! rep3) })))
                          else ());
                         (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                         (result := ([@expl:result := second] ! second));
                         (assert { repClosed s (! rep3) })))
                  else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                         (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                         (assert { Rgn.mem (! tmp) (! rep3) });
                         (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                          else ());
                         (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                         (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                          else ());
                         (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                         (result := ([@expl:result := first] ! first));
                         (assert { repClosed s (! rep3) }))));
                 (! result))))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  lemma img_rep_lem : forall s: state.
                        forall self1: reference.
                          (isAllocated s self1) -> ((hasPqueueType s self1) -> ((s.heap.rep[self1]) = (s.heap.rep[self1])))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {})`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {})`child] wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((assert { PQUEUE.pqueuePub s });
           (result := ([@expl:result := new Node] mk_Node s));
           (assert { pqueueI s });
           (assert { (! result) <> null });
           ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
           (assert { PQUEUE.pqueuePub s });
           (assert {
              forall p: reference.
                (isAllocated s p) ->
                  ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep3 = s.heap.rep[p] in
                                                                  not (Rgn.mem (! result) rep3)))) });
           (assert { pqueueI s });
           (let ghost rep4 = ref emptyRgn in
            (((assert { isValidRgn s (! rep4) });
              (rep4 := ([@expl:rep := self.rep] s.heap.rep[! self]));
              (s.heap.rep <-
                 ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep4) (singleton (! result))) s.heap.rep));
              (assert {
                 forall p: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let prep = s.heap.rep[p] in
                                                                    not (Rgn.mem (! result) prep))))) });
              (assert {
                 forall p: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) ->
                           ((p <> (! self)) -> (let prep = s.heap.rep[p] in
                                                let srep = s.heap.rep[! self] in
                                                srep \# prep)))) });
              (assert {
                 forall p: reference, q: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) ->
                           ((isAllocated s q) ->
                              ((hasPqueueType s q) ->
                                 ((Rgn.mem q s.pool) ->
                                    ((p <> q) ->
                                       ((p <> (! self)) ->
                                          ((q <> (! self)) -> (let prep = s.heap.rep[p] in
                                                               let qrep = s.heap.rep[q] in
                                                               prep \# qrep))))))))) });
              (assert { PQUEUE.pqueuePub s });
              (assert { let rep5 = s.heap.rep[! self] in
                        repClosed s rep5 });
              (assert { pqueueI s });
              (let hd = ref null in
               (((assert { hasNodeType s (! hd) });
                 (hd := ([@expl:hd := self.head] s.heap.head[! self]));
                 (if ((! hd) =. null)
                  then (((assert { let rep6 = s.heap.rep[! self] in
                                   repClosed s rep6 });
                         (s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                         (assert { (s.heap.head[! self]) = (! result) });
                         (assert { let hd7 = s.heap.head[! self] in
                                   let rep8 = s.heap.rep[! self] in
                                   Rgn.mem hd7 rep8 });
                         (assert {
                            let hd9 = s.heap.head[! self] in
                            ((s.heap.sibling[hd9]) = null) /\ (((s.heap.prev[hd9]) = null) /\ ((s.heap.child[hd9]) = null)) })))
                  else (let tmp = ref null in
                        (((assert { hasNodeType s (! tmp) });
                          (tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                          (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                          (assert { let hd10 = s.heap.head[! self] in
                                    let rep11 = s.heap.rep[! self] in
                                    Rgn.mem hd10 rep11 })))));
                 (let sz = ref 0 in
                  (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
                    (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                    (! result)))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { not ((s.heap.sibling[handle]) = null) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let trees = ref null in
         (((assert { hasNodeArrayType s (! trees) });
           (let index = ref 0 in
            (let current = ref null in
             (((assert { hasNodeType s (! current) });
               (let tmp = ref null in
                (((assert { hasNodeType s (! tmp) });
                  (let fst = ref null in
                   (((assert { hasNodeType s (! fst) });
                     (let snd = ref null in
                      (((assert { hasNodeType s (! snd) });
                        (let i = ref 0 in
                         (let j = ref 0 in
                          (((((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                              (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                              (s.heap.slots <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                            (s.heap.slots <-
                               ([@expl:trees.{0} := handle] M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                            (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                            (assert {
                               forall p: reference.
                                 (isAllocated s p) ->
                                   ((hasNodeArrayType s p) ->
                                      ((p <> (! trees)) -> (let s3 = old (s.heap.slots[p]) in
                                                            (s.heap.slots[p]) = s3))) });
                            (index := ([@expl:index := 1] 1));
                            (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                            (while (! current) <>. null do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! tmp)) /\
                                   ((hasNodeType s (! snd)) /\
                                      ((hasPqueueType s (! self)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasNodeType s (! handle)) /\
                                               ((hasNodeType s (! fst)) /\
                                                  ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant { 1 <= (! index) }
                               invariant { let l = s.heap.length[! trees] in
                                           (! index) < l }
                               invariant {
                                 forall k4: int. (0 <= k4) -> ((k4 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k4) = null))) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k5: int. ((! index) <= k5) -> ((k5 < l) -> ((A.get (s.heap.slots[! trees]) k5) = null)) }
                               invariant {
                                 forall k6: int.
                                   (0 <= k6) ->
                                     ((k6 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k6 in
                                         let rep7 = s.heap.rep[! self] in
                                         Rgn.mem n rep7)) }
                               invariant { let rep8 = s.heap.rep[! self] in
                                           Rgn.mem (! current) rep8 }
                               invariant { let rep9 = s.heap.rep[! self] in
                                           repClosed s rep9 }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeType s p) ->
                                        ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                           (let sib = old (s.heap.sibling[p]) in
                                            let prev10 = old (s.heap.prev[p]) in
                                            let child11 = old (s.heap.child[p]) in
                                            ((s.heap.sibling[p]) = sib) /\
                                              (((s.heap.prev[p]) = prev10) /\ ((s.heap.child[p]) = child11))))) }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeArrayType s p) ->
                                        ((p <> (! trees)) ->
                                           (let slots12 = old (s.heap.slots[p]) in
                                            let length13 = old (s.heap.length[p]) in
                                            ((s.heap.slots[p]) = slots12) /\ ((s.heap.length[p]) = length13)))) }
                               invariant { PQUEUE.pqueuePub s }
                               invariant { pqueueI s }
                               ((assume { let l = s.heap.length[! trees] in
                                          (! index) < (l - 1) });
                                (s.heap.slots <-
                                   ([@expl:trees.{index} := current]
                                    M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                                (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                                (if ((! tmp) <>. null)
                                 then (s.heap.sibling <- ([@expl:tmp.sibling := null] M.add (! tmp) null s.heap.sibling)) 
                                 else ());
                                (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                                (index := ([@expl:index := index + 1] (! index) + 1)))
                             done);
                            (s.heap.slots <-
                               ([@expl:trees.{index} := null]
                                M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) null) s.heap.slots));
                            (assert { let l = s.heap.length[! trees] in
                                      (! index) < l });
                            (i := ([@expl:i := 0] 0));
                            (tmp := ([@expl:tmp := null] null));
                            (while ((! i) + 1) < (! index) do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! tmp)) /\
                                   ((hasNodeType s (! snd)) /\
                                      ((hasPqueueType s (! self)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasNodeType s (! handle)) /\
                                               ((hasNodeType s (! fst)) /\
                                                  ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant {
                                 forall k14: int.
                                   (0 <= k14) -> ((k14 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k14) = null))) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k15: int. ((! index) <= k15) -> ((k15 < l) -> ((A.get (s.heap.slots[! trees]) k15) = null)) }
                               invariant {
                                 forall k16: int.
                                   (0 <= k16) ->
                                     ((k16 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k16 in
                                         let rep17 = s.heap.rep[! self] in
                                         Rgn.mem n rep17)) }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeType s p) ->
                                        ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                           (let sib = old (s.heap.sibling[p]) in
                                            let prev18 = old (s.heap.prev[p]) in
                                            let child19 = old (s.heap.child[p]) in
                                            ((s.heap.sibling[p]) = sib) /\
                                              (((s.heap.prev[p]) = prev18) /\ ((s.heap.child[p]) = child19))))) }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeArrayType s p) ->
                                        ((p <> (! trees)) ->
                                           (let slots20 = old (s.heap.slots[p]) in
                                            let length21 = old (s.heap.length[p]) in
                                            ((s.heap.slots[p]) = slots20) /\ ((s.heap.length[p]) = length21)))) }
                               invariant { PQUEUE.pqueuePub s }
                               invariant { pqueueI s }
                               invariant { 0 <= (! i) }
                               invariant { (! i) <= (! index) }
                               invariant { let rep22 = s.heap.rep[! self] in
                                           Rgn.mem (! tmp) rep22 }
                               ((fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                                (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                                (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                (s.heap.slots <-
                                   ([@expl:trees.{i} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                                (i := ([@expl:i := i + 2] (! i) + 2)))
                             done);
                            (j := ([@expl:j := i - 2] (! i) - 2));
                            (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                             then (((assert { ((! j) + 2) < (! index) });
                                    (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                    (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                                    (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                    (s.heap.slots <-
                                       ([@expl:trees.{j} := tmp]
                                        M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                             else ());
                            (while 2 <= (! j) do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! tmp)) /\
                                   ((hasNodeType s (! snd)) /\
                                      ((hasPqueueType s (! self)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasNodeType s (! handle)) /\
                                               ((hasNodeType s (! fst)) /\
                                                  ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant {
                                 forall k23: int.
                                   (0 <= k23) -> ((k23 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k23) = null))) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k24: int. ((! index) <= k24) -> ((k24 < l) -> ((A.get (s.heap.slots[! trees]) k24) = null)) }
                               invariant {
                                 forall k25: int.
                                   (0 <= k25) ->
                                     ((k25 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k25 in
                                         let rep26 = s.heap.rep[! self] in
                                         Rgn.mem n rep26)) }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeType s p) ->
                                        ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                           (let sib = old (s.heap.sibling[p]) in
                                            let prev27 = old (s.heap.prev[p]) in
                                            let child28 = old (s.heap.child[p]) in
                                            ((s.heap.sibling[p]) = sib) /\
                                              (((s.heap.prev[p]) = prev27) /\ ((s.heap.child[p]) = child28))))) }
                               invariant {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasNodeArrayType s p) ->
                                        ((p <> (! trees)) ->
                                           (let slots29 = old (s.heap.slots[p]) in
                                            let length30 = old (s.heap.length[p]) in
                                            ((s.heap.slots[p]) = slots29) /\ ((s.heap.length[p]) = length30)))) }
                               invariant { (0 - 2) <= (! j) }
                               invariant { (! j) < (! index) }
                               invariant { PQUEUE.pqueuePub s }
                               invariant { pqueueI s }
                               ((fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                                (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                (s.heap.slots <-
                                   ([@expl:trees.{j - 2} := tmp]
                                    M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                                (j := ([@expl:j := j - 2] (! j) - 2)))
                             done);
                            (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                            (! result)))))))))))))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { pqueueI s }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let tmp = ref null in
         (((assert { hasNodeType s (! tmp) });
           (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
           (if ((! tmp) =. null) then (result := ([@expl:result := handle] ! handle))
            else (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))));
           (! result))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self} union {})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (Rgn.union (s.heap.rep[self]) (singleton self)) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self} union {})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (Rgn.union (s.heap.rep[self]) (singleton self)) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { PQUEUE.pqueuePub s }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((result := ([@expl:result := findMin(self)] findMin s (! self)));
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
            (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
            (if ((! tmp) =. null)
             then (((assume { (s.heap.size[! self]) = 1 });
                    (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head))))
             else (((assume { let sz = s.heap.size[! self] in
                              sz > 1 });
                    (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                    (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
            (let sz = ref 0 in
             (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
               (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
               (! result))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r27 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r27 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { (s.heap.key[handle]) = k }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let handle = ref handle in
        (let k = ref k in
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let pos = ref null in
             (((assert { hasNodeType s (! pos) });
               (assert { let key3 = s.heap.key[! handle] in
                         key3 >= 0 });
               (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
               (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
               (if ((! handle) <>. (! tmp))
                then (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                       (if ((! tmp) <>. null)
                        then (((pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                               (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev))))
                        else ());
                       (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                       (assert { let rep4 = s.heap.rep[! self] in
                                 Rgn.mem (! tmp) rep4 });
                       (if ((! tmp) <>. null)
                        then (((pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                               (if ((! pos) =. (! handle))
                                then (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                       (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                                else (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                       (assert { let rep5 = s.heap.rep[! self] in
                                                 (Rgn.mem (! pos) rep5) /\ (Rgn.mem (! tmp) rep5) });
                                       (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                       (assert { let rep6 = s.heap.rep[! self] in
                                                 let sib = s.heap.sibling[! tmp] in
                                                 Rgn.mem sib rep6 }))));
                               (assert {
                                  forall p: reference.
                                    (isAllocated s p) ->
                                      ((hasNodeType s p) ->
                                         (let rep7 = s.heap.rep[! self] in
                                          (not (Rgn.mem p rep7)) -> (let sib = old (s.heap.sibling[p]) in
                                                                    (s.heap.sibling[p]) = sib))) })))
                        else ());
                       (s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! handle) null s.heap.sibling));
                       (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                       (assert { (! pos) <> null });
                       (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                       (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
                else ());
               (! result))))))))))
  
  lemma boundary_frames_invariant_PqueueL : forall s: state, t8: state, pi: 
                                              PreRefperm.t.
                                              (okRefperm s t8 pi) ->
                                                ((PreRefperm.identity pi s.alloct.M.domain t8.alloct.M.domain) ->
                                                   ((PreRefperm.idRgn pi s.pool t8.pool) ->
                                                      ((agree_allfields s t8 pi (Rgn.union (img_rep s s.pool) s.pool)) ->
                                                         ((pqueueI s) -> (pqueueI t8)))))
end

module PqueueR
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repOk (s: state) (pq: reference) =
    (hasPqueueType s pq) ->
      ((pq <> null) ->
         (let sntl1 = s.heap.sntl[pq] in
          let rep2 = s.heap.rep[pq] in
          (typeofRgn s rep2 (L.Cons Node L.Nil)) /\
            ((not (Rgn.mem sntl1 rep2)) /\
               ((not (Rgn.mem null rep2)) /\
                  (forall n: reference.
                     (isAllocated s n) ->
                       ((hasNodeType s n) ->
                          ((Rgn.mem n rep2) ->
                             (let chl = s.heap.child[n] in
                              let sib = s.heap.sibling[n] in
                              let pre = s.heap.prev[n] in
                              ((Rgn.mem chl rep2) \/ (chl = sntl1)) /\
                                (((Rgn.mem sib rep2) \/ (sib = sntl1)) /\ ((Rgn.mem pre rep2) \/ (pre = sntl1)))))))))))
  
  lemma repOk_EMPTY : forall s: state.
                        forall p: reference.
                          (isAllocated s p) -> ((hasPqueueType s p) -> (((s.heap.rep[p]) = emptyRgn) -> (repOk s p)))
  
  predicate sntlOk (s: state) (sntl1: reference) =
    (hasNodeType s sntl1) ->
      ((sntl1 <> null) ->
         (((s.heap.tag[sntl1]) = (0 - 1)) /\
            (((s.heap.key[sntl1]) = (0 - 1)) /\
               (((s.heap.sibling[sntl1]) = sntl1) /\ (((s.heap.child[sntl1]) = sntl1) /\ ((s.heap.prev[sntl1]) = sntl1))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = emptyRgn)))))))
  
  predicate pqueueI (s: state) =
    forall pq: reference.
      (isAllocated s pq) ->
        ((hasPqueueType s pq) ->
           ((Rgn.mem pq s.pool) ->
              (let rep1 = s.heap.rep[pq] in
               let sz = s.heap.size[pq] in
               let sntl2 = s.heap.sntl[pq] in
               let head3 = s.heap.head[pq] in
               (sntl2 <> null) /\
                 ((Rgn.mem sntl2 s.pool) /\
                    ((sntlOk s sntl2) /\
                       ((repOk s pq) /\
                          ((head3 <> null) /\
                             (((head3 <> sntl2) -> (Rgn.mem head3 rep1)) /\
                                ((sz >= 0) /\
                                   (((sz = 0) <-> (head3 = sntl2)) /\
                                      ((nodeP s rep1) /\
                                         (forall pq2: reference.
                                            (isAllocated s pq2) ->
                                              ((hasPqueueType s pq2) ->
                                                 ((Rgn.mem pq2 s.pool) -> ((pq <> pq2) -> (not ((s.heap.sntl[pq2]) = sntl2)))))))))))))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p s.pool) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q s.pool) ->
                                               ((PQUEUE.pqueuePub s) ->
                                                  ((p <> q) ->
                                                     (let prep = s.heap.rep[p] in
                                                      let qrep = s.heap.rep[q] in
                                                      forall n: reference.
                                                        (isAllocated s n) ->
                                                          ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    requires { (s.heap.sibling[self]) = null }
    requires { (s.heap.prev[self]) = null }
    requires { (s.heap.child[self]) = null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`tag] wrs_to_tag_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`key] wrs_to_key_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
    ensures { (s.heap.sibling[self]) = null }
    ensures { (s.heap.prev[self]) = null }
    ensures { (s.heap.child[self]) = null } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
           (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
           (! result))))))
  
  let getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.tag[self]) = result } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((result := ([@expl:result := self.tag] s.heap.tag[! self]));
         (! result))))
  
  let getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { (s.heap.key[self]) = result } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((result := ([@expl:result := self.key] s.heap.key[! self]));
         (! result))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { PQUEUE.pqueuePub s }
    requires { not (Rgn.mem self s.pool) }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.sntl }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (Rgn.union (singleton self) (s.heap.rep[self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`prev]
              wrs_to_prev_framed_by (old s) s (Rgn.union (Rgn.union (singleton self) (s.heap.rep[self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (Rgn.union (singleton self) (s.heap.rep[self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`tag]
              wrs_to_tag_framed_by (old s) s (Rgn.union (Rgn.union (singleton self) (s.heap.rep[self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`key]
              wrs_to_key_framed_by (old s) s (Rgn.union (Rgn.union (singleton self) (s.heap.rep[self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { Rgn.mem self s.pool }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let sntl2 = ref null in
        (((assert { hasNodeType s (! sntl2) });
          (sntl2 := ([@expl:sntl := new Node] mk_Node s));
          (let sntlVal = ref 0 in
           (((sntlVal := ([@expl:sntlVal := - 1] 0 - 1));
             ([@expl:Node(sntl,sntlVal,sntlVal)] init_Node s (! sntl2) (! sntlVal) (! sntlVal));
             (assert {
                forall pq: reference.
                  (isAllocated s pq) -> ((hasPqueueType s pq) -> ((Rgn.mem pq s.pool) -> (not ((s.heap.sntl[pq]) = (! sntl2))))) });
             (s.heap.rep <- ([@expl:self.rep := {}] M.add (! self) emptyRgn s.heap.rep));
             (s.heap.sntl <- ([@expl:self.sntl := sntl] M.add (! self) (! sntl2) s.heap.sntl));
             (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl2) s.heap.head));
             (s.heap.sibling <- ([@expl:sntl.sibling := sntl] M.add (! sntl2) (! sntl2) s.heap.sibling));
             (s.heap.child <- ([@expl:sntl.child := sntl] M.add (! sntl2) (! sntl2) s.heap.child));
             (s.heap.prev <- ([@expl:sntl.prev := sntl] M.add (! sntl2) (! sntl2) s.heap.prev));
             (s.pool <-
                ([@expl:pool := pool union {self} union {sntl}] Rgn.union (Rgn.union s.pool (singleton (! self))) (singleton (! sntl2))));
             (! result))))))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert { let sntl1 = s.heap.sntl[! self] in
                   not ((s.heap.head[! self]) = sntl1) });
         (result := ([@expl:result := self.head] s.heap.head[! self]));
         (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let first = ref first in
        (let second = ref second in
         (let fkey = ref 0 in
          (let skey = ref 0 in
           (let tmp = ref null in
            (((assert { hasNodeType s (! tmp) });
              (let ghost rep3 = ref emptyRgn in
               (((assert { isValidRgn s (! rep3) });
                 (let sntl4 = ref null in
                  (((assert { hasNodeType s (! sntl4) });
                    (sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                    (assert { ((! first) <> (! sntl4)) /\ ((! second) <> (! sntl4)) });
                    (rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                    (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
                    (skey := ([@expl:skey := second.key] s.heap.key[! second]));
                    (assert {
                       forall p: reference.
                         (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (repOk s p)))) });
                    (if ((! skey) < (! fkey))
                     then (((tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                            (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                            (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                            (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                            (assert { let p = s.heap.prev[! first] in
                                      Rgn.mem p (! rep3) });
                            (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                            (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                    (assert { let rep5 = s.heap.rep[! self] in
                                              Rgn.mem (! tmp) rep5 });
                                    (assert {
                                       forall p: reference.
                                         (isAllocated s p) ->
                                           ((hasPqueueType s p) ->
                                              ((Rgn.mem p s.pool) ->
                                                 ((p <> (! self)) -> (let rep6 = s.heap.rep[p] in
                                                                    not (Rgn.mem (! tmp) rep6))))) });
                                    (assert {
                                       let rep7 = s.heap.rep[! self] in
                                       let p = s.heap.prev[! tmp] in
                                       (p = (! sntl4)) \/ (Rgn.mem p rep7) });
                                    (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                                    (assert { Rgn.mem (! tmp) (! rep3) });
                                    (assert { let p = s.heap.prev[! tmp] in
                                              Rgn.mem p (! rep3) });
                                    (assert { repOk s (! self) })))
                             else ());
                            (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                            (result := ([@expl:result := second] ! second));
                            (assert { repOk s (! self) })))
                     else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                            (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                            (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                            (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                    (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                             else ());
                            (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                            (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((assert { Rgn.mem (! tmp) (! rep3) });
                                    (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                                    (assert { Rgn.mem (! tmp) (! rep3) });
                                    (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                             else ());
                            (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                            (result := ([@expl:result := first] ! first));
                            (assert { repOk s (! self) }))));
                    (! result)))))))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {})`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {})`child] wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self}`rep union {})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) emptyRgn) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (let sntl3 = ref null in
          (((assert { hasNodeType s (! sntl3) });
            (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
            (result := ([@expl:result := new Node] mk_Node s));
            ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
            (assert { PQUEUE.pqueuePub s });
            (assert {
               forall p: reference.
                 (isAllocated s p) ->
                   ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep4 = s.heap.rep[p] in
                                                                   not (Rgn.mem (! result) rep4)))) });
            (s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! result) (! sntl3) s.heap.sibling));
            (s.heap.child <- ([@expl:result.child := sntl] M.add (! result) (! sntl3) s.heap.child));
            (s.heap.prev <- ([@expl:result.prev := sntl] M.add (! result) (! sntl3) s.heap.prev));
            (let ghost rep5 = ref emptyRgn in
             (((assert { isValidRgn s (! rep5) });
               (rep5 := ([@expl:rep := self.rep] s.heap.rep[! self]));
               (assert { (repOk s (! self)) /\ (nodeP s (! rep5)) });
               (s.heap.rep <-
                  ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep5) (singleton (! result))) s.heap.rep));
               (assert { repOk s (! self) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = old (s.heap.rep[p]) in
                                                                    (s.heap.rep[p]) = r)))) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = s.heap.rep[p] in
                                                                    not (Rgn.mem (! result) r))))) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = s.heap.rep[p] in
                                                                    let r2 = s.heap.rep[! self] in
                                                                    r \# r2)))) });
               (assert { PQUEUE.pqueuePub s });
               (assert { let r = s.heap.rep[! self] in
                         nodeP s r });
               (assert {
                  forall p: reference.
                    (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let r = s.heap.rep[p] in
                                                                    nodeP s r))) });
               (let hd = ref null in
                (((assert { hasNodeType s (! hd) });
                  (hd := ([@expl:hd := self.head] s.heap.head[! self]));
                  (if ((! hd) =. (! sntl3))
                   then (((s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                          (assert { repOk s (! self) })))
                   else (let tmp = ref null in
                         (((assert { hasNodeType s (! tmp) });
                           (tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                           (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                           (assert {
                              let hd6 = s.heap.head[! self] in
                              let rep7 = s.heap.rep[! self] in
                              (hd6 <> null) /\ (Rgn.mem hd6 rep7) })))));
                  (let sz = ref 0 in
                   (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
                     (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                     (! result))))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { let sntl3 = s.heap.sntl[self] in
               (not ((s.heap.sibling[handle]) = sntl3)) /\ (not ((s.heap.sibling[handle]) = null)) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let trees = ref null in
         (((assert { hasNodeArrayType s (! trees) });
           (let index = ref 0 in
            (let current = ref null in
             (((assert { hasNodeType s (! current) });
               (let sntl4 = ref null in
                (((assert { hasNodeType s (! sntl4) });
                  (let tmp = ref null in
                   (((assert { hasNodeType s (! tmp) });
                     (let fst = ref null in
                      (((assert { hasNodeType s (! fst) });
                        (let snd = ref null in
                         (((assert { hasNodeType s (! snd) });
                           (let i = ref 0 in
                            (let j = ref 0 in
                             (((sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                               (((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                                 (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                                 (s.heap.slots <-
                                    ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                               (s.heap.slots <-
                                  ([@expl:trees.{0} := handle]
                                   M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                               (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                               (assert {
                                  forall p: reference.
                                    (isAllocated s p) ->
                                      ((hasNodeArrayType s p) ->
                                         ((p <> (! trees)) -> (let s5 = old (s.heap.slots[p]) in
                                                               (s.heap.slots[p]) = s5))) });
                               (index := ([@expl:index := 1] 1));
                               (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                               (while (! current) <>. (! sntl4) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! tmp)) /\
                                      ((hasNodeType s (! sntl4)) /\
                                         ((hasNodeType s (! snd)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! result)) /\
                                                  ((hasNodeType s (! handle)) /\
                                                     ((hasNodeType s (! fst)) /\
                                                        ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant { 1 <= (! index) }
                                  invariant { let l = s.heap.length[! trees] in
                                              (! index) < l }
                                  invariant {
                                    forall k6: int.
                                      (0 <= k6) -> ((k6 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k6) = (! sntl4)))) }
                                  invariant {
                                    forall k7: int.
                                      (0 <= k7) ->
                                        ((k7 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k7 in
                                            let rep8 = s.heap.rep[! self] in
                                            Rgn.mem n rep8)) }
                                  invariant {
                                    ((! current) <> (! sntl4)) -> (let rep9 = s.heap.rep[! self] in
                                                                   Rgn.mem (! current) rep9) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeType s p) ->
                                           ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                              (let sib = old (s.heap.sibling[p]) in
                                               let pre = old (s.heap.prev[p]) in
                                               let chl = old (s.heap.child[p]) in
                                               ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeArrayType s p) ->
                                           ((p <> (! trees)) ->
                                              (let slots10 = old (s.heap.slots[p]) in
                                               let length11 = old (s.heap.length[p]) in
                                               ((s.heap.slots[p]) = slots10) /\ ((s.heap.length[p]) = length11)))) }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant { pqueueI s }
                                  ((assume { let l = s.heap.length[! trees] in
                                             (! index) < (l - 1) });
                                   (s.heap.slots <-
                                      ([@expl:trees.{index} := current]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                                   (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                                   (s.heap.sibling <- ([@expl:tmp.sibling := sntl] M.add (! tmp) (! sntl4) s.heap.sibling));
                                   (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                                   (index := ([@expl:index := index + 1] (! index) + 1)))
                                done);
                               (s.heap.slots <-
                                  ([@expl:trees.{index} := sntl]
                                   M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! sntl4)) s.heap.slots));
                               (i := ([@expl:i := 0] 0));
                               (tmp := ([@expl:tmp := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                               (while ((! i) + 1) < (! index) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! tmp)) /\
                                      ((hasNodeType s (! sntl4)) /\
                                         ((hasNodeType s (! snd)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! result)) /\
                                                  ((hasNodeType s (! handle)) /\
                                                     ((hasNodeType s (! fst)) /\
                                                        ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant {
                                    forall k12: int.
                                      (0 <= k12) -> ((k12 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k12) = (! sntl4)))) }
                                  invariant {
                                    forall k13: int.
                                      (0 <= k13) ->
                                        ((k13 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k13 in
                                            let rep14 = s.heap.rep[! self] in
                                            Rgn.mem n rep14)) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeType s p) ->
                                           ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                              (let sib = old (s.heap.sibling[p]) in
                                               let pre = old (s.heap.prev[p]) in
                                               let chl = old (s.heap.child[p]) in
                                               ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeArrayType s p) ->
                                           ((p <> (! trees)) ->
                                              (let slots15 = old (s.heap.slots[p]) in
                                               let length16 = old (s.heap.length[p]) in
                                               ((s.heap.slots[p]) = slots15) /\ ((s.heap.length[p]) = length16)))) }
                                  invariant { let rep17 = s.heap.rep[! self] in
                                              (Rgn.mem (! tmp) rep17) /\ ((! tmp) <> null) }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant { pqueueI s }
                                  invariant { 0 <= (! i) }
                                  invariant { (! i) <= (! index) }
                                  ((fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                                   (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                                   (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                   (s.heap.slots <-
                                      ([@expl:trees.{i} := tmp]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                                   (i := ([@expl:i := i + 2] (! i) + 2)))
                                done);
                               (j := ([@expl:j := i - 2] (! i) - 2));
                               (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                                then (((assert { ((! j) + 2) < (! index) });
                                       (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                       (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                                       (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                       (s.heap.slots <-
                                          ([@expl:trees.{j} := tmp]
                                           M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                                else ());
                               (while 2 <= (! j) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! tmp)) /\
                                      ((hasNodeType s (! sntl4)) /\
                                         ((hasNodeType s (! snd)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! result)) /\
                                                  ((hasNodeType s (! handle)) /\
                                                     ((hasNodeType s (! fst)) /\
                                                        ((hasNodeType s (! current)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant {
                                    forall k18: int.
                                      (0 <= k18) -> ((k18 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k18) = (! sntl4)))) }
                                  invariant {
                                    forall k19: int.
                                      (0 <= k19) ->
                                        ((k19 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k19 in
                                            let rep20 = s.heap.rep[! self] in
                                            Rgn.mem n rep20)) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeType s p) ->
                                           ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                              (let sib = old (s.heap.sibling[p]) in
                                               let pre = old (s.heap.prev[p]) in
                                               let chl = old (s.heap.child[p]) in
                                               ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                                  invariant {
                                    forall p: reference.
                                      (isAllocated s p) ->
                                        ((hasNodeArrayType s p) ->
                                           ((p <> (! trees)) ->
                                              (let slots21 = old (s.heap.slots[p]) in
                                               let length22 = old (s.heap.length[p]) in
                                               ((s.heap.slots[p]) = slots21) /\ ((s.heap.length[p]) = length22)))) }
                                  invariant { let rep23 = s.heap.rep[! self] in
                                              (Rgn.mem (! tmp) rep23) /\ ((! tmp) <> null) }
                                  invariant { (0 - 2) <= (! j) }
                                  invariant { (! j) < (! index) }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant { pqueueI s }
                                  ((fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                                   (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                   (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                   (assert { ((! tmp) <> null) /\ (typeofRgn s (singleton (! tmp)) (L.Cons Node L.Nil)) });
                                   (s.heap.slots <-
                                      ([@expl:trees.{j - 2} := tmp]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                                   (j := ([@expl:j := j - 2] (! j) - 2)))
                                done);
                               (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                               (! result))))))))))))))))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { pqueueI s }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let tmp = ref null in
         (((assert { hasNodeType s (! tmp) });
           (let sntl3 = ref null in
            (((assert { hasNodeType s (! sntl3) });
              (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
              (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
              (if ((! tmp) =. (! sntl3)) then (result := ([@expl:result := handle] ! handle))
               else (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))));
              (! result)))))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self} union {})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (Rgn.union (s.heap.rep[self]) (singleton self)) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self} union {})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (Rgn.union (s.heap.rep[self]) (singleton self)) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { PQUEUE.pqueuePub s }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((result := ([@expl:result := findMin(self)] findMin s (! self)));
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let sntl3 = ref null in
             (((assert { hasNodeType s (! sntl3) });
               (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
               (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
               (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
               (if ((! tmp) =. (! sntl3))
                then (((assume { (s.heap.size[! self]) = 1 });
                       (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl3) s.heap.head))))
                else (((assume { let sz = s.heap.size[! self] in
                                 sz > 1 });
                       (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                       (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
               (let sz = ref 0 in
                (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
                  (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
                  (! result)))))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r40 = old (Rgn.union (img_rep s s.pool) s.pool) in
              Rgn.subset bsnap_r40 (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { PQUEUE.pqueuePub s }
    ensures { (s.heap.key[handle]) = k }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let handle = ref handle in
        (let k = ref k in
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let pos = ref null in
             (((assert { hasNodeType s (! pos) });
               (let sntl3 = ref null in
                (((assert { hasNodeType s (! sntl3) });
                  (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                  (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
                  (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                  (assert { repOk s (! self) });
                  (if ((! handle) <>. (! tmp))
                   then (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                          (if ((! tmp) <>. (! sntl3))
                           then (((pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                                  (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev));
                                  (assert { repOk s (! self) })))
                           else ());
                          (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                          (if ((! tmp) <>. (! sntl3))
                           then (((pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                                  (if ((! pos) =. (! handle))
                                   then (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                          (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                                   else (((assert { not ((s.heap.prev[! handle]) = (! sntl3)) });
                                          (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                          (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                          (assert {
                                             ((! pos) <> (! sntl3)) ->
                                               (let rep4 = s.heap.rep[! self] in
                                                let s5 = s.heap.sibling[! tmp] in
                                                Rgn.mem s5 rep4) }))));
                                  (assert {
                                     forall p: reference.
                                       (isAllocated s p) ->
                                         ((hasNodeType s p) ->
                                            (let r = s.heap.rep[! self] in
                                             (not (Rgn.mem p r)) -> (let sib = old (s.heap.sibling[p]) in
                                                                    (s.heap.sibling[p]) = sib))) })))
                           else ());
                          (s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! handle) (! sntl3) s.heap.sibling));
                          (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                          (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                          (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
                   else ());
                  (! result)))))))))))))
  
  lemma boundary_frames_invariant_PqueueR : forall s: state, t6: state, pi: 
                                              PreRefperm.t.
                                              (okRefperm s t6 pi) ->
                                                ((PreRefperm.identity pi s.alloct.M.domain t6.alloct.M.domain) ->
                                                   ((PreRefperm.idRgn pi s.pool t6.pool) ->
                                                      ((agree_allfields s t6 pi (Rgn.union (img_rep s s.pool) s.pool)) ->
                                                         ((pqueueI s) -> (pqueueI t6)))))
end

module PQUEUE_REL
  
  use prelude.Prelude
  use State
  use PqueueL
  use PqueueR
  
  predicate coupling0 (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_pq: reference) (r_pq: reference) =
    (hasPqueueType l_s l_pq) ->
      ((hasPqueueType r_s r_pq) ->
         (((l_pq <> null) /\ (r_pq <> null)) ->
            ((PreRefperm.idRef pi l_pq r_pq) ->
               (let l_sntl = l_s.heap.sntl[l_pq] in
                let r_sntl = r_s.heap.sntl[r_pq] in
                let l_rep = l_s.heap.rep[l_pq] in
                let r_rep = r_s.heap.rep[r_pq] in
                let l_hd = l_s.heap.head[l_pq] in
                let r_hd = r_s.heap.head[r_pq] in
                let l_sz = l_s.heap.size[l_pq] in
                let r_sz = r_s.heap.size[r_pq] in
                (l_sz = r_sz) /\
                  (((PreRefperm.idRef pi l_hd r_hd) \/ ((l_hd = null) /\ (r_hd = r_sntl))) /\
                     (forall l_n: reference, r_n: reference.
                        (isAllocated l_s l_n) ->
                          ((hasNodeType l_s l_n) ->
                             ((Rgn.mem l_n l_rep) ->
                                ((isAllocated r_s r_n) ->
                                   ((hasNodeType r_s r_n) ->
                                      ((Rgn.mem r_n r_rep) ->
                                         ((PreRefperm.idRef pi l_n r_n) ->
                                            (let l_k = l_s.heap.key[l_n] in
                                             let r_k = r_s.heap.key[r_n] in
                                             let l_t = l_s.heap.tag[l_n] in
                                             let r_t = r_s.heap.tag[r_n] in
                                             let l_pre = l_s.heap.prev[l_n] in
                                             let r_pre = r_s.heap.prev[r_n] in
                                             let l_sib = l_s.heap.sibling[l_n] in
                                             let r_sib = r_s.heap.sibling[r_n] in
                                             let l_chl = l_s.heap.child[l_n] in
                                             let r_chl = r_s.heap.child[r_n] in
                                             (l_k = r_k) /\
                                               ((l_t = r_t) /\
                                                  ((((PreRefperm.idRef pi l_pre r_pre) /\ ((l_pre <> null) /\ (r_pre <> r_sntl))) \/
                                                      ((l_pre = null) /\ (r_pre = r_sntl))) /\
                                                     ((((PreRefperm.idRef pi l_sib r_sib) /\ ((l_sib <> null) /\ (r_sib <> r_sntl))) \/
                                                         ((l_sib = null) /\ (r_sib = r_sntl))) /\
                                                        (((PreRefperm.idRef pi l_chl r_chl) /\ ((l_chl <> null) /\ (r_chl <> r_sntl))) \/
                                                           ((l_chl = null) /\ (r_chl = r_sntl)))))))))))))))))))
  
  predicate coupling (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (forall l_pq: reference, r_pq: reference.
       (isAllocated l_s l_pq) ->
         ((hasPqueueType l_s l_pq) ->
            ((Rgn.mem l_pq l_s.pool) ->
               ((isAllocated r_s r_pq) ->
                  ((hasPqueueType r_s r_pq) ->
                     ((Rgn.mem r_pq r_s.pool) -> ((PreRefperm.idRef pi l_pq r_pq) -> (coupling0 l_s r_s pi l_pq r_pq)))))))) /\
      (((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) /\ ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)))
  
  let isEmpty (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (agree_size l_s r_s pi (singleton l_self)) /\ (agree_size r_s l_s (PreRefperm.invert pi) (singleton r_self)) }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) } =
    label INIT in
      let l_result = ref false in
      (let r_result = ref false in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let l_sz = ref 0 in
          (let r_sz = ref 0 in
           (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
               (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
             (l_result := ([@expl:result := sz = 0] (! l_sz) = 0));
             (r_result := ([@expl:result := sz = 0] (! r_sz) = 0));
             (! l_result, ! r_result))))))))
  
  let findMin (l_s: state) (r_s: state) (pi7: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi7 }
    requires { coupling l_s r_s pi7 }
    requires { PreRefperm.idRef pi7 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { okRefperm l_s r_s pi7 }
    ensures { coupling l_s r_s pi7 }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi7 l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let hd = l_s.heap.head[l_self] in
                      l_result = hd) /\ (let hd = r_s.heap.head[r_self] in
                                         r_result = hd))
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi7 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi7) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (((assert {
              (not ((l_s.heap.head[! l_self]) = null)) /\
                (let sntl8 = r_s.heap.sntl[! r_self] in
                 not ((r_s.heap.head[! r_self]) = sntl8)) });
           (l_result := ([@expl:result := self.head] l_s.heap.head[! l_self]));
           (r_result := ([@expl:result := self.head] r_s.heap.head[! r_self]));
           (! l_result, ! r_result))))))
  
  val link (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_first: reference) (l_second: reference) (r_self: reference) (r_first: reference) (r_second: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_first }
    requires { l_first <> null }
    requires { hasNodeType l_s l_second }
    requires { l_second <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_first }
    requires { r_first <> null }
    requires { hasNodeType r_s r_second }
    requires { r_second <> null }
    requires { okRefperm l_s r_s pi }
    requires { PreRefperm.idRef pi l_second r_second }
    requires { PreRefperm.idRef pi l_first r_first }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { coupling l_s r_s pi }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let rep9 = l_s.heap.rep[l_self] in
                (Rgn.mem l_first rep9) /\ (Rgn.mem l_second rep9)) /\
                 (let rep10 = r_s.heap.rep[r_self] in
                  (Rgn.mem r_first rep10) /\ (Rgn.mem r_second rep10)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.child }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.child }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (((l_result = l_first) \/ (l_result = l_second)) /\ ((r_result = r_first) \/ (r_result = r_second)))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((((l_result = l_first) /\ ((l_s.heap.child[l_first]) = l_second)) \/
                        ((l_result = l_second) /\ ((l_s.heap.child[l_second]) = l_first))) /\
                       (((r_result = r_first) /\ ((r_s.heap.child[r_first]) = r_second)) \/
                          ((r_result = r_second) /\ ((r_s.heap.child[r_second]) = r_first))))
              end }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let insert (l_s: state) (r_s: state) (pi11: PreRefperm.t) (l_self: reference) (l_k: int) (l_t: int) (r_self: reference) (r_k: int) (r_t: int) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi11 }
    requires { coupling l_s r_s pi11 }
    requires { l_t = r_t }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi11 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    requires { (0 <= l_t) /\ (0 <= r_t) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    writes { pi11 }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.rep }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.tag }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.rep }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.tag }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union emptyRgn (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({} union {self}`rep)`prev] wrs_to_prev_framed_by (old l_s) l_s (Rgn.union emptyRgn (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({} union {self}`rep)`child] wrs_to_child_framed_by (old l_s) l_s (Rgn.union emptyRgn (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({} union {self}`rep)`tag] wrs_to_tag_framed_by (old l_s) l_s (Rgn.union emptyRgn (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({} union {self}`rep)`key] wrs_to_key_framed_by (old l_s) l_s (Rgn.union emptyRgn (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union emptyRgn (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({} union {self}`rep)`prev] wrs_to_prev_framed_by (old r_s) r_s (Rgn.union emptyRgn (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({} union {self}`rep)`child] wrs_to_child_framed_by (old r_s) r_s (Rgn.union emptyRgn (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({} union {self}`rep)`tag] wrs_to_tag_framed_by (old r_s) r_s (Rgn.union emptyRgn (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({} union {self}`rep)`key] wrs_to_key_framed_by (old r_s) r_s (Rgn.union emptyRgn (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { okRefperm l_s r_s pi11 }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep12 = l_s.heap.rep[l_self] in
                      forall n: reference.
                        (isAllocated l_s n) ->
                          ((hasNodeType l_s n) ->
                             ((Rgn.mem n rep12) ->
                                ((n <> l_result) ->
                                   (let ot = old (l_s.heap.tag[n]) in
                                    let ok = old (l_s.heap.key[n]) in
                                    ((l_s.heap.tag[n]) = ot) /\ ((l_s.heap.key[n]) = ok)))))) /\
                       (let rep13 = r_s.heap.rep[r_self] in
                        forall n: reference.
                          (isAllocated r_s n) ->
                            ((hasNodeType r_s n) ->
                               ((Rgn.mem n rep13) ->
                                  ((n <> r_result) ->
                                     (let ot = old (r_s.heap.tag[n]) in
                                      let ok = old (r_s.heap.key[n]) in
                                      ((r_s.heap.tag[n]) = ot) /\ ((r_s.heap.key[n]) = ok)))))))
              end }
    ensures { coupling l_s r_s pi11 }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi11 l_result r_result) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.tag[l_result]) = l_t) /\ ((r_s.heap.tag[r_result]) = r_t)) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.key[l_result]) = l_k) /\ ((r_s.heap.key[r_result]) = r_k)) end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let orep = old (l_s.heap.rep[l_self]) in
                      (l_s.heap.rep[l_self]) = (Rgn.union orep (singleton l_result))) /\
                       (let orep = old (r_s.heap.rep[r_self]) in
                        (r_s.heap.rep[r_self]) = (Rgn.union orep (singleton r_result))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep14 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep14) /\
                       (let rep15 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep15))
              end }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let l_k = ref l_k in
         (let l_t = ref l_t in
          (let r_self = ref r_self in
           (let r_k = ref r_k in
            (let r_t = ref r_t in
             (((assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) });
               (let l_sntl = ref null in
                (let r_sntl = ref null in
                 ((((();
                     (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                   (((l_result := ([@expl:result := new Node] mk_Node l_s));
                     (r_result := ([@expl:result := new Node] mk_Node r_s))));
                   ((([@expl:Node(result,k,t)] PqueueL.init_Node l_s (! l_result) (! l_k) (! l_t));
                     ([@expl:Node(result,k,t)] PqueueR.init_Node r_s (! r_result) (! r_k) (! r_t))));
                   ((();
                     (r_s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! r_result) (! r_sntl) r_s.heap.sibling));
                     (r_s.heap.child <- ([@expl:result.child := sntl] M.add (! r_result) (! r_sntl) r_s.heap.child));
                     (r_s.heap.prev <- ([@expl:result.prev := sntl] M.add (! r_result) (! r_sntl) r_s.heap.prev))));
                   (PreRefperm.updateRefperm pi11 (! l_result) (! r_result));
                   (assert { PreRefperm.idRef pi11 (! l_result) (! r_result) });
                   (assert {
                      (((l_s.heap.sibling[! l_result]) = null) /\
                         (((l_s.heap.child[! l_result]) = null) /\ ((l_s.heap.prev[! l_result]) = null))) /\
                        (((r_s.heap.sibling[! r_result]) = (! r_sntl)) /\
                           (((r_s.heap.child[! r_result]) = (! r_sntl)) /\ ((r_s.heap.prev[! r_result]) = (! r_sntl)))) });
                   (let ghost l_rep = ref emptyRgn in
                    (let ghost r_rep = ref emptyRgn in
                     (((((l_rep := ([@expl:rep := self.rep] l_s.heap.rep[! l_self]));
                         (r_rep := ([@expl:rep := self.rep] r_s.heap.rep[! r_self]))));
                       (((l_s.heap.rep <-
                            ([@expl:self.rep := rep union {result}]
                             M.add (! l_self) (Rgn.union (! l_rep) (singleton (! l_result))) l_s.heap.rep));
                         (r_s.heap.rep <-
                            ([@expl:self.rep := rep union {result}]
                             M.add (! r_self) (Rgn.union (! r_rep) (singleton (! r_result))) r_s.heap.rep))));
                       (let l_hd = ref null in
                        (let r_hd = ref null in
                         (((((l_hd := ([@expl:hd := self.head] l_s.heap.head[! l_self]));
                             (r_hd := ([@expl:hd := self.head] r_s.heap.head[! r_self]))));
                           (assert { ((l_s.heap.head[! l_self]) = null) <-> ((r_s.heap.head[! r_self]) = (! r_sntl)) });
                           ((([@expl:guard agreement] assert { ((! l_hd) = null) = ((! r_hd) = (! r_sntl)) });
                             (if ((! l_hd) =. null)
                              then (((((l_s.heap.head <- ([@expl:self.head := result] M.add (! l_self) (! l_result) l_s.heap.head));
                                       (r_s.heap.head <- ([@expl:self.head := result] M.add (! r_self) (! r_result) r_s.heap.head))));
                                     (assert {
                                        let l_hd = l_s.heap.head[! l_self] in
                                        let r_hd = r_s.heap.head[! r_self] in
                                        PreRefperm.idRef pi11 l_hd r_hd });
                                     (assert {
                                        forall l_pq: reference, r_pq: reference.
                                          (isAllocated l_s l_pq) ->
                                            ((hasPqueueType l_s l_pq) ->
                                               ((Rgn.mem l_pq l_s.pool) ->
                                                  ((isAllocated r_s r_pq) ->
                                                     ((hasPqueueType r_s r_pq) ->
                                                        ((Rgn.mem r_pq r_s.pool) ->
                                                           ((PreRefperm.idRef pi11 l_pq r_pq) ->
                                                              (let l_hd = l_s.heap.head[l_pq] in
                                                               let r_hd = r_s.heap.head[r_pq] in
                                                               (PreRefperm.idRef pi11 l_hd r_hd) \/
                                                                 ((l_hd = null) /\ ((r_s.heap.sntl[r_pq]) = r_hd))))))))) });
                                     (assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) })))
                              else (((assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) });
                                     (let l_tmp = ref null in
                                      (let r_tmp = ref null in
                                       (((assume {
                                            ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)) /\
                                              ((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) });
                                         (match link l_s r_s pi11 (! l_self) (! l_hd) (! l_result) (! r_self) (! r_hd) (! r_result)
                                          with
                                            | (l_link_res, r_link_res) ->
                                                (((l_tmp := ([@expl:tmp := link(self,hd,result)] l_link_res));
                                                  (r_tmp := ([@expl:tmp := link(self,hd,result)] r_link_res))))
                                          end);
                                         (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                                         (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))))))));
                           (let l_sz = ref 0 in
                            (let r_sz = ref 0 in
                             (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                                 (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                               (assert { (! l_sz) = (! r_sz) });
                               (((l_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! l_self) ((! l_sz) + 1) l_s.heap.size));
                                 (r_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! r_self) ((! r_sz) + 1) r_s.heap.size))));
                               (assume {
                                  ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)) /\
                                    ((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) });
                               (! l_result, ! r_result))))))))))))))))))))))))))
  
  val combine (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (r_self: reference) (r_handle: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (let rep16 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep16) /\
                 (let rep17 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep17) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.slots }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.child }
    writes { l_s.heap.length }
    writes { l_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.child }
    writes { r_s.heap.length }
    writes { r_s.alloct }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old l_s) l_s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old l_s) l_s emptyRgn }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old r_s) r_s emptyRgn }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old r_s) r_s emptyRgn }
    ensures { okRefperm l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { coupling l_s r_s pi }
    ensures { (let ohd = old (l_s.heap.head[l_self]) in
               (l_s.heap.head[l_self]) = ohd) /\
                (let ohd = old (r_s.heap.head[r_self]) in
                 (r_s.heap.head[r_self]) = ohd) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep18 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep18) /\
                       (let rep19 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep19))
              end }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let deleteMin (l_s: state) (r_s: state) (pi20: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi20 }
    requires { PreRefperm.idRef pi20 l_self r_self }
    requires { coupling l_s r_s pi20 }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.length }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.length }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.slots }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr ({} union {self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union emptyRgn (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self))) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union emptyRgn (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self))) }
    ensures { [@expl:wr ({self}`rep union {self})`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr ({} union {self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union emptyRgn (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self))) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union emptyRgn (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self))) }
    ensures { [@expl:wr ({self}`rep union {self})`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { okRefperm l_s r_s pi20 }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { (let rep21 = l_s.heap.rep[l_self] in
               forall n: reference.
                 (isAllocated l_s n) ->
                   ((hasNodeType l_s n) ->
                      ((Rgn.mem n rep21) ->
                         (let otag = old (l_s.heap.tag[n]) in
                          let okey = old (l_s.heap.key[n]) in
                          ((l_s.heap.tag[n]) = otag) /\ ((l_s.heap.key[n]) = okey))))) /\
                (let rep22 = r_s.heap.rep[r_self] in
                 forall n: reference.
                   (isAllocated r_s n) ->
                     ((hasNodeType r_s n) ->
                        ((Rgn.mem n rep22) ->
                           (let otag = old (r_s.heap.tag[n]) in
                            let okey = old (r_s.heap.key[n]) in
                            ((r_s.heap.tag[n]) = otag) /\ ((r_s.heap.key[n]) = okey))))) }
    ensures { (let orep = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = orep) /\
                (let orep = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = orep) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi20 l_result r_result) end }
    ensures { coupling l_s r_s pi20 }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (((match findMin l_s r_s pi20 (! l_self) (! r_self)
            with
              | (l_findMin_res, r_findMin_res) ->
                  (((l_result := ([@expl:result := findMin(self)] l_findMin_res));
                    (r_result := ([@expl:result := findMin(self)] r_findMin_res))))
            end);
           (let l_tmp = ref null in
            (let r_tmp = ref null in
             (let l_sntl = ref null in
              (let r_sntl = ref null in
               ((((();
                   (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                 (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                   (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                 (((l_tmp := ([@expl:tmp := tmp.child] l_s.heap.child[! l_tmp]));
                   (r_tmp := ([@expl:tmp := tmp.child] r_s.heap.child[! r_tmp]))));
                 ((([@expl:guard agreement] assert { ((! l_tmp) = null) = ((! r_tmp) = (! r_sntl)) });
                   (if ((! l_tmp) =. null)
                    then (((assume { ((l_s.heap.size[! l_self]) = 1) /\ ((r_s.heap.size[! r_self]) = 1) });
                           (l_s.heap.head <- ([@expl:self.head := null] M.add (! l_self) null l_s.heap.head));
                           (r_s.heap.head <- ([@expl:self.head := sntl] M.add (! r_self) (! r_sntl) r_s.heap.head))))
                    else (((assume { (let sz = l_s.heap.size[! l_self] in
                                      sz > 1) /\ (let sz = r_s.heap.size[! r_self] in
                                                  sz > 1) });
                           (match combine l_s r_s pi20 (! l_self) (! l_tmp) (! r_self) (! r_tmp)
                            with
                              | (l_combine_res, r_combine_res) ->
                                  (((l_tmp := ([@expl:tmp := combine(self,tmp)] l_combine_res));
                                    (r_tmp := ([@expl:tmp := combine(self,tmp)] r_combine_res))))
                            end);
                           (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                           (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))));
                 (let l_sz = ref 0 in
                  (let r_sz = ref 0 in
                   (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                       (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                     (((l_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! l_self) ((! l_sz) - 1) l_s.heap.size));
                       (r_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! r_self) ((! r_sz) - 1) r_s.heap.size))));
                     (assume { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) });
                     (! l_result, ! r_result))))))))))))))))
  
  let decreaseKey (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (l_k: int) (r_self: reference) (r_handle: reference) (r_k: int) : 
    (unit,
     unit)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (let key23 = l_s.heap.key[l_handle] in
                l_k <= key23) /\ (let key24 = r_s.heap.key[r_handle] in
                                  r_k <= key24) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    requires { (let rep25 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep25) /\
                 (let rep26 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep26) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { ((l_s.heap.key[l_handle]) = l_k) /\ ((r_s.heap.key[r_handle]) = r_k) }
    ensures { (let bsnap_r14 = old (Rgn.union (img_rep l_s l_s.pool) l_s.pool) in
               Rgn.subset bsnap_r14 (Rgn.union (img_rep l_s l_s.pool) l_s.pool)) /\
                (let bsnap_r14 = old (Rgn.union (img_rep r_s r_s.pool) r_s.pool) in
                 Rgn.subset bsnap_r14 (Rgn.union (img_rep r_s r_s.pool) r_s.pool)) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    label INIT in
      let l_result = ref () in
      (let r_result = ref () in
       (let l_self = ref l_self in
        (let l_handle = ref l_handle in
         (let l_k = ref l_k in
          (let r_self = ref r_self in
           (let r_handle = ref r_handle in
            (let r_k = ref r_k in
             (let l_tmp = ref null in
              (let r_tmp = ref null in
               (let l_pos = ref null in
                (let r_pos = ref null in
                 (let l_sntl = ref null in
                  (let r_sntl = ref null in
                   ((((();
                       (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                     (((l_s.heap.key <- ([@expl:handle.key := k] M.add (! l_handle) (! l_k) l_s.heap.key));
                       (r_s.heap.key <- ([@expl:handle.key := k] M.add (! r_handle) (! r_k) r_s.heap.key))));
                     (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                       (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                     ((([@expl:guard agreement] assert { ((! l_handle) <> (! l_tmp)) = ((! r_handle) <> (! r_tmp)) });
                       (if ((! l_handle) <>. (! l_tmp))
                        then (((((l_tmp := ([@expl:tmp := handle.sibling] l_s.heap.sibling[! l_handle]));
                                 (r_tmp := ([@expl:tmp := handle.sibling] r_s.heap.sibling[! r_handle]))));
                               ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                                 (if ((! l_tmp) <>. null)
                                  then (((((l_pos := ([@expl:pos := handle.prev] l_s.heap.prev[! l_handle]));
                                           (r_pos := ([@expl:pos := handle.prev] r_s.heap.prev[! r_handle]))));
                                         (l_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! l_tmp) (! l_pos) l_s.heap.prev));
                                         (r_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! r_tmp) (! r_pos) r_s.heap.prev))))
                                  else ((();
                                         ())))));
                               (((l_tmp := ([@expl:tmp := handle.prev] l_s.heap.prev[! l_handle]));
                                 (r_tmp := ([@expl:tmp := handle.prev] r_s.heap.prev[! r_handle]))));
                               ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                                 (if ((! l_tmp) <>. null)
                                  then (((((l_pos := ([@expl:pos := tmp.child] l_s.heap.child[! l_tmp]));
                                           (r_pos := ([@expl:pos := tmp.child] r_s.heap.child[! r_tmp]))));
                                         (assert {
                                            ((not ((l_s.heap.prev[! l_handle]) = null)) /\ (not ((r_s.heap.prev[! r_handle]) = null))) /\
                                              (not ((r_s.heap.prev[! r_handle]) = (! r_sntl))) });
                                         (assert {
                                            (PreRefperm.idRef pi (! l_tmp) (! r_tmp)) /\
                                              (((! l_tmp) <> null) /\ ((! r_tmp) <> (! r_sntl))) });
                                         (assert {
                                            let l_c = l_s.heap.child[! l_tmp] in
                                            let r_c = r_s.heap.child[! r_tmp] in
                                            ((PreRefperm.idRef pi l_c r_c) /\ ((l_c <> null) /\ (r_c <> (! r_sntl)))) \/
                                              ((l_c = null) /\ (r_c = (! r_sntl))) });
                                         ([@expl:guard agreement] assert { ((! l_pos) = (! l_handle)) = ((! r_pos) = (! r_handle)) });
                                         (if ((! l_pos) =. (! l_handle))
                                          then (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                   (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                                 (l_s.heap.child <- ([@expl:tmp.child := pos] M.add (! l_tmp) (! l_pos) l_s.heap.child));
                                                 (r_s.heap.child <- ([@expl:tmp.child := pos] M.add (! r_tmp) (! r_pos) r_s.heap.child))))
                                          else (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                   (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                                 (l_s.heap.sibling <-
                                                    ([@expl:tmp.sibling := pos] M.add (! l_tmp) (! l_pos) l_s.heap.sibling));
                                                 (r_s.heap.sibling <-
                                                    ([@expl:tmp.sibling := pos] M.add (! r_tmp) (! r_pos) r_s.heap.sibling)))))))
                                  else ((();
                                         ())))));
                               (((l_s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! l_handle) null l_s.heap.sibling));
                                 (r_s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! r_handle) (! r_sntl) r_s.heap.sibling))));
                               (((l_pos := ([@expl:pos := self.head] l_s.heap.head[! l_self]));
                                 (r_pos := ([@expl:pos := self.head] r_s.heap.head[! r_self]))));
                               (assume {
                                  ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueL.pqueueI l_s)) /\
                                    ((PqueueR.PQUEUE.pqueuePub r_s) /\ (PqueueR.pqueueI r_s)) });
                               (match link l_s r_s pi (! l_self) (! l_pos) (! l_handle) (! r_self) (! r_pos) (! r_handle)
                                with
                                  | (l_link_res, r_link_res) ->
                                      (((l_tmp := ([@expl:tmp := link(self,pos,handle)] l_link_res));
                                        (r_tmp := ([@expl:tmp := link(self,pos,handle)] r_link_res))))
                                end);
                               (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                               (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head))))
                        else ((();
                               ())))));
                     (assume {
                        ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueL.pqueueI l_s)) /\
                          ((PqueueR.PQUEUE.pqueuePub r_s) /\ (PqueueR.pqueueI r_s)) });
                     (! l_result, ! r_result))))))))))))))))
end

module CLIENT
  
  use prelude.Prelude
  use State
end

module Client
  use prelude.Prelude
  use State
  use CLIENT
  use PQUEUE
  use export graph_theory.Graph_theory
  
  val initDistances (s: state) (d: reference) (k: int) : unit
    requires { hasDistArrayType s d }
    requires { d <> null }
    requires { k >= 0 }
    writes { s.heap.dSlots }
    ensures { result = () }
    ensures { [@expl:wr {d}`dSlots] wrs_to_dSlots_framed_by (old s) s (singleton d) }
    ensures { let len = s.heap.dLength[d] in
              forall i: int. (0 <= i) -> ((i < len) -> ((A.get (s.heap.dSlots[d]) i) = k)) }
  
  let dijkstra (s: state) (g: graph) (source: int) : reference diverges
    requires { s.pool = emptyRgn }
    requires { PQUEUE.pqueuePub s }
    requires { hasVertex g source }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.child }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.sntl }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr (pool`rep union pool)`slots] wrs_to_slots_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool union {})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) emptyRgn) }
    ensures { [@expl:wr (pool`rep union pool union {})`sntl]
              wrs_to_sntl_framed_by (old s) s (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) emptyRgn) }
    ensures { [@expl:wr (pool`rep union pool)`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool union {})`head]
              wrs_to_head_framed_by (old s) s (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) emptyRgn) }
    ensures { [@expl:wr (pool`rep union pool)`child] wrs_to_child_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool union pool union {})`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) s.pool) emptyRgn) }
    ensures { [@expl:wr (pool`rep union pool)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool union {})`size]
              wrs_to_size_framed_by (old s) s (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) emptyRgn) }
    ensures { [@expl:wr (pool`rep union pool)`length] wrs_to_length_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool)`key] wrs_to_key_framed_by (old s) s (Rgn.union (img_rep s s.pool) s.pool) }
    ensures { [@expl:wr (pool`rep union pool union {})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) emptyRgn) } =
    label INIT in
      let result = ref null in
      (let g = ref g in
       (let source = ref source in
        (let queue = ref null in
         (((assert { hasPqueueType s (! queue) });
           (let numVs = ref 0 in
            (((numVs := ([@expl:numVs := numVertices(g)] numVertices (! g)));
              (queue := ([@expl:queue := new Pqueue] mk_Pqueue s));
              ([@expl:Pqueue(queue)] PQUEUE.init_Pqueue s (! queue));
              (let dist = ref null in
               (((assert { hasDistArrayType s (! dist) });
                 (((dist := ([@expl:dist := new(DistArray){numVs}] mk_DistArray s));
                   (s.heap.dLength <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (! numVs) s.heap.dLength));
                   (s.heap.dSlots <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (A.make (! numVs) 0) s.heap.dSlots))));
                 ([@expl:initDistances(dist,maxWeight)] initDistances s (! dist) maxWeight);
                 (let initDist = ref 0 in
                  (((initDist := ([@expl:initDist := 0] 0));
                    (let ins = ref null in
                     (((assert { hasNodeType s (! ins) });
                       (ins := ([@expl:ins := insert(queue,initDist,source)] PQUEUE.insert s (! queue) (! initDist) (! source)));
                       (let isEmp = ref false in
                        (((isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                          (let min = ref null in
                           (((assert { hasNodeType s (! min) });
                             (let minTag = ref 0 in
                              (let minKey = ref 0 in
                               (((min := ([@expl:min := ins] ! ins));
                                 (while not (! isEmp) do
                                    invariant {
                                      [@expl:locals type invariant]
                                      (hasPqueueType s (! queue)) /\
                                        ((hasNodeType s (! min)) /\
                                           ((hasNodeType s (! ins)) /\
                                              ((hasDistArrayType s (! dist)) /\ (hasDistArrayType s (! result))))) }
                                    invariant { alloc_does_not_shrink (old s) s }
                                    invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                                    invariant { (! numVs) = (numVertices (! g)) }
                                    invariant { (s.heap.dLength[! dist]) = (! numVs) }
                                    invariant { (singleton (! dist)) \# (Rgn.union s.pool (img_rep s s.pool)) }
                                    invariant { let rep1 = s.heap.rep[! queue] in
                                                Rgn.mem (! min) rep1 }
                                    invariant {
                                      let rep2 = s.heap.rep[! queue] in
                                      forall n: reference.
                                        (isAllocated s n) ->
                                          ((hasNodeType s n) ->
                                             ((Rgn.mem n rep2) ->
                                                (let len = s.heap.dLength[! dist] in
                                                 let tag3 = s.heap.tag[n] in
                                                 (tag3 >= 0) /\ (tag3 < len)))) }
                                    invariant { PQUEUE.pqueuePub s }
                                    ((min := ([@expl:min := deleteMin(queue)] PQUEUE.deleteMin s (! queue)));
                                     (minTag := ([@expl:minTag := getTag(min)] PQUEUE.getTag s (! min)));
                                     (minKey := ([@expl:minKey := getKey(min)] PQUEUE.getKey s (! min)));
                                     (assert { ((! minTag) >= 0) /\ (let len = s.heap.dLength[! dist] in
                                                                    (! minTag) < len) });
                                     (let i = ref 0 in
                                      (((assert { (Rgn.union (img_rep s s.pool) s.pool) \# (singleton (! dist)) });
                                        (i := ([@expl:i := dist.{minTag}] A.get (s.heap.dSlots[! dist]) (! minTag)));
                                        (if ((! minKey) < (! i))
                                         then (((assert { (Rgn.union (img_rep s s.pool) s.pool) \# (singleton (! dist)) });
                                                (s.heap.dSlots <-
                                                   ([@expl:dist.{minTag} := minKey]
                                                    M.add (! dist) (A.set (s.heap.dSlots[! dist]) (! minTag) (! minKey)) s.heap.dSlots));
                                                (let eLen = ref 0 in
                                                 (let gEdges = ref (A.make 0 (any edge)) in
                                                  (((isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                                                    (gEdges := ([@expl:gEdges := edges(g)] edges (! g)));
                                                    (eLen := ([@expl:eLen := length(gEdges)] A.length (! gEdges)));
                                                    (let i4 = ref 0 in
                                                     (while (0 <= (! i4))  && ((! i4) < (! eLen)) do
                                                        invariant {
                                                          [@expl:locals type invariant]
                                                          (hasPqueueType s (! queue)) /\
                                                            ((hasNodeType s (! min)) /\
                                                               ((hasNodeType s (! ins)) /\
                                                                  ((hasDistArrayType s (! dist)) /\ (hasDistArrayType s (! result))))) }
                                                        invariant { alloc_does_not_shrink (old s) s }
                                                        invariant { 0 <= (! i4) }
                                                        invariant { (! i4) <= (! eLen) }
                                                        invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                                                        invariant { (! numVs) = (numVertices (! g)) }
                                                        invariant { (s.heap.dLength[! dist]) = (! numVs) }
                                                        invariant { let rep5 = s.heap.rep[! queue] in
                                                                    Rgn.mem (! min) rep5 }
                                                        invariant {
                                                          let rep6 = s.heap.rep[! queue] in
                                                          forall n: reference.
                                                            (isAllocated s n) ->
                                                              ((hasNodeType s n) ->
                                                                 ((Rgn.mem n rep6) ->
                                                                    (
                                                                    let len = s.heap.dLength[! dist] in
                                                                    let tag7 = s.heap.tag[n] in
                                                                    (tag7 >= 0) /\ (tag7 < len)))) }
                                                        invariant { (singleton (! dist)) \# (Rgn.union s.pool (img_rep s s.pool)) }
                                                        invariant { PQUEUE.pqueuePub s }
                                                        let startV = ref 0 in
                                                        (let endV = ref 0 in
                                                         (let currWeight = ref 0 in
                                                          (let currEdge = ref (any edge) in
                                                           (((currEdge := ([@expl:currEdge := get(gEdges,i)] A.get (! gEdges) (! i4)));
                                                             (startV
                                                                := ([@expl:startV := startVertex(currEdge)] startVertex (! currEdge)));
                                                             (endV := ([@expl:endV := endVertex(currEdge)] endVertex (! currEdge)));
                                                             (currWeight
                                                                := ([@expl:currWeight := weight(currEdge)] weight (! currEdge)));
                                                             (let d = ref 0 in
                                                              (let candidateDist = ref 0 in
                                                               (((assert {
                                                                    (Rgn.union (img_rep s s.pool) s.pool) \# (singleton (! dist)) });
                                                                 (d
                                                                    := (
                                                                    [@expl:d := dist.{startV}] 
                                                                    A.get (s.heap.dSlots[! dist]) (! startV)));
                                                                 (candidateDist
                                                                    := (
                                                                    [@expl:candidateDist := d + currWeight] (! d) + (! currWeight)));
                                                                 (assert {
                                                                    (Rgn.union (img_rep s s.pool) s.pool) \# (singleton (! dist)) });
                                                                 (d
                                                                    := (
                                                                    [@expl:d := dist.{endV}] A.get (s.heap.dSlots[! dist]) (! endV)));
                                                                 (if ((! candidateDist) < (! d))
                                                                  then (
                                                                    ((
                                                                    assert {
                                                                    (Rgn.union (img_rep s s.pool) s.pool) \# (singleton (! dist)) });
                                                                    (s.heap.dSlots <-
                                                                    ([@expl:dist.{endV} := candidateDist]
                                                                    M.add
                                                                    (! dist)
                                                                    (A.set (s.heap.dSlots[! dist]) (! endV) (! candidateDist))
                                                                    s.heap.dSlots))))
                                                                  else ());
                                                                 (i4 := ([@expl:i := i + 1] (! i4) + 1));
                                                                 (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue))))))))))))
                                                      done))))))))
                                         else ());
                                        (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)))))))
                                  done);
                                 (result := ([@expl:result := dist] ! dist));
                                 (! result))))))))))))))))))))))))))))
end

