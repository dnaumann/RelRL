module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  use graph_theory.Graph_theory
  
  type reftype = 
    | DistArray
    | Node
    | NodeArray
    | Pqueue
  
  type heap = {
    mutable ghost rep : M.t rgn ;
    mutable size : M.t int ;
    mutable head : M.t reference ;
    mutable sntl : M.t reference ;
    mutable slots : M.t (A.array reference) ;
    mutable length : M.t int ;
    mutable prev : M.t reference ;
    mutable sibling : M.t reference ;
    mutable child : M.t reference ;
    mutable key : M.t int ;
    mutable tag : M.t int ;
    mutable dLength : M.t int ;
    mutable dSlots : M.t (A.array int)
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = DistArray) ->
           (((p \: heap.dLength) /\ (p \: heap.dSlots)) /\
              (((heap.dLength[p]) >= 0) /\ ((heap.dLength[p]) = (A.length (heap.dSlots[p])))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.prev) /\ ((p \: heap.sibling) /\ ((p \: heap.child) /\ ((p \: heap.key) /\ (p \: heap.tag))))) /\
              ((((heap.prev[p]) = null) \/ (((heap.prev[p]) \: alloct) /\ ((alloct[heap.prev[p]]) = Node))) /\
                 ((((heap.sibling[p]) = null) \/ (((heap.sibling[p]) \: alloct) /\ ((alloct[heap.sibling[p]]) = Node))) /\
                    (((heap.child[p]) = null) \/ (((heap.child[p]) \: alloct) /\ ((alloct[heap.child[p]]) = Node))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = NodeArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\
              (((heap.length[p]) >= 0) /\
                 (((heap.length[p]) = (A.length (heap.slots[p]))) /\
                    (let arr = heap.slots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr)) -> (let v = A.get arr i in
                                                   (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Node))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Pqueue) ->
           (((p \: heap.rep) /\ ((p \: heap.size) /\ ((p \: heap.head) /\ (p \: heap.sntl)))) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 ((((heap.sntl[p]) = null) \/ (((heap.sntl[p]) \: alloct) /\ ((alloct[heap.sntl[p]]) = Node))) /\
                    (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct))))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasDistArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = DistArray))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasNodeArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = NodeArray))
  
  predicate hasPqueueType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Pqueue))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_DistArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result DistArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { s.heap.dLength = (M.add result 0 (old s.heap.dLength)) }
    ensures { s.heap.dSlots = (M.add result (A.make 0 0) (old s.heap.dSlots)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.child }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.prev = (M.add result null (old s.heap.prev)) }
    ensures { s.heap.sibling = (M.add result null (old s.heap.sibling)) }
    ensures { s.heap.child = (M.add result null (old s.heap.child)) }
    ensures { s.heap.key = (M.add result 0 (old s.heap.key)) }
    ensures { s.heap.tag = (M.add result 0 (old s.heap.tag)) }
  
  val mk_NodeArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result NodeArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 null) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_Pqueue (s: state) : reference
    writes { s.alloct }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.head }
    writes { s.heap.sntl }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Pqueue (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasPqueueType s result }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.size = (M.add result 0 (old s.heap.size)) }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
    ensures { s.heap.sntl = (M.add result null (old s.heap.sntl)) }
  
  function img_tag : state -> (rgn -> rgn)
  
  axiom img_tag_ax : forall s: state, r: rgn. (img_tag s r) = emptyRgn
  
  function img_sntl : state -> (rgn -> rgn)
  
  axiom img_sntl_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_sntl s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.sntl[q])))))
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn. (img_slots s r) = emptyRgn
  
  function img_size : state -> (rgn -> rgn)
  
  axiom img_size_ax : forall s: state, r: rgn. (img_size s r) = emptyRgn
  
  function img_sibling : state -> (rgn -> rgn)
  
  axiom img_sibling_ax : forall s: state, r: rgn, p: reference.
                           (Rgn.mem p (img_sibling s r)) <->
                             (exists q: reference.
                                (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.sibling[q])))))
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_prev : state -> (rgn -> rgn)
  
  axiom img_prev_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_prev s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.prev[q])))))
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_key : state -> (rgn -> rgn)
  
  axiom img_key_ax : forall s: state, r: rgn. (img_key s r) = emptyRgn
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  function img_dSlots : state -> (rgn -> rgn)
  
  axiom img_dSlots_ax : forall s: state, r: rgn. (img_dSlots s r) = emptyRgn
  
  function img_dLength : state -> (rgn -> rgn)
  
  axiom img_dLength_ax : forall s: state, r: rgn. (img_dLength s r) = emptyRgn
  
  function img_child : state -> (rgn -> rgn)
  
  axiom img_child_ax : forall s: state, r: rgn, p: reference.
                         (Rgn.mem p (img_child s r)) <->
                           (exists q: reference.
                              (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.child[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. (p \: pre.alloct) -> ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_dLength_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = DistArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.dLength[p]) = (post.heap.dLength[p]))))
  
  predicate wrs_to_dSlots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = DistArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.dSlots[p]) = (post.heap.dSlots[p]))))
  
  predicate wrs_to_prev_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.prev[p]) = (post.heap.prev[p]))))
  
  predicate wrs_to_sibling_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.sibling[p]) = (post.heap.sibling[p]))))
  
  predicate wrs_to_child_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.child[p]) = (post.heap.child[p]))))
  
  predicate wrs_to_key_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.key[p]) = (post.heap.key[p]))))
  
  predicate wrs_to_tag_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.tag[p]) = (post.heap.tag[p]))))
  
  predicate wrs_to_slots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = NodeArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.slots[p]) = (post.heap.slots[p]))))
  
  predicate wrs_to_length_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = NodeArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.length[p]) = (post.heap.length[p]))))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_size_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.size[p]) = (post.heap.size[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate wrs_to_sntl_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Pqueue) -> ((not (Rgn.mem p r)) -> ((pre.heap.sntl[p]) = (post.heap.sntl[p]))))
  
  predicate agree_tag (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.tag[o]) = (sr.heap.tag[pi.lor[o]]))))))
  
  predicate agree_sntl (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sntl[o]) (sr.heap.sntl[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_size (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.size[o]) = (sr.heap.size[pi.lor[o]]))))))
  
  predicate agree_sibling (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sibling[o]) (sr.heap.sibling[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_prev (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.prev[o]) (sr.heap.prev[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_key (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.key[o]) = (sr.heap.key[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_dSlots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dSlots[o]) = (sr.heap.dSlots[pi.lor[o]]))))))
  
  predicate agree_dLength (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dLength[o]) = (sr.heap.dLength[pi.lor[o]]))))))
  
  predicate agree_child (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.child[o]) (sr.heap.child[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_dLength sl sr pi w) /\
      ((agree_dSlots sl sr pi w) /\
         ((agree_prev sl sr pi w) /\
            ((agree_sibling sl sr pi w) /\
               ((agree_child sl sr pi w) /\
                  ((agree_key sl sr pi w) /\
                     ((agree_tag sl sr pi w) /\
                        ((agree_slots sl sr pi w) /\
                           ((agree_length sl sr pi w) /\
                              ((agree_rep sl sr pi w) /\
                                 ((agree_size sl sr pi w) /\ ((agree_head sl sr pi w) /\ (agree_sntl sl sr pi w))))))))))))
end

module CLIENT
  
  use prelude.Prelude
  use State
end

module MAIN
  use prelude.Prelude
  use State
end

module PQUEUE
  use prelude.Prelude
  use State
  
  predicate pqueuePub (s: state) =
    (typeofRgn s s.pool (L.Cons Node (L.Cons Pqueue L.Nil))) /\
      ((typeofRgn s (img_rep s s.pool) (L.Cons Node L.Nil)) /\
         (forall p: reference, q: reference.
            (isAllocated s p) ->
              ((hasPqueueType s p) ->
                 ((Rgn.mem p s.pool) ->
                    ((isAllocated s q) ->
                       ((hasPqueueType s q) ->
                          ((Rgn.mem q s.pool) -> (let prep = s.heap.rep[p] in
                                                  let qrep = s.heap.rep[q] in
                                                  (p <> q) -> (prep \# qrep)))))))))
  
  lemma noPqueueInRep : forall s: state.
                          (pqueuePub s) ->
                            (forall p: reference, q: reference.
                               (isAllocated s p) ->
                                 ((hasPqueueType s p) ->
                                    ((Rgn.mem p s.pool) ->
                                       ((isAllocated s q) ->
                                          ((hasPqueueType s q) ->
                                             ((Rgn.mem q s.pool) -> (let prep = s.heap.rep[p] in
                                                                    (p <> q) -> (not (Rgn.mem q prep)))))))))
  
  val getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { pqueuePub s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.tag[self]) = result }
    ensures { pqueuePub s }
  
  val getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { pqueuePub s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[self]) = result }
    ensures { pqueuePub s }
  
  val init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { not (Rgn.mem self s.pool) }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { Rgn.mem self s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (Rgn.union s.pool (s.heap.rep[self])) }
    ensures { pqueuePub s }
  
  val isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { pqueuePub s }
  
  val findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { pqueuePub s }
  
  val insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`tag] wrs_to_tag_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`key] wrs_to_key_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { let oa = old s.alloct.M.domain in
              (Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self])) /\ (Rgn.mem result (Rgn.diff s.alloct.M.domain oa)) }
    ensures { pqueuePub s }
  
  val deleteMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { pqueuePub s }
  
  val decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s }
    writes { s.heap.slots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.rep }
    writes { s.heap.tag }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.dLength }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[handle]) = k }
    ensures { pqueuePub s }
end

module PqueueL
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repClosed (s: state) (rep1: rgn) =
    (typeofRgn s rep1 (L.Cons Node L.Nil)) /\
      ((Rgn.mem null rep1) /\
         ((Rgn.subset (img_sibling s rep1) rep1) /\ ((Rgn.subset (img_child s rep1) rep1) /\ (Rgn.subset (img_prev s rep1) rep1))))
  
  lemma repClosed_DEF : forall s: state.
                          forall r: rgn.
                            (repClosed s r) <->
                              ((typeofRgn s r (L.Cons Node L.Nil)) /\
                                 ((Rgn.mem null r) /\
                                    (forall n: reference.
                                       (isAllocated s n) ->
                                         ((hasNodeType s n) ->
                                            ((Rgn.mem n r) ->
                                               (let sib = s.heap.sibling[n] in
                                                let pre = s.heap.prev[n] in
                                                let chl = s.heap.child[n] in
                                                (Rgn.mem sib r) /\ ((Rgn.mem pre r) /\ (Rgn.mem chl r))))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = (singleton null))))))))
  
  predicate pqueueI (s: state) =
    forall p: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p s.pool) ->
              (let rep1 = s.heap.rep[p] in
               let sz = s.heap.size[p] in
               let hd = s.heap.head[p] in
               (repClosed s rep1) /\ ((sz >= 0) /\ ((Rgn.mem hd rep1) /\ (((sz = 0) <-> (hd = null)) /\ (nodeP s rep1)))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p s.pool) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q s.pool) ->
                                               ((PQUEUE.pqueuePub s) ->
                                                  ((p <> q) ->
                                                     (let prep = s.heap.rep[p] in
                                                      let qrep = s.heap.rep[q] in
                                                      forall n: reference.
                                                        (isAllocated s n) ->
                                                          ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { [@expl:wr {self}`key] wrs_to_key_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`tag] wrs_to_tag_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
           (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
           (! result))))))
  
  let getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.tag[self]) = result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.tag] s.heap.tag[! self]));
         (! result))))
  
  let getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[self]) = result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.key] s.heap.key[! self]));
         (! result))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { not (Rgn.mem self s.pool) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.pool }
    writes { s.heap.rep }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`key] wrs_to_key_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { Rgn.mem self s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (Rgn.union s.pool (s.heap.rep[self])) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (((s.heap.rep <- ([@expl:self.rep := {null}] M.add (! self) (singleton null) s.heap.rep));
         (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
         (! result))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert { not ((s.heap.head[! self]) = null) });
         (assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.head] s.heap.head[! self]));
         (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let first = ref first in
        (let second = ref second in
         (let fkey = ref 0 in
          (let skey = ref 0 in
           (let tmp = ref null in
            (((assert { hasNodeType s (! tmp) });
              (let ghost rep3 = ref emptyRgn in
               (((assert { isValidRgn s (! rep3) });
                 (assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                 (assert {
                    ((Rgn.mem (! first) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                      true });
                 (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
                 (assert {
                    ((Rgn.mem (! second) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                      true });
                 (skey := ([@expl:skey := second.key] s.heap.key[! second]));
                 (if ((! skey) < (! fkey))
                  then (((assert {
                            ((Rgn.mem (! first) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                               ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                              true });
                         (tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                         (assert { Rgn.mem (! tmp) (! rep3) });
                         (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                         (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                         (assert { let p = s.heap.prev[! first] in
                                   Rgn.mem p (! rep3) });
                         (assert {
                            ((Rgn.mem (! second) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                               ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                              true });
                         (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                         (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((assert {
                                    ((Rgn.mem (! first) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                       ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                      true });
                                 (tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                 (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (assert { let p = s.heap.prev[! tmp] in
                                           Rgn.mem p (! rep3) });
                                 (assert { repClosed s (! rep3) })))
                          else ());
                         (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                         (result := ([@expl:result := second] ! second));
                         (assert { repClosed s (! rep3) })))
                  else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                         (assert {
                            ((Rgn.mem (! second) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                               ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                              true });
                         (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                         (assert { Rgn.mem (! tmp) (! rep3) });
                         (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((assert {
                                    ((Rgn.mem (! first) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                       ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                      true });
                                 (tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                          else ());
                         (assert {
                            ((Rgn.mem (! first) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                               ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                              true });
                         (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                         (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                         (if ((! tmp) <>. null)
                          then (((assert {
                                    ((Rgn.mem (! second) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                       ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                                      true });
                                 (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                                 (assert { Rgn.mem (! tmp) (! rep3) });
                                 (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                          else ());
                         (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                         (result := ([@expl:result := first] ! first));
                         (assert { repClosed s (! rep3) }))));
                 (! result))))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  lemma img_rep_lem : forall s: state.
                        forall self1: reference.
                          (isAllocated s self1) -> ((hasPqueueType s self1) -> ((s.heap.rep[self1]) = (s.heap.rep[self1])))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({} union {self}`rep)`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`child] wrs_to_child_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { let oa = old s.alloct.M.domain in
              (Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self])) /\ (Rgn.mem result (Rgn.diff s.alloct.M.domain oa)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((assert { PQUEUE.pqueuePub s });
           (result := ([@expl:result := new Node] mk_Node s));
           (assert { pqueueI s });
           (assert { (! result) <> null });
           (assert {
              ((Rgn.mem (! result) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                 ((not (Rgn.mem (! result) (s.alloct.M.domain at INIT))) \/ ((! result) = null))) /\
                true });
           ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
           (assert { PQUEUE.pqueuePub s });
           (assert {
              forall p: reference.
                (isAllocated s p) ->
                  ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep3 = s.heap.rep[p] in
                                                                  not (Rgn.mem (! result) rep3)))) });
           (assert { pqueueI s });
           (let ghost rep4 = ref emptyRgn in
            (((assert { isValidRgn s (! rep4) });
              (assert {
                 ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                    ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                   true });
              (rep4 := ([@expl:rep := self.rep] s.heap.rep[! self]));
              (s.heap.rep <-
                 ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep4) (singleton (! result))) s.heap.rep));
              (assert {
                 forall p: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let prep = s.heap.rep[p] in
                                                                    not (Rgn.mem (! result) prep))))) });
              (assert {
                 forall p: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) ->
                           ((p <> (! self)) -> (let prep = s.heap.rep[p] in
                                                let srep = s.heap.rep[! self] in
                                                srep \# prep)))) });
              (assert {
                 forall p: reference, q: reference.
                   (isAllocated s p) ->
                     ((hasPqueueType s p) ->
                        ((Rgn.mem p s.pool) ->
                           ((isAllocated s q) ->
                              ((hasPqueueType s q) ->
                                 ((Rgn.mem q s.pool) ->
                                    ((p <> q) ->
                                       ((p <> (! self)) ->
                                          ((q <> (! self)) -> (let prep = s.heap.rep[p] in
                                                               let qrep = s.heap.rep[q] in
                                                               prep \# qrep))))))))) });
              (assert { PQUEUE.pqueuePub s });
              (assert { let rep5 = s.heap.rep[! self] in
                        repClosed s rep5 });
              (assert { pqueueI s });
              (let hd = ref null in
               (((assert { hasNodeType s (! hd) });
                 (assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (hd := ([@expl:hd := self.head] s.heap.head[! self]));
                 (if ((! hd) =. null)
                  then (((assert { let rep6 = s.heap.rep[! self] in
                                   repClosed s rep6 });
                         (s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                         (assert { (s.heap.head[! self]) = (! result) });
                         (assert { let hd7 = s.heap.head[! self] in
                                   let rep8 = s.heap.rep[! self] in
                                   Rgn.mem hd7 rep8 });
                         (assert {
                            let hd9 = s.heap.head[! self] in
                            ((s.heap.sibling[hd9]) = null) /\ (((s.heap.prev[hd9]) = null) /\ ((s.heap.child[hd9]) = null)) })))
                  else (let tmp = ref null in
                        (((assert { hasNodeType s (! tmp) });
                          (assert {
                             (Rgn.subset
                                 (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                 (Rgn.union
                                     ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                     (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                               true });
                          (tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                          (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                          (assert { let hd10 = s.heap.head[! self] in
                                    let rep11 = s.heap.rep[! self] in
                                    Rgn.mem hd10 rep11 })))));
                 (let sz = ref 0 in
                  (((assert {
                       ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                          ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                         true });
                    (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                    (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                    (! result)))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { not ((s.heap.sibling[handle]) = null) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let trees = ref null in
         (((assert { hasNodeArrayType s (! trees) });
           (let index = ref 0 in
            (let current = ref null in
             (((assert { hasNodeType s (! current) });
               (let tmp = ref null in
                (((assert { hasNodeType s (! tmp) });
                  (let fst = ref null in
                   (((assert { hasNodeType s (! fst) });
                     (let snd = ref null in
                      (((assert { hasNodeType s (! snd) });
                        (let i = ref 0 in
                         (let j = ref 0 in
                          (((((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                              (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                              (s.heap.slots <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                            (s.heap.slots <-
                               ([@expl:trees.{0} := handle] M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                            (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                            (assert {
                               forall p: reference.
                                 (isAllocated s p) ->
                                   ((hasNodeArrayType s p) ->
                                      ((p <> (! trees)) -> (let s3 = old (s.heap.slots[p]) in
                                                            (s.heap.slots[p]) = s3))) });
                            (index := ([@expl:index := 1] 1));
                            (assert {
                               ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                  ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                 true });
                            (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                            (while (! current) <>. null do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! current)) /\
                                   ((hasNodeType s (! fst)) /\
                                      ((hasNodeType s (! handle)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! snd)) /\ ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                               invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { pqueueI s }
                               invariant { PQUEUE.pqueuePub s }
                               invariant { let rep4 = s.heap.rep[! self] in
                                           repClosed s rep4 }
                               invariant { let rep5 = s.heap.rep[! self] in
                                           Rgn.mem (! current) rep5 }
                               invariant {
                                 forall k6: int.
                                   (0 <= k6) ->
                                     ((k6 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k6 in
                                         let rep7 = s.heap.rep[! self] in
                                         Rgn.mem n rep7)) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k8: int. ((! index) <= k8) -> ((k8 < l) -> ((A.get (s.heap.slots[! trees]) k8) = null)) }
                               invariant {
                                 forall k9: int. (0 <= k9) -> ((k9 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k9) = null))) }
                               invariant { (1 <= (! index)) /\ (let l = s.heap.length[! trees] in
                                                                (! index) < l) }
                               ((assume { let l = s.heap.length[! trees] in
                                          (! index) < (l - 1) });
                                (s.heap.slots <-
                                   ([@expl:trees.{index} := current]
                                    M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                                (assert {
                                   ((Rgn.mem (! current) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! current) (s.alloct.M.domain at INIT))) \/ ((! current) = null))) /\
                                     true });
                                (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                                (if ((! tmp) <>. null)
                                 then (s.heap.sibling <- ([@expl:tmp.sibling := null] M.add (! tmp) null s.heap.sibling)) 
                                 else ());
                                (assert {
                                   ((Rgn.mem (! current) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! current) (s.alloct.M.domain at INIT))) \/ ((! current) = null))) /\
                                     true });
                                (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                                (index := ([@expl:index := index + 1] (! index) + 1)))
                             done);
                            (s.heap.slots <-
                               ([@expl:trees.{index} := null]
                                M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) null) s.heap.slots));
                            (assert { let l = s.heap.length[! trees] in
                                      (! index) < l });
                            (i := ([@expl:i := 0] 0));
                            (tmp := ([@expl:tmp := null] null));
                            (while ((! i) + 1) < (! index) do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! current)) /\
                                   ((hasNodeType s (! fst)) /\
                                      ((hasNodeType s (! handle)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! snd)) /\ ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                               invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { let rep10 = s.heap.rep[! self] in
                                           Rgn.mem (! tmp) rep10 }
                               invariant { (0 <= (! i)) /\ ((! i) <= (! index)) }
                               invariant { pqueueI s }
                               invariant { PQUEUE.pqueuePub s }
                               invariant {
                                 forall k11: int.
                                   (0 <= k11) ->
                                     ((k11 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k11 in
                                         let rep12 = s.heap.rep[! self] in
                                         Rgn.mem n rep12)) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k13: int. ((! index) <= k13) -> ((k13 < l) -> ((A.get (s.heap.slots[! trees]) k13) = null)) }
                               invariant {
                                 forall k14: int.
                                   (0 <= k14) -> ((k14 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k14) = null))) }
                               ((assert {
                                   ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                     true });
                                (fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                                (assert {
                                   ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                     true });
                                (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                                (assert {
                                   (Rgn.subset
                                       (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                       (Rgn.union
                                           ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                           (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                     true });
                                (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                (s.heap.slots <-
                                   ([@expl:trees.{i} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                                (i := ([@expl:i := i + 2] (! i) + 2)))
                             done);
                            (j := ([@expl:j := i - 2] (! i) - 2));
                            (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                             then (((assert { ((! j) + 2) < (! index) });
                                    (assert {
                                       ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                          ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                         true });
                                    (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                    (assert {
                                       ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                          ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                         true });
                                    (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                                    (assert {
                                       (Rgn.subset
                                           (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                           (Rgn.union
                                               ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                               (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                         true });
                                    (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                    (s.heap.slots <-
                                       ([@expl:trees.{j} := tmp]
                                        M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                             else ());
                            (while 2 <= (! j) do
                               invariant {
                                 [@expl:locals type invariant]
                                 (hasNodeType s (! current)) /\
                                   ((hasNodeType s (! fst)) /\
                                      ((hasNodeType s (! handle)) /\
                                         ((hasNodeType s (! result)) /\
                                            ((hasPqueueType s (! self)) /\
                                               ((hasNodeType s (! snd)) /\ ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees)))))))) }
                               invariant { alloc_does_not_shrink (old s) s }
                               invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                               invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                               invariant { pqueueI s }
                               invariant { PQUEUE.pqueuePub s }
                               invariant { ((0 - 2) <= (! j)) /\ ((! j) < (! index)) }
                               invariant {
                                 forall k15: int.
                                   (0 <= k15) ->
                                     ((k15 < (! index)) ->
                                        (let n = A.get (s.heap.slots[! trees]) k15 in
                                         let rep16 = s.heap.rep[! self] in
                                         Rgn.mem n rep16)) }
                               invariant {
                                 let l = s.heap.length[! trees] in
                                 forall k17: int. ((! index) <= k17) -> ((k17 < l) -> ((A.get (s.heap.slots[! trees]) k17) = null)) }
                               invariant {
                                 forall k18: int.
                                   (0 <= k18) -> ((k18 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k18) = null))) }
                               ((assert {
                                   ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                     true });
                                (fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                                (assert {
                                   ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                     true });
                                (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                (assert {
                                   (Rgn.subset
                                       (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                       (Rgn.union
                                           ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                           (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                     true });
                                (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                (s.heap.slots <-
                                   ([@expl:trees.{j - 2} := tmp]
                                    M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                                (j := ([@expl:j := j - 2] (! j) - 2)))
                             done);
                            (assert {
                               ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                  ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                 true });
                            (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                            (! result)))))))))))))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { pqueueI s }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let tmp = ref null in
         (((assert { hasNodeType s (! tmp) });
           (assert {
              ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                 ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                true });
           (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
           (if ((! tmp) =. null) then (result := ([@expl:result := handle] ! handle))
            else (((assert {
                      (Rgn.subset
                          (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                          (Rgn.union
                              ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                              (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                        true });
                   (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))))));
           (! result))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := findMin(self)] findMin s (! self)));
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (assert {
               ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                  ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                 true });
            (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
            (assert {
               ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                  ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                 true });
            (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
            (if ((! tmp) =. null)
             then (((assume { (s.heap.size[! self]) = 1 });
                    (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head))))
             else (((assume { let sz = s.heap.size[! self] in
                              sz > 1 });
                    (assert {
                       (Rgn.subset
                           (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                           (Rgn.union
                               ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                               (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                         true });
                    (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                    (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
            (let sz = ref 0 in
             (((assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (sz := ([@expl:sz := self.size] s.heap.size[! self]));
               (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
               (! result))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r27 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r27 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[handle]) = k }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let handle = ref handle in
        (let k = ref k in
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let pos = ref null in
             (((assert { hasNodeType s (! pos) });
               (assert { let key3 = s.heap.key[! handle] in
                         key3 >= 0 });
               (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
               (if ((! handle) <>. (! tmp))
                then (((assert {
                          ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                             ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                            true });
                       (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                       (if ((! tmp) <>. null)
                        then (((assert {
                                  ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                    true });
                               (pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                               (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev))))
                        else ());
                       (assert {
                          ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                             ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                            true });
                       (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                       (assert { let rep4 = s.heap.rep[! self] in
                                 Rgn.mem (! tmp) rep4 });
                       (if ((! tmp) <>. null)
                        then (((assert {
                                  ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                                    true });
                               (pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                               (if ((! pos) =. (! handle))
                                then (((assert {
                                          ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                             ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                            true });
                                       (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                       (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                                else (((assert {
                                          ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                             ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                            true });
                                       (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                       (assert { let rep5 = s.heap.rep[! self] in
                                                 (Rgn.mem (! pos) rep5) /\ (Rgn.mem (! tmp) rep5) });
                                       (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                       (assert { let rep6 = s.heap.rep[! self] in
                                                 let sib = s.heap.sibling[! tmp] in
                                                 Rgn.mem sib rep6 }))));
                               (assert {
                                  forall p: reference.
                                    (isAllocated s p) ->
                                      ((hasNodeType s p) ->
                                         (let rep7 = s.heap.rep[! self] in
                                          (not (Rgn.mem p rep7)) -> (let sib = old (s.heap.sibling[p]) in
                                                                    (s.heap.sibling[p]) = sib))) })))
                        else ());
                       (s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! handle) null s.heap.sibling));
                       (assert {
                          ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                             ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                            true });
                       (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                       (assert { (! pos) <> null });
                       (assert {
                          (Rgn.subset
                              (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                              (Rgn.union
                                  ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                  (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                            true });
                       (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                       (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
                else ());
               (! result))))))))))
  
  lemma boundary_frames_invariant_PqueueL : forall s: state, t8: state, pi: 
                                              PreRefperm.t.
                                              (okRefperm s t8 pi) ->
                                                ((PreRefperm.identity pi s.alloct.M.domain t8.alloct.M.domain) ->
                                                   ((PreRefperm.idRgn pi s.pool t8.pool) ->
                                                      ((agree_allfields s t8 pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                         ((pqueueI s) -> (pqueueI t8)))))
end

module PqueueR
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repOk (s: state) (pq: reference) =
    (hasPqueueType s pq) ->
      ((pq <> null) ->
         (let sntl1 = s.heap.sntl[pq] in
          let rep2 = s.heap.rep[pq] in
          (typeofRgn s rep2 (L.Cons Node L.Nil)) /\
            ((not (Rgn.mem sntl1 rep2)) /\
               ((not (Rgn.mem null rep2)) /\
                  (forall n: reference.
                     (isAllocated s n) ->
                       ((hasNodeType s n) ->
                          ((Rgn.mem n rep2) ->
                             (let chl = s.heap.child[n] in
                              let sib = s.heap.sibling[n] in
                              let pre = s.heap.prev[n] in
                              ((Rgn.mem chl rep2) \/ (chl = sntl1)) /\
                                (((Rgn.mem sib rep2) \/ (sib = sntl1)) /\ ((Rgn.mem pre rep2) \/ (pre = sntl1)))))))))))
  
  lemma repOk_EMPTY : forall s: state.
                        forall p: reference.
                          (isAllocated s p) -> ((hasPqueueType s p) -> (((s.heap.rep[p]) = emptyRgn) -> (repOk s p)))
  
  predicate sntlOk (s: state) (sntl1: reference) =
    (hasNodeType s sntl1) ->
      ((sntl1 <> null) ->
         (((s.heap.tag[sntl1]) = (0 - 1)) /\
            (((s.heap.key[sntl1]) = (0 - 1)) /\
               (((s.heap.sibling[sntl1]) = sntl1) /\ (((s.heap.child[sntl1]) = sntl1) /\ ((s.heap.prev[sntl1]) = sntl1))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = emptyRgn)))))))
  
  predicate pqueueI (s: state) =
    forall pq: reference.
      (isAllocated s pq) ->
        ((hasPqueueType s pq) ->
           ((Rgn.mem pq s.pool) ->
              (let rep1 = s.heap.rep[pq] in
               let sz = s.heap.size[pq] in
               let sntl2 = s.heap.sntl[pq] in
               let head3 = s.heap.head[pq] in
               (sntl2 <> null) /\
                 ((Rgn.mem sntl2 s.pool) /\
                    ((sntlOk s sntl2) /\
                       ((repOk s pq) /\
                          ((head3 <> null) /\
                             (((head3 <> sntl2) -> (Rgn.mem head3 rep1)) /\
                                ((sz >= 0) /\
                                   (((sz = 0) <-> (head3 = sntl2)) /\
                                      ((nodeP s rep1) /\
                                         (forall pq2: reference.
                                            (isAllocated s pq2) ->
                                              ((hasPqueueType s pq2) ->
                                                 ((Rgn.mem pq2 s.pool) -> ((pq <> pq2) -> (not ((s.heap.sntl[pq2]) = sntl2)))))))))))))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p s.pool) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q s.pool) ->
                                               ((PQUEUE.pqueuePub s) ->
                                                  ((p <> q) ->
                                                     (let prep = s.heap.rep[p] in
                                                      let qrep = s.heap.rep[q] in
                                                      forall n: reference.
                                                        (isAllocated s n) ->
                                                          ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { [@expl:wr {self}`key] wrs_to_key_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`tag] wrs_to_tag_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
           (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
           (! result))))))
  
  let getTag (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.tag[self]) = result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.tag] s.heap.tag[! self]));
         (! result))))
  
  let getKey (s: state) (self: reference) : int
    requires { hasNodeType s self }
    requires { self <> null }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[self]) = result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.key] s.heap.key[! self]));
         (! result))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { not (Rgn.mem self s.pool) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.sntl }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self}`rep union {self})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (s.heap.rep[self]) (singleton self))) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`prev]
              wrs_to_prev_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (s.heap.rep[self]) (singleton self))) }
    ensures { [@expl:wr ({self}`rep union {self})`head] wrs_to_head_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`child]
              wrs_to_child_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (s.heap.rep[self]) (singleton self))) }
    ensures { [@expl:wr ({self}`rep union {self})`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`tag]
              wrs_to_tag_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (s.heap.rep[self]) (singleton self))) }
    ensures { [@expl:wr ({self}`rep union {self})`size] wrs_to_size_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({self}`rep union {self})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { [@expl:wr ({} union {self}`rep union {self})`key]
              wrs_to_key_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (s.heap.rep[self]) (singleton self))) }
    ensures { [@expl:wr ({self}`rep union {self})`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (s.heap.rep[self]) (singleton self)) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { Rgn.mem self s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (Rgn.union s.pool (s.heap.rep[self])) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let sntl2 = ref null in
        (((assert { hasNodeType s (! sntl2) });
          (sntl2 := ([@expl:sntl := new Node] mk_Node s));
          (let sntlVal = ref 0 in
           (((sntlVal := ([@expl:sntlVal := - 1] 0 - 1));
             (assert { ((not (Rgn.mem (! sntl2) (s.alloct.M.domain at INIT))) \/ ((! sntl2) = null)) /\ true });
             ([@expl:Node(sntl,sntlVal,sntlVal)] init_Node s (! sntl2) (! sntlVal) (! sntlVal));
             (assert {
                forall pq: reference.
                  (isAllocated s pq) -> ((hasPqueueType s pq) -> ((Rgn.mem pq s.pool) -> (not ((s.heap.sntl[pq]) = (! sntl2))))) });
             (s.heap.rep <- ([@expl:self.rep := {}] M.add (! self) emptyRgn s.heap.rep));
             (s.heap.sntl <- ([@expl:self.sntl := sntl] M.add (! self) (! sntl2) s.heap.sntl));
             (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl2) s.heap.head));
             (s.heap.sibling <- ([@expl:sntl.sibling := sntl] M.add (! sntl2) (! sntl2) s.heap.sibling));
             (s.heap.child <- ([@expl:sntl.child := sntl] M.add (! sntl2) (! sntl2) s.heap.child));
             (s.heap.prev <- ([@expl:sntl.prev := sntl] M.add (! sntl2) (! sntl2) s.heap.prev));
             (s.pool <-
                ([@expl:pool := pool union {self} union {sntl}] Rgn.union (Rgn.union s.pool (singleton (! self))) (singleton (! sntl2))));
             (! result))))))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert { let sntl1 = s.heap.sntl[! self] in
                   not ((s.heap.head[! self]) = sntl1) });
         (assert {
            ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := self.head] s.heap.head[! self]));
         (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let first = ref first in
        (let second = ref second in
         (let fkey = ref 0 in
          (let skey = ref 0 in
           (let tmp = ref null in
            (((assert { hasNodeType s (! tmp) });
              (let ghost rep3 = ref emptyRgn in
               (((assert { isValidRgn s (! rep3) });
                 (let sntl4 = ref null in
                  (((assert { hasNodeType s (! sntl4) });
                    (assert {
                       ((Rgn.mem (! self) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                          ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                         true });
                    (sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                    (assert { ((! first) <> (! sntl4)) /\ ((! second) <> (! sntl4)) });
                    (assert {
                       ((Rgn.mem (! self) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                          ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                         true });
                    (rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                    (assert {
                       ((Rgn.mem (! first) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                          ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                         true });
                    (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
                    (assert {
                       ((Rgn.mem (! second) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                          ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                         true });
                    (skey := ([@expl:skey := second.key] s.heap.key[! second]));
                    (assert {
                       forall p: reference.
                         (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (repOk s p)))) });
                    (if ((! skey) < (! fkey))
                     then (((assert {
                               ((Rgn.mem (! first) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                  ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                 true });
                            (tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                            (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                            (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                            (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                            (assert { let p = s.heap.prev[! first] in
                                      Rgn.mem p (! rep3) });
                            (assert {
                               ((Rgn.mem (! second) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                  ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                                 true });
                            (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                            (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((assert {
                                       ((Rgn.mem (! first) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                          ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                         true });
                                    (tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                    (assert { let rep5 = s.heap.rep[! self] in
                                              Rgn.mem (! tmp) rep5 });
                                    (assert {
                                       forall p: reference.
                                         (isAllocated s p) ->
                                           ((hasPqueueType s p) ->
                                              ((Rgn.mem p s.pool) ->
                                                 ((p <> (! self)) -> (let rep6 = s.heap.rep[p] in
                                                                    not (Rgn.mem (! tmp) rep6))))) });
                                    (assert {
                                       let rep7 = s.heap.rep[! self] in
                                       let p = s.heap.prev[! tmp] in
                                       (p = (! sntl4)) \/ (Rgn.mem p rep7) });
                                    (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                                    (assert { Rgn.mem (! tmp) (! rep3) });
                                    (assert { let p = s.heap.prev[! tmp] in
                                              Rgn.mem p (! rep3) });
                                    (assert { repOk s (! self) })))
                             else ());
                            (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                            (result := ([@expl:result := second] ! second));
                            (assert { repOk s (! self) })))
                     else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                            (assert {
                               ((Rgn.mem (! second) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                  ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                                 true });
                            (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                            (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                            (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((assert {
                                       ((Rgn.mem (! first) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                          ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                         true });
                                    (tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                                    (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                             else ());
                            (assert {
                               ((Rgn.mem (! first) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                  ((not (Rgn.mem (! first) (s.alloct.M.domain at INIT))) \/ ((! first) = null))) /\
                                 true });
                            (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                            (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                            (if ((! tmp) <>. (! sntl4))
                             then (((assert { Rgn.mem (! tmp) (! rep3) });
                                    (assert {
                                       ((Rgn.mem (! second) ((Rgn.union (s.heap.rep[! self]) (singleton (! self))) at INIT)) \/
                                          ((not (Rgn.mem (! second) (s.alloct.M.domain at INIT))) \/ ((! second) = null))) /\
                                         true });
                                    (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                                    (assert { Rgn.mem (! tmp) (! rep3) });
                                    (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                             else ());
                            (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                            (result := ([@expl:result := first] ! first));
                            (assert { repOk s (! self) }))));
                    (! result)))))))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({} union {self}`rep)`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`child] wrs_to_child_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr ({} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union emptyRgn (s.heap.rep[self])) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { let oa = old s.alloct.M.domain in
              (Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self])) /\ (Rgn.mem result (Rgn.diff s.alloct.M.domain oa)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let k = ref k in
        (let t = ref t in
         (let sntl3 = ref null in
          (((assert { hasNodeType s (! sntl3) });
            (assert {
               ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                  ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                 true });
            (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
            (result := ([@expl:result := new Node] mk_Node s));
            (assert {
               ((Rgn.mem (! result) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                  ((not (Rgn.mem (! result) (s.alloct.M.domain at INIT))) \/ ((! result) = null))) /\
                 true });
            ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
            (assert { PQUEUE.pqueuePub s });
            (assert {
               forall p: reference.
                 (isAllocated s p) ->
                   ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep4 = s.heap.rep[p] in
                                                                   not (Rgn.mem (! result) rep4)))) });
            (s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! result) (! sntl3) s.heap.sibling));
            (s.heap.child <- ([@expl:result.child := sntl] M.add (! result) (! sntl3) s.heap.child));
            (s.heap.prev <- ([@expl:result.prev := sntl] M.add (! result) (! sntl3) s.heap.prev));
            (let ghost rep5 = ref emptyRgn in
             (((assert { isValidRgn s (! rep5) });
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (rep5 := ([@expl:rep := self.rep] s.heap.rep[! self]));
               (assert { (repOk s (! self)) /\ (nodeP s (! rep5)) });
               (s.heap.rep <-
                  ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep5) (singleton (! result))) s.heap.rep));
               (assert { repOk s (! self) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = old (s.heap.rep[p]) in
                                                                    (s.heap.rep[p]) = r)))) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = s.heap.rep[p] in
                                                                    not (Rgn.mem (! result) r))))) });
               (assert {
                  forall p: reference.
                    (isAllocated s p) ->
                      ((hasPqueueType s p) ->
                         ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = s.heap.rep[p] in
                                                                    let r2 = s.heap.rep[! self] in
                                                                    r \# r2)))) });
               (assert { PQUEUE.pqueuePub s });
               (assert { let r = s.heap.rep[! self] in
                         nodeP s r });
               (assert {
                  forall p: reference.
                    (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let r = s.heap.rep[p] in
                                                                    nodeP s r))) });
               (let hd = ref null in
                (((assert { hasNodeType s (! hd) });
                  (assert {
                     ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                        ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                       true });
                  (hd := ([@expl:hd := self.head] s.heap.head[! self]));
                  (if ((! hd) =. (! sntl3))
                   then (((s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                          (assert { repOk s (! self) })))
                   else (let tmp = ref null in
                         (((assert { hasNodeType s (! tmp) });
                           (assert {
                              (Rgn.subset
                                  (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                  (Rgn.union
                                      ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                      (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                true });
                           (tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                           (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                           (assert {
                              let hd6 = s.heap.head[! self] in
                              let rep7 = s.heap.rep[! self] in
                              (hd6 <> null) /\ (Rgn.mem hd6 rep7) })))));
                  (let sz = ref 0 in
                   (((assert {
                        ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                           ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                          true });
                     (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                     (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                     (! result))))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { let sntl3 = s.heap.sntl[self] in
               (not ((s.heap.sibling[handle]) = sntl3)) /\ (not ((s.heap.sibling[handle]) = null)) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let trees = ref null in
         (((assert { hasNodeArrayType s (! trees) });
           (let index = ref 0 in
            (let current = ref null in
             (((assert { hasNodeType s (! current) });
               (let sntl4 = ref null in
                (((assert { hasNodeType s (! sntl4) });
                  (let tmp = ref null in
                   (((assert { hasNodeType s (! tmp) });
                     (let fst = ref null in
                      (((assert { hasNodeType s (! fst) });
                        (let snd = ref null in
                         (((assert { hasNodeType s (! snd) });
                           (let i = ref 0 in
                            (let j = ref 0 in
                             (((assert {
                                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                                    true });
                               (sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                               (((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                                 (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                                 (s.heap.slots <-
                                    ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                               (s.heap.slots <-
                                  ([@expl:trees.{0} := handle]
                                   M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                               (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                               (assert {
                                  forall p: reference.
                                    (isAllocated s p) ->
                                      ((hasNodeArrayType s p) ->
                                         ((p <> (! trees)) -> (let s5 = old (s.heap.slots[p]) in
                                                               (s.heap.slots[p]) = s5))) });
                               (index := ([@expl:index := 1] 1));
                               (assert {
                                  ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                    true });
                               (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                               (while (! current) <>. (! sntl4) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! current)) /\
                                      ((hasNodeType s (! fst)) /\
                                         ((hasNodeType s (! handle)) /\
                                            ((hasNodeType s (! result)) /\
                                               ((hasPqueueType s (! self)) /\
                                                  ((hasNodeType s (! snd)) /\
                                                     ((hasNodeType s (! sntl4)) /\
                                                        ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                                  invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { pqueueI s }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant {
                                    ((! current) <> (! sntl4)) -> (let rep6 = s.heap.rep[! self] in
                                                                   Rgn.mem (! current) rep6) }
                                  invariant {
                                    forall k7: int.
                                      (0 <= k7) ->
                                        ((k7 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k7 in
                                            let rep8 = s.heap.rep[! self] in
                                            Rgn.mem n rep8)) }
                                  invariant {
                                    forall k9: int.
                                      (0 <= k9) -> ((k9 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k9) = (! sntl4)))) }
                                  invariant { (1 <= (! index)) /\ (let l = s.heap.length[! trees] in
                                                                   (! index) < l) }
                                  ((assume { let l = s.heap.length[! trees] in
                                             (! index) < (l - 1) });
                                   (s.heap.slots <-
                                      ([@expl:trees.{index} := current]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                                   (assert {
                                      ((Rgn.mem (! current) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! current) (s.alloct.M.domain at INIT))) \/ ((! current) = null))) /\
                                        true });
                                   (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                                   (s.heap.sibling <- ([@expl:tmp.sibling := sntl] M.add (! tmp) (! sntl4) s.heap.sibling));
                                   (assert {
                                      ((Rgn.mem (! current) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! current) (s.alloct.M.domain at INIT))) \/ ((! current) = null))) /\
                                        true });
                                   (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                                   (index := ([@expl:index := index + 1] (! index) + 1)))
                                done);
                               (s.heap.slots <-
                                  ([@expl:trees.{index} := sntl]
                                   M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! sntl4)) s.heap.slots));
                               (i := ([@expl:i := 0] 0));
                               (assert {
                                  ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                    true });
                               (tmp := ([@expl:tmp := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                               (while ((! i) + 1) < (! index) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! current)) /\
                                      ((hasNodeType s (! fst)) /\
                                         ((hasNodeType s (! handle)) /\
                                            ((hasNodeType s (! result)) /\
                                               ((hasPqueueType s (! self)) /\
                                                  ((hasNodeType s (! snd)) /\
                                                     ((hasNodeType s (! sntl4)) /\
                                                        ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                                  invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { (0 <= (! i)) /\ ((! i) <= (! index)) }
                                  invariant { pqueueI s }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant { let rep10 = s.heap.rep[! self] in
                                              (Rgn.mem (! tmp) rep10) /\ ((! tmp) <> null) }
                                  invariant {
                                    forall k11: int.
                                      (0 <= k11) ->
                                        ((k11 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k11 in
                                            let rep12 = s.heap.rep[! self] in
                                            Rgn.mem n rep12)) }
                                  invariant {
                                    forall k13: int.
                                      (0 <= k13) -> ((k13 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k13) = (! sntl4)))) }
                                  ((assert {
                                      ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                        true });
                                   (fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                                   (assert {
                                      ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                        true });
                                   (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                                   (assert {
                                      (Rgn.subset
                                          (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                          (Rgn.union
                                              ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                              (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                        true });
                                   (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                   (s.heap.slots <-
                                      ([@expl:trees.{i} := tmp]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                                   (i := ([@expl:i := i + 2] (! i) + 2)))
                                done);
                               (j := ([@expl:j := i - 2] (! i) - 2));
                               (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                                then (((assert { ((! j) + 2) < (! index) });
                                       (assert {
                                          ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                             ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                            true });
                                       (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                       (assert {
                                          ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                             ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                            true });
                                       (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                                       (assert {
                                          (Rgn.subset
                                              (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                              (Rgn.union
                                                  ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                                  (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                            true });
                                       (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                       (s.heap.slots <-
                                          ([@expl:trees.{j} := tmp]
                                           M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                                else ());
                               (while 2 <= (! j) do
                                  invariant {
                                    [@expl:locals type invariant]
                                    (hasNodeType s (! current)) /\
                                      ((hasNodeType s (! fst)) /\
                                         ((hasNodeType s (! handle)) /\
                                            ((hasNodeType s (! result)) /\
                                               ((hasPqueueType s (! self)) /\
                                                  ((hasNodeType s (! snd)) /\
                                                     ((hasNodeType s (! sntl4)) /\
                                                        ((hasNodeType s (! tmp)) /\ (hasNodeArrayType s (! trees))))))))) }
                                  invariant { alloc_does_not_shrink (old s) s }
                                  invariant { [@expl:wr {trees}`slots] wrs_to_slots_framed_by (old s) s (singleton (! trees)) }
                                  invariant { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[! self]) }
                                  invariant { pqueueI s }
                                  invariant { PQUEUE.pqueuePub s }
                                  invariant { ((0 - 2) <= (! j)) /\ ((! j) < (! index)) }
                                  invariant { let rep14 = s.heap.rep[! self] in
                                              (Rgn.mem (! tmp) rep14) /\ ((! tmp) <> null) }
                                  invariant {
                                    forall k15: int.
                                      (0 <= k15) ->
                                        ((k15 < (! index)) ->
                                           (let n = A.get (s.heap.slots[! trees]) k15 in
                                            let rep16 = s.heap.rep[! self] in
                                            Rgn.mem n rep16)) }
                                  invariant {
                                    forall k17: int.
                                      (0 <= k17) -> ((k17 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k17) = (! sntl4)))) }
                                  ((assert {
                                      ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                        true });
                                   (fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                                   (assert {
                                      ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                         ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                        true });
                                   (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                                   (assert {
                                      (Rgn.subset
                                          (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                          (Rgn.union
                                              ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                              (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                        true });
                                   (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                                   (assert { ((! tmp) <> null) /\ (typeofRgn s (singleton (! tmp)) (L.Cons Node L.Nil)) });
                                   (s.heap.slots <-
                                      ([@expl:trees.{j - 2} := tmp]
                                       M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                                   (j := ([@expl:j := j - 2] (! j) - 2)))
                                done);
                               (assert {
                                  ((Rgn.mem (! trees) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                     ((not (Rgn.mem (! trees) (s.alloct.M.domain at INIT))) \/ ((! trees) = null))) /\
                                    true });
                               (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                               (! result))))))))))))))))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old s) s emptyRgn }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old s) s (s.heap.rep[self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old s) s (s.heap.rep[self]) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { pqueueI s }
    ensures { PQUEUE.pqueuePub s }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let handle = ref handle in
        (let tmp = ref null in
         (((assert { hasNodeType s (! tmp) });
           (let sntl3 = ref null in
            (((assert { hasNodeType s (! sntl3) });
              (assert {
                 ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                    ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                   true });
              (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
              (assert {
                 ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                    ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                   true });
              (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
              (if ((! tmp) =. (! sntl3)) then (result := ([@expl:result := handle] ! handle))
               else (((assert {
                         (Rgn.subset
                             (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                             (Rgn.union
                                 ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                 (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                           true });
                      (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))))));
              (! result)))))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (((assert {
            ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
              true });
         (result := ([@expl:result := findMin(self)] findMin s (! self)));
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let sntl3 = ref null in
             (((assert { hasNodeType s (! sntl3) });
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
               (assert {
                  ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                    true });
               (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
               (if ((! tmp) =. (! sntl3))
                then (((assume { (s.heap.size[! self]) = 1 });
                       (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl3) s.heap.head))))
                else (((assume { let sz = s.heap.size[! self] in
                                 sz > 1 });
                       (assert {
                          (Rgn.subset
                              (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                              (Rgn.union
                                  ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                  (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                            true });
                       (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                       (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
               (let sz = ref 0 in
                (((assert {
                     ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                        ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                       true });
                  (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                  (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
                  (! result)))))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s }
    requires { pqueueI s }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl] wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r40 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r40 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.key[handle]) = k }
    ensures { PQUEUE.pqueuePub s }
    ensures { pqueueI s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let handle = ref handle in
        (let k = ref k in
         (let tmp = ref null in
          (((assert { hasNodeType s (! tmp) });
            (let pos = ref null in
             (((assert { hasNodeType s (! pos) });
               (let sntl3 = ref null in
                (((assert { hasNodeType s (! sntl3) });
                  (assert {
                     ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                        ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                       true });
                  (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                  (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
                  (assert {
                     ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                        ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                       true });
                  (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                  (assert { repOk s (! self) });
                  (if ((! handle) <>. (! tmp))
                   then (((assert {
                             ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                               true });
                          (tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                          (if ((! tmp) <>. (! sntl3))
                           then (((assert {
                                     ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                        ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                       true });
                                  (pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                                  (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev));
                                  (assert { repOk s (! self) })))
                           else ());
                          (assert {
                             ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                               true });
                          (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                          (if ((! tmp) <>. (! sntl3))
                           then (((assert {
                                     ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                        ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                                       true });
                                  (pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                                  (if ((! pos) =. (! handle))
                                   then (((assert {
                                             ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                                ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                               true });
                                          (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                          (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                                   else (((assert { not ((s.heap.prev[! handle]) = (! sntl3)) });
                                          (assert {
                                             ((Rgn.mem (! handle) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                                ((not (Rgn.mem (! handle) (s.alloct.M.domain at INIT))) \/ ((! handle) = null))) /\
                                               true });
                                          (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                          (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                          (assert {
                                             ((! pos) <> (! sntl3)) ->
                                               (let rep4 = s.heap.rep[! self] in
                                                let s5 = s.heap.sibling[! tmp] in
                                                Rgn.mem s5 rep4) }))));
                                  (assert {
                                     forall p: reference.
                                       (isAllocated s p) ->
                                         ((hasNodeType s p) ->
                                            (let r = s.heap.rep[! self] in
                                             (not (Rgn.mem p r)) -> (let sib = old (s.heap.sibling[p]) in
                                                                    (s.heap.sibling[p]) = sib))) })))
                           else ());
                          (s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! handle) (! sntl3) s.heap.sibling));
                          (assert {
                             ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                               true });
                          (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                          (assert {
                             (Rgn.subset
                                 (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                                 (Rgn.union
                                     ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                                     (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                               true });
                          (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                          (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
                   else ());
                  (! result)))))))))))))
  
  lemma boundary_frames_invariant_PqueueR : forall s: state, t6: state, pi: 
                                              PreRefperm.t.
                                              (okRefperm s t6 pi) ->
                                                ((PreRefperm.identity pi s.alloct.M.domain t6.alloct.M.domain) ->
                                                   ((PreRefperm.idRgn pi s.pool t6.pool) ->
                                                      ((agree_allfields s t6 pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                         ((pqueueI s) -> (pqueueI t6)))))
end

module PQUEUE_REL
  
  use prelude.Prelude
  use State
  use PqueueL
  use PqueueR
  
  predicate coupling0 (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_pq: reference) (r_pq: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasPqueueType l_s l_pq) ->
         ((hasPqueueType r_s r_pq) ->
            (((l_pq <> null) /\ (r_pq <> null)) ->
               ((PreRefperm.idRef pi l_pq r_pq) ->
                  (let l_sntl = l_s.heap.sntl[l_pq] in
                   let r_sntl = r_s.heap.sntl[r_pq] in
                   let l_rep = l_s.heap.rep[l_pq] in
                   let r_rep = r_s.heap.rep[r_pq] in
                   let l_hd = l_s.heap.head[l_pq] in
                   let r_hd = r_s.heap.head[r_pq] in
                   let l_sz = l_s.heap.size[l_pq] in
                   let r_sz = r_s.heap.size[r_pq] in
                   (l_sz = r_sz) /\
                     (((PreRefperm.idRef pi l_hd r_hd) \/ ((l_hd = null) /\ (r_hd = r_sntl))) /\
                        ((PreRefperm.idRgn pi (rgnSubK l_rep l_s.alloct Node) (rgnSubK r_rep r_s.alloct Node)) /\
                           (forall l_n: reference, r_n: reference.
                              (isAllocated l_s l_n) ->
                                ((hasNodeType l_s l_n) ->
                                   ((Rgn.mem l_n l_rep) ->
                                      ((isAllocated r_s r_n) ->
                                         ((hasNodeType r_s r_n) ->
                                            ((Rgn.mem r_n r_rep) ->
                                               ((PreRefperm.idRef pi l_n r_n) ->
                                                  (let l_k = l_s.heap.key[l_n] in
                                                   let r_k = r_s.heap.key[r_n] in
                                                   let l_t = l_s.heap.tag[l_n] in
                                                   let r_t = r_s.heap.tag[r_n] in
                                                   let l_pre = l_s.heap.prev[l_n] in
                                                   let r_pre = r_s.heap.prev[r_n] in
                                                   let l_sib = l_s.heap.sibling[l_n] in
                                                   let r_sib = r_s.heap.sibling[r_n] in
                                                   let l_chl = l_s.heap.child[l_n] in
                                                   let r_chl = r_s.heap.child[r_n] in
                                                   (l_k = r_k) /\
                                                     ((l_t = r_t) /\
                                                        ((((PreRefperm.idRef pi l_pre r_pre) /\ ((l_pre <> null) /\ (r_pre <> r_sntl))) \/
                                                            ((l_pre = null) /\ (r_pre = r_sntl))) /\
                                                           ((((PreRefperm.idRef pi l_sib r_sib) /\
                                                                ((l_sib <> null) /\ (r_sib <> r_sntl))) \/
                                                               ((l_sib = null) /\ (r_sib = r_sntl))) /\
                                                              (((PreRefperm.idRef pi l_chl r_chl) /\
                                                                  ((l_chl <> null) /\ (r_chl <> r_sntl))) \/
                                                                 ((l_chl = null) /\ (r_chl = r_sntl)))))))))))))))))))))
  
  predicate pqueueR (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (okRefperm l_s r_s pi) ->
      ((PreRefperm.idRgn pi (rgnSubK l_s.pool l_s.alloct Pqueue) (rgnSubK r_s.pool r_s.alloct Pqueue)) /\
         ((forall l_pq: reference, r_pq: reference.
             (isAllocated l_s l_pq) ->
               ((hasPqueueType l_s l_pq) ->
                  ((Rgn.mem l_pq l_s.pool) ->
                     ((isAllocated r_s r_pq) ->
                        ((hasPqueueType r_s r_pq) ->
                           ((Rgn.mem r_pq r_s.pool) -> ((PreRefperm.idRef pi l_pq r_pq) -> (coupling0 l_s r_s pi l_pq r_pq)))))))) /\
            (((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) /\ ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)))))
  
  let isEmpty (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { pqueueR l_s r_s pi }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (agree_size l_s r_s pi (singleton l_self)) /\ (agree_size r_s l_s (PreRefperm.invert pi) (singleton r_self)) }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { pqueueR l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) } =
    label INIT in
      let l_result = ref false in
      (let r_result = ref false in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let l_sz = ref 0 in
          (let r_sz = ref 0 in
           (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
               (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
             (l_result := ([@expl:result := sz = 0] (! l_sz) = 0));
             (r_result := ([@expl:result := sz = 0] (! r_sz) = 0));
             (! l_result, ! r_result))))))))
  
  let findMin (l_s: state) (r_s: state) (pi7: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi7 }
    requires { pqueueR l_s r_s pi7 }
    requires { PreRefperm.idRef pi7 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { okRefperm l_s r_s pi7 }
    ensures { pqueueR l_s r_s pi7 }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi7 l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let hd = l_s.heap.head[l_self] in
                      l_result = hd) /\ (let hd = r_s.heap.head[r_self] in
                                         r_result = hd))
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi7 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi7) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (((assert {
              (not ((l_s.heap.head[! l_self]) = null)) /\
                (let sntl8 = r_s.heap.sntl[! r_self] in
                 not ((r_s.heap.head[! r_self]) = sntl8)) });
           (l_result := ([@expl:result := self.head] l_s.heap.head[! l_self]));
           (r_result := ([@expl:result := self.head] r_s.heap.head[! r_self]));
           (! l_result, ! r_result))))))
  
  val link (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_first: reference) (l_second: reference) (r_self: reference) (r_first: reference) (r_second: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_first }
    requires { l_first <> null }
    requires { hasNodeType l_s l_second }
    requires { l_second <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_first }
    requires { r_first <> null }
    requires { hasNodeType r_s r_second }
    requires { r_second <> null }
    requires { okRefperm l_s r_s pi }
    requires { PreRefperm.idRef pi l_second r_second }
    requires { PreRefperm.idRef pi l_first r_first }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { pqueueR l_s r_s pi }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let rep9 = l_s.heap.rep[l_self] in
                (Rgn.mem l_first rep9) /\ (Rgn.mem l_second rep9)) /\
                 (let rep10 = r_s.heap.rep[r_self] in
                  (Rgn.mem r_first rep10) /\ (Rgn.mem r_second rep10)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.child }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { r_s.heap.child }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { okRefperm l_s r_s pi }
    ensures { pqueueR l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (((l_result = l_first) \/ (l_result = l_second)) /\ ((r_result = r_first) \/ (r_result = r_second)))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((((l_result = l_first) /\ ((l_s.heap.child[l_first]) = l_second)) \/
                        ((l_result = l_second) /\ ((l_s.heap.child[l_second]) = l_first))) /\
                       (((r_result = r_first) /\ ((r_s.heap.child[r_first]) = r_second)) \/
                          ((r_result = r_second) /\ ((r_s.heap.child[r_second]) = r_first))))
              end }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let insert (l_s: state) (r_s: state) (pi11: PreRefperm.t) (l_self: reference) (l_k: int) (l_t: int) (r_self: reference) (r_k: int) (r_t: int) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi11 }
    requires { pqueueR l_s r_s pi11 }
    requires { l_t = r_t }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi11 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    requires { (0 <= l_t) /\ (0 <= r_t) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    writes { pi11 }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.rep }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.tag }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.rep }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.tag }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({self}`rep union {})`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {})`prev] wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self}`rep union {})`child] wrs_to_child_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self}`rep union {})`tag] wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({self}`rep union {})`key] wrs_to_key_framed_by (old l_s) l_s (Rgn.union (l_s.heap.rep[l_self]) emptyRgn) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({self}`rep union {})`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) emptyRgn) }
    ensures { [@expl:wr ({self}`rep union {})`prev] wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self}`rep union {})`child] wrs_to_child_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self}`rep union {})`tag] wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({self}`rep union {})`key] wrs_to_key_framed_by (old r_s) r_s (Rgn.union (r_s.heap.rep[r_self]) emptyRgn) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi11 }
    ensures { pqueueR l_s r_s pi11 }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep12 = l_s.heap.rep[l_self] in
                      forall n: reference.
                        (isAllocated l_s n) ->
                          ((hasNodeType l_s n) ->
                             ((Rgn.mem n rep12) ->
                                ((n <> l_result) ->
                                   (let ot = old (l_s.heap.tag[n]) in
                                    let ok = old (l_s.heap.key[n]) in
                                    ((l_s.heap.tag[n]) = ot) /\ ((l_s.heap.key[n]) = ok)))))) /\
                       (let rep13 = r_s.heap.rep[r_self] in
                        forall n: reference.
                          (isAllocated r_s n) ->
                            ((hasNodeType r_s n) ->
                               ((Rgn.mem n rep13) ->
                                  ((n <> r_result) ->
                                     (let ot = old (r_s.heap.tag[n]) in
                                      let ok = old (r_s.heap.key[n]) in
                                      ((r_s.heap.tag[n]) = ot) /\ ((r_s.heap.key[n]) = ok)))))))
              end }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi11 l_result r_result) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.tag[l_result]) = l_t) /\ ((r_s.heap.tag[r_result]) = r_t)) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.key[l_result]) = l_k) /\ ((r_s.heap.key[r_result]) = r_k)) end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let orep = old (l_s.heap.rep[l_self]) in
                      (l_s.heap.rep[l_self]) = (Rgn.union orep (singleton l_result))) /\
                       (let orep = old (r_s.heap.rep[r_self]) in
                        (r_s.heap.rep[r_self]) = (Rgn.union orep (singleton r_result))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep14 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep14) /\
                       (let rep15 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep15))
              end }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let l_k = ref l_k in
         (let l_t = ref l_t in
          (let r_self = ref r_self in
           (let r_k = ref r_k in
            (let r_t = ref r_t in
             (((assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) });
               (let l_sntl = ref null in
                (let r_sntl = ref null in
                 ((((();
                     (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                   (((l_result := ([@expl:result := new Node] mk_Node l_s));
                     (r_result := ([@expl:result := new Node] mk_Node r_s))));
                   ((([@expl:Node(result,k,t)] PqueueL.init_Node l_s (! l_result) (! l_k) (! l_t));
                     ([@expl:Node(result,k,t)] PqueueR.init_Node r_s (! r_result) (! r_k) (! r_t))));
                   ((();
                     (r_s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! r_result) (! r_sntl) r_s.heap.sibling));
                     (r_s.heap.child <- ([@expl:result.child := sntl] M.add (! r_result) (! r_sntl) r_s.heap.child));
                     (r_s.heap.prev <- ([@expl:result.prev := sntl] M.add (! r_result) (! r_sntl) r_s.heap.prev))));
                   (PreRefperm.updateRefperm pi11 (! l_result) (! r_result));
                   (assert { PreRefperm.idRef pi11 (! l_result) (! r_result) });
                   (assert {
                      (((l_s.heap.sibling[! l_result]) = null) /\
                         (((l_s.heap.child[! l_result]) = null) /\ ((l_s.heap.prev[! l_result]) = null))) /\
                        (((r_s.heap.sibling[! r_result]) = (! r_sntl)) /\
                           (((r_s.heap.child[! r_result]) = (! r_sntl)) /\ ((r_s.heap.prev[! r_result]) = (! r_sntl)))) });
                   (let ghost l_rep = ref emptyRgn in
                    (let ghost r_rep = ref emptyRgn in
                     (((((l_rep := ([@expl:rep := self.rep] l_s.heap.rep[! l_self]));
                         (r_rep := ([@expl:rep := self.rep] r_s.heap.rep[! r_self]))));
                       (((l_s.heap.rep <-
                            ([@expl:self.rep := rep union {result}]
                             M.add (! l_self) (Rgn.union (! l_rep) (singleton (! l_result))) l_s.heap.rep));
                         (r_s.heap.rep <-
                            ([@expl:self.rep := rep union {result}]
                             M.add (! r_self) (Rgn.union (! r_rep) (singleton (! r_result))) r_s.heap.rep))));
                       (let l_hd = ref null in
                        (let r_hd = ref null in
                         (((((l_hd := ([@expl:hd := self.head] l_s.heap.head[! l_self]));
                             (r_hd := ([@expl:hd := self.head] r_s.heap.head[! r_self]))));
                           (assert { ((l_s.heap.head[! l_self]) = null) <-> ((r_s.heap.head[! r_self]) = (! r_sntl)) });
                           ((([@expl:guard agreement] assert { ((! l_hd) = null) = ((! r_hd) = (! r_sntl)) });
                             (if ((! l_hd) =. null)
                              then (((((l_s.heap.head <- ([@expl:self.head := result] M.add (! l_self) (! l_result) l_s.heap.head));
                                       (r_s.heap.head <- ([@expl:self.head := result] M.add (! r_self) (! r_result) r_s.heap.head))));
                                     (assert {
                                        let l_hd = l_s.heap.head[! l_self] in
                                        let r_hd = r_s.heap.head[! r_self] in
                                        PreRefperm.idRef pi11 l_hd r_hd });
                                     (assert {
                                        forall l_pq: reference, r_pq: reference.
                                          (isAllocated l_s l_pq) ->
                                            ((hasPqueueType l_s l_pq) ->
                                               ((Rgn.mem l_pq l_s.pool) ->
                                                  ((isAllocated r_s r_pq) ->
                                                     ((hasPqueueType r_s r_pq) ->
                                                        ((Rgn.mem r_pq r_s.pool) ->
                                                           ((PreRefperm.idRef pi11 l_pq r_pq) ->
                                                              (let l_hd = l_s.heap.head[l_pq] in
                                                               let r_hd = r_s.heap.head[r_pq] in
                                                               (PreRefperm.idRef pi11 l_hd r_hd) \/
                                                                 ((l_hd = null) /\ ((r_s.heap.sntl[r_pq]) = r_hd))))))))) });
                                     (assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) })))
                              else (((assert { coupling0 l_s r_s pi11 (! l_self) (! r_self) });
                                     (let l_tmp = ref null in
                                      (let r_tmp = ref null in
                                       (((assume {
                                            ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)) /\
                                              ((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) });
                                         (match link l_s r_s pi11 (! l_self) (! l_hd) (! l_result) (! r_self) (! r_hd) (! r_result)
                                          with
                                            | (l_link_res, r_link_res) ->
                                                (((l_tmp := ([@expl:tmp := link(self,hd,result)] l_link_res));
                                                  (r_tmp := ([@expl:tmp := link(self,hd,result)] r_link_res))))
                                          end);
                                         (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                                         (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))))))));
                           (let l_sz = ref 0 in
                            (let r_sz = ref 0 in
                             (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                                 (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                               (assert { (! l_sz) = (! r_sz) });
                               (((l_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! l_self) ((! l_sz) + 1) l_s.heap.size));
                                 (r_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! r_self) ((! r_sz) + 1) r_s.heap.size))));
                               (assume {
                                  ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s)) /\
                                    ((PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s)) });
                               (! l_result, ! r_result))))))))))))))))))))))))))
  
  val combine (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (r_self: reference) (r_handle: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { pqueueR l_s r_s pi }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (let rep16 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep16) /\
                 (let rep17 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep17) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.child }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { l_s.alloct }
    writes { l_s.heap.slots }
    writes { l_s.heap.length }
    writes { r_s.heap.child }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    writes { r_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.length }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old l_s) l_s emptyRgn }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old l_s) l_s emptyRgn }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {}`slots] wrs_to_slots_framed_by (old r_s) r_s emptyRgn }
    ensures { [@expl:wr {}`length] wrs_to_length_framed_by (old r_s) r_s emptyRgn }
    ensures { okRefperm l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { pqueueR l_s r_s pi }
    ensures { (let ohd = old (l_s.heap.head[l_self]) in
               (l_s.heap.head[l_self]) = ohd) /\
                (let ohd = old (r_s.heap.head[r_self]) in
                 (r_s.heap.head[r_self]) = ohd) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep18 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep18) /\
                       (let rep19 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep19))
              end }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let deleteMin (l_s: state) (r_s: state) (pi20: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi20 }
    requires { pqueueR l_s r_s pi20 }
    requires { PreRefperm.idRef pi20 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.length }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.length }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.slots }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr ({self} union {self}`rep union {})`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr ({self} union {self}`rep union {})`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi20 }
    ensures { pqueueR l_s r_s pi20 }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { (let rep21 = l_s.heap.rep[l_self] in
               forall n: reference.
                 (isAllocated l_s n) ->
                   ((hasNodeType l_s n) ->
                      ((Rgn.mem n rep21) ->
                         (let otag = old (l_s.heap.tag[n]) in
                          let okey = old (l_s.heap.key[n]) in
                          ((l_s.heap.tag[n]) = otag) /\ ((l_s.heap.key[n]) = okey))))) /\
                (let rep22 = r_s.heap.rep[r_self] in
                 forall n: reference.
                   (isAllocated r_s n) ->
                     ((hasNodeType r_s n) ->
                        ((Rgn.mem n rep22) ->
                           (let otag = old (r_s.heap.tag[n]) in
                            let okey = old (r_s.heap.key[n]) in
                            ((r_s.heap.tag[n]) = otag) /\ ((r_s.heap.key[n]) = okey))))) }
    ensures { (let orep = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = orep) /\
                (let orep = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = orep) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi20 l_result r_result) end }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (((match findMin l_s r_s pi20 (! l_self) (! r_self)
            with
              | (l_findMin_res, r_findMin_res) ->
                  (((l_result := ([@expl:result := findMin(self)] l_findMin_res));
                    (r_result := ([@expl:result := findMin(self)] r_findMin_res))))
            end);
           (let l_tmp = ref null in
            (let r_tmp = ref null in
             (let l_sntl = ref null in
              (let r_sntl = ref null in
               ((((();
                   (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                 (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                   (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                 (((l_tmp := ([@expl:tmp := tmp.child] l_s.heap.child[! l_tmp]));
                   (r_tmp := ([@expl:tmp := tmp.child] r_s.heap.child[! r_tmp]))));
                 ((([@expl:guard agreement] assert { ((! l_tmp) = null) = ((! r_tmp) = (! r_sntl)) });
                   (if ((! l_tmp) =. null)
                    then (((assume { ((l_s.heap.size[! l_self]) = 1) /\ ((r_s.heap.size[! r_self]) = 1) });
                           (l_s.heap.head <- ([@expl:self.head := null] M.add (! l_self) null l_s.heap.head));
                           (r_s.heap.head <- ([@expl:self.head := sntl] M.add (! r_self) (! r_sntl) r_s.heap.head))))
                    else (((assume { (let sz = l_s.heap.size[! l_self] in
                                      sz > 1) /\ (let sz = r_s.heap.size[! r_self] in
                                                  sz > 1) });
                           (match combine l_s r_s pi20 (! l_self) (! l_tmp) (! r_self) (! r_tmp)
                            with
                              | (l_combine_res, r_combine_res) ->
                                  (((l_tmp := ([@expl:tmp := combine(self,tmp)] l_combine_res));
                                    (r_tmp := ([@expl:tmp := combine(self,tmp)] r_combine_res))))
                            end);
                           (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                           (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))));
                 (let l_sz = ref 0 in
                  (let r_sz = ref 0 in
                   (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                       (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                     (((l_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! l_self) ((! l_sz) - 1) l_s.heap.size));
                       (r_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! r_self) ((! r_sz) - 1) r_s.heap.size))));
                     (assume { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) });
                     (! l_result, ! r_result))))))))))))))))
  
  let decreaseKey (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (l_k: int) (r_self: reference) (r_handle: reference) (r_k: int) : 
    (unit,
     unit)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { pqueueR l_s r_s pi }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (let key23 = l_s.heap.key[l_handle] in
                l_k <= key23) /\ (let key24 = r_s.heap.key[r_handle] in
                                  r_k <= key24) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    requires { (let rep25 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep25) /\
                 (let rep26 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep26) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { okRefperm l_s r_s pi }
    ensures { pqueueR l_s r_s pi }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { ((l_s.heap.key[l_handle]) = l_k) /\ ((r_s.heap.key[r_handle]) = r_k) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    label INIT in
      let l_result = ref () in
      (let r_result = ref () in
       (let l_self = ref l_self in
        (let l_handle = ref l_handle in
         (let l_k = ref l_k in
          (let r_self = ref r_self in
           (let r_handle = ref r_handle in
            (let r_k = ref r_k in
             (let l_tmp = ref null in
              (let r_tmp = ref null in
               (let l_pos = ref null in
                (let r_pos = ref null in
                 (let l_sntl = ref null in
                  (let r_sntl = ref null in
                   ((((();
                       (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                     (((l_s.heap.key <- ([@expl:handle.key := k] M.add (! l_handle) (! l_k) l_s.heap.key));
                       (r_s.heap.key <- ([@expl:handle.key := k] M.add (! r_handle) (! r_k) r_s.heap.key))));
                     (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                       (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                     ((([@expl:guard agreement] assert { ((! l_handle) <> (! l_tmp)) = ((! r_handle) <> (! r_tmp)) });
                       (if ((! l_handle) <>. (! l_tmp))
                        then (((((l_tmp := ([@expl:tmp := handle.sibling] l_s.heap.sibling[! l_handle]));
                                 (r_tmp := ([@expl:tmp := handle.sibling] r_s.heap.sibling[! r_handle]))));
                               ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                                 (if ((! l_tmp) <>. null)
                                  then (((((l_pos := ([@expl:pos := handle.prev] l_s.heap.prev[! l_handle]));
                                           (r_pos := ([@expl:pos := handle.prev] r_s.heap.prev[! r_handle]))));
                                         (l_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! l_tmp) (! l_pos) l_s.heap.prev));
                                         (r_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! r_tmp) (! r_pos) r_s.heap.prev))))
                                  else ((();
                                         ())))));
                               (((l_tmp := ([@expl:tmp := handle.prev] l_s.heap.prev[! l_handle]));
                                 (r_tmp := ([@expl:tmp := handle.prev] r_s.heap.prev[! r_handle]))));
                               ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                                 (if ((! l_tmp) <>. null)
                                  then (((((l_pos := ([@expl:pos := tmp.child] l_s.heap.child[! l_tmp]));
                                           (r_pos := ([@expl:pos := tmp.child] r_s.heap.child[! r_tmp]))));
                                         (assert {
                                            ((not ((l_s.heap.prev[! l_handle]) = null)) /\ (not ((r_s.heap.prev[! r_handle]) = null))) /\
                                              (not ((r_s.heap.prev[! r_handle]) = (! r_sntl))) });
                                         (assert {
                                            (PreRefperm.idRef pi (! l_tmp) (! r_tmp)) /\
                                              (((! l_tmp) <> null) /\ ((! r_tmp) <> (! r_sntl))) });
                                         (assert {
                                            let l_c = l_s.heap.child[! l_tmp] in
                                            let r_c = r_s.heap.child[! r_tmp] in
                                            ((PreRefperm.idRef pi l_c r_c) /\ ((l_c <> null) /\ (r_c <> (! r_sntl)))) \/
                                              ((l_c = null) /\ (r_c = (! r_sntl))) });
                                         ((([@expl:guard agreement] assert { ((! l_pos) = (! l_handle)) = ((! r_pos) = (! r_handle)) });
                                           (if ((! l_pos) =. (! l_handle))
                                            then (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                     (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                                   (l_s.heap.child <-
                                                      ([@expl:tmp.child := pos] M.add (! l_tmp) (! l_pos) l_s.heap.child));
                                                   (r_s.heap.child <-
                                                      ([@expl:tmp.child := pos] M.add (! r_tmp) (! r_pos) r_s.heap.child))))
                                            else (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                     (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                                   (l_s.heap.sibling <-
                                                      ([@expl:tmp.sibling := pos] M.add (! l_tmp) (! l_pos) l_s.heap.sibling));
                                                   (r_s.heap.sibling <-
                                                      ([@expl:tmp.sibling := pos] M.add (! r_tmp) (! r_pos) r_s.heap.sibling)))))));
                                         (assert { coupling0 l_s r_s pi (! l_self) (! r_self) })))
                                  else ((();
                                         ())))));
                               (((l_s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! l_handle) null l_s.heap.sibling));
                                 (r_s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! r_handle) (! r_sntl) r_s.heap.sibling))));
                               (((l_pos := ([@expl:pos := self.head] l_s.heap.head[! l_self]));
                                 (r_pos := ([@expl:pos := self.head] r_s.heap.head[! r_self]))));
                               (assume {
                                  ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueL.pqueueI l_s)) /\
                                    ((PqueueR.PQUEUE.pqueuePub r_s) /\ (PqueueR.pqueueI r_s)) });
                               (match link l_s r_s pi (! l_self) (! l_pos) (! l_handle) (! r_self) (! r_pos) (! r_handle)
                                with
                                  | (l_link_res, r_link_res) ->
                                      (((l_tmp := ([@expl:tmp := link(self,pos,handle)] l_link_res));
                                        (r_tmp := ([@expl:tmp := link(self,pos,handle)] r_link_res))))
                                end);
                               (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                               (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head))))
                        else ((();
                               ())))));
                     (assume {
                        ((PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueL.pqueueI l_s)) /\
                          ((PqueueR.PQUEUE.pqueuePub r_s) /\ (PqueueR.pqueueI r_s)) });
                     (! l_result, ! r_result))))))))))))))))
  
  lemma boundary_frames_coupling_PQUEUE_REL : forall s: state, t27: state, s': state, t': state, pi28: 
                                                PreRefperm.t, pi': PreRefperm.t, rho: 
                                                PreRefperm.t.
                                                (okRefperm s t27 pi28) ->
                                                  ((okRefperm s' t' pi') ->
                                                     ((PreRefperm.identity pi28 s.alloct.M.domain t27.alloct.M.domain) ->
                                                        ((PreRefperm.identity pi' s'.alloct.M.domain t'.alloct.M.domain) ->
                                                           ((okRefperm s s' rho) ->
                                                              ((okRefperm t27 t' rho) ->
                                                                 ((PreRefperm.idRgn pi28 s.pool t27.pool) ->
                                                                    (
                                                                    (agree_allfields s t27 pi28 (Rgn.union s.pool (img_rep s s.pool))) ->
                                                                    ((PreRefperm.idRgn pi' s'.pool t'.pool) ->
                                                                    ((agree_allfields
                                                                    s'
                                                                    t'
                                                                    pi'
                                                                    (Rgn.union s'.pool (img_rep s' s'.pool))) ->
                                                                    ((pqueueR s s' rho) -> (pqueueR t27 t' rho)))))))))))
  
  lemma pqueueR_is_refperm_monotonic : forall s: state, t29: state, pi30: 
                                         PreRefperm.t.
                                         (okRefperm s t29 pi30) ->
                                           ((pqueueR s t29 pi30) ->
                                              (forall rho: PreRefperm.t.
                                                 (okRefperm s t29 rho) -> ((PreRefperm.extends pi30 rho) -> (pqueueR s t29 rho))))
end

module Main
  
  use prelude.Prelude
  use State
  use MAIN
  use PQUEUE
  use export graph_theory.Graph_theory
  
  val initDistances (s: state) (d: reference) (k: int) : unit
    requires { hasDistArrayType s d }
    requires { d <> null }
    requires { k >= 0 }
    writes { s.heap.dSlots }
    ensures { result = () }
    ensures { [@expl:wr {d}`dSlots] wrs_to_dSlots_framed_by (old s) s (singleton d) }
    ensures { let len = s.heap.dLength[d] in
              forall i: int. (0 <= i) -> ((i < len) -> ((A.get (s.heap.dSlots[d]) i) = k)) }
  
  let main (s: state) (g: graph) (source: int) : reference diverges
    requires { s.pool = emptyRgn }
    requires { PQUEUE.pqueuePub s }
    requires { hasVertex g source }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.child }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.sntl }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`dSlots]
              wrs_to_dSlots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`sntl]
              wrs_to_sntl_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`sibling] wrs_to_sibling_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`prev] wrs_to_prev_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`head]
              wrs_to_head_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`child] wrs_to_child_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (Rgn.union s.pool (img_rep s s.pool)))) }
    ensures { [@expl:wr (pool union pool`rep)`tag] wrs_to_tag_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`size]
              wrs_to_size_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`key] wrs_to_key_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`dLength]
              wrs_to_dLength_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) } =
    label INIT in
      let result = ref null in
      (let g = ref g in
       (let source = ref source in
        (let queue = ref null in
         (((assert { hasPqueueType s (! queue) });
           (let numVs = ref 0 in
            (((numVs := ([@expl:numVs := numVertices(g)] numVertices (! g)));
              (queue := ([@expl:queue := new Pqueue] mk_Pqueue s));
              ([@expl:Pqueue(queue)] PQUEUE.init_Pqueue s (! queue));
              (let dist = ref null in
               (((assert { hasDistArrayType s (! dist) });
                 (((dist := ([@expl:dist := new(DistArray){numVs}] mk_DistArray s));
                   (s.heap.dLength <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (! numVs) s.heap.dLength));
                   (s.heap.dSlots <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (A.make (! numVs) 0) s.heap.dSlots))));
                 (assert {
                    ((Rgn.mem (! dist) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                       ((not (Rgn.mem (! dist) (s.alloct.M.domain at INIT))) \/ ((! dist) = null))) /\
                      true });
                 ([@expl:initDistances(dist,maxWeight)] initDistances s (! dist) maxWeight);
                 (let initDist = ref 0 in
                  (((initDist := ([@expl:initDist := 0] 0));
                    (let ins = ref null in
                     (((assert { hasNodeType s (! ins) });
                       (assert {
                          (Rgn.subset
                              (Rgn.diff (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) (singleton null))
                              (Rgn.union
                                  ((Rgn.union s.pool (Rgn.union s.pool (img_rep s s.pool))) at INIT)
                                  (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                            ((Rgn.subset
                                 (Rgn.diff (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) (singleton null))
                                 (Rgn.union
                                     ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                     (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                               true) });
                       (ins := ([@expl:ins := insert(queue,initDist,source)] PQUEUE.insert s (! queue) (! initDist) (! source)));
                       (let isEmp = ref false in
                        (((assert {
                             ((Rgn.mem (! queue) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                ((not (Rgn.mem (! queue) (s.alloct.M.domain at INIT))) \/ ((! queue) = null))) /\
                               true });
                          (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                          (let min = ref null in
                           (((assert { hasNodeType s (! min) });
                             (let minTag = ref 0 in
                              (let minKey = ref 0 in
                               (((min := ([@expl:min := ins] ! ins));
                                 (while not (! isEmp) do
                                    invariant {
                                      [@expl:locals type invariant]
                                      (hasDistArrayType s (! dist)) /\
                                        ((hasNodeType s (! ins)) /\
                                           ((hasNodeType s (! min)) /\ ((hasPqueueType s (! queue)) /\ (hasDistArrayType s (! result))))) }
                                    invariant { alloc_does_not_shrink (old s) s }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`slots]
                                      wrs_to_slots_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({dist} union {queue} union {queue}`rep)`dSlots]
                                      wrs_to_dSlots_framed_by
                                        (old s)
                                        s
                                        (Rgn.union (singleton (! dist)) (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`sntl]
                                      wrs_to_sntl_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`sibling]
                                      wrs_to_sibling_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`prev]
                                      wrs_to_prev_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`head]
                                      wrs_to_head_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`child]
                                      wrs_to_child_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`rep]
                                      wrs_to_rep_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`tag]
                                      wrs_to_tag_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`size]
                                      wrs_to_size_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`length]
                                      wrs_to_length_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({queue} union {queue}`rep)`key]
                                      wrs_to_key_framed_by (old s) s (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                    invariant {
                                      [@expl:wr ({dist} union {queue} union {queue}`rep)`dLength]
                                      wrs_to_dLength_framed_by
                                        (old s)
                                        s
                                        (Rgn.union (singleton (! dist)) (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))) }
                                    invariant { PQUEUE.pqueuePub s }
                                    invariant {
                                      let oa = old s.alloct.M.domain in
                                      Rgn.subset
                                         (Rgn.diff (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) (singleton null))
                                         (Rgn.diff s.alloct.M.domain oa) }
                                    invariant {
                                      let rep1 = s.heap.rep[! queue] in
                                      forall n: reference.
                                        (isAllocated s n) ->
                                          ((hasNodeType s n) ->
                                             ((Rgn.mem n rep1) ->
                                                (let len = s.heap.dLength[! dist] in
                                                 let tag2 = s.heap.tag[n] in
                                                 (tag2 >= 0) /\ (tag2 < len)))) }
                                    invariant {
                                      let rep3 = s.heap.rep[! queue] in
                                      forall n: reference.
                                        (isAllocated s n) ->
                                          ((hasNodeType s n) -> ((Rgn.mem n rep3) -> (let key4 = s.heap.key[n] in
                                                                    key4 >= 0))) }
                                    invariant { let rep5 = s.heap.rep[! queue] in
                                                Rgn.mem (! min) rep5 }
                                    invariant {
                                      let len = s.heap.dLength[! dist] in
                                      forall k: int. (0 <= k) -> ((k < len) -> (let v = A.get (s.heap.dSlots[! dist]) k in
                                                                    0 <= v)) }
                                    invariant { (singleton (! dist)) \# (Rgn.union s.pool (img_rep s s.pool)) }
                                    invariant { ((! numVs) = (numVertices (! g))) /\ ((s.heap.dLength[! dist]) = (! numVs)) }
                                    invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                                    ((assert {
                                        (Rgn.subset
                                            (Rgn.diff (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) (singleton null))
                                            (Rgn.union
                                                ((Rgn.union s.pool (Rgn.union s.pool (img_rep s s.pool))) at INIT)
                                                (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                          ((Rgn.subset
                                               (Rgn.diff (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) (singleton null))
                                               (Rgn.union
                                                   ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                                   (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                             true) });
                                     (min := ([@expl:min := deleteMin(queue)] PQUEUE.deleteMin s (! queue)));
                                     (assert {
                                        ((Rgn.mem (! min) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                           ((not (Rgn.mem (! min) (s.alloct.M.domain at INIT))) \/ ((! min) = null))) /\
                                          true });
                                     (minTag := ([@expl:minTag := getTag(min)] PQUEUE.getTag s (! min)));
                                     (assert {
                                        ((Rgn.mem (! min) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                           ((not (Rgn.mem (! min) (s.alloct.M.domain at INIT))) \/ ((! min) = null))) /\
                                          true });
                                     (minKey := ([@expl:minKey := getKey(min)] PQUEUE.getKey s (! min)));
                                     (assert { ((! minTag) >= 0) /\ (let len = s.heap.dLength[! dist] in
                                                                    (! minTag) < len) });
                                     (let i = ref 0 in
                                      (((assert { not (Rgn.mem (! dist) (Rgn.union s.pool (img_rep s s.pool))) });
                                        (assert {
                                           ((Rgn.mem (! dist) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                              ((not (Rgn.mem (! dist) (s.alloct.M.domain at INIT))) \/ ((! dist) = null))) /\
                                             true });
                                        (i := ([@expl:i := dist.{minTag}] A.get (s.heap.dSlots[! dist]) (! minTag)));
                                        (if ((! minKey) < (! i))
                                         then (((assert { not (Rgn.mem (! dist) (Rgn.union s.pool (img_rep s s.pool))) });
                                                (s.heap.dSlots <-
                                                   ([@expl:dist.{minTag} := minKey]
                                                    M.add (! dist) (A.set (s.heap.dSlots[! dist]) (! minTag) (! minKey)) s.heap.dSlots));
                                                (let eLen = ref 0 in
                                                 (let gEdges = ref (A.make 0 (any edge)) in
                                                  (((assert {
                                                       ((Rgn.mem (! queue) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                          ((not (Rgn.mem (! queue) (s.alloct.M.domain at INIT))) \/ ((! queue) = null))) /\
                                                         true });
                                                    (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                                                    (gEdges := ([@expl:gEdges := edges(g)] edges (! g)));
                                                    (eLen := ([@expl:eLen := length(gEdges)] A.length (! gEdges)));
                                                    (let i6 = ref 0 in
                                                     (while (0 <= (! i6))  && ((! i6) < (! eLen)) do
                                                        invariant {
                                                          [@expl:locals type invariant]
                                                          (hasDistArrayType s (! dist)) /\
                                                            ((hasNodeType s (! ins)) /\
                                                               ((hasNodeType s (! min)) /\
                                                                  ((hasPqueueType s (! queue)) /\ (hasDistArrayType s (! result))))) }
                                                        invariant { alloc_does_not_shrink (old s) s }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`slots]
                                                          wrs_to_slots_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({dist} union {queue} union {queue}`rep)`dSlots]
                                                          wrs_to_dSlots_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union
                                                                (singleton (! dist))
                                                                (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`sntl]
                                                          wrs_to_sntl_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`sibling]
                                                          wrs_to_sibling_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`prev]
                                                          wrs_to_prev_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`head]
                                                          wrs_to_head_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`child]
                                                          wrs_to_child_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`rep]
                                                          wrs_to_rep_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`tag]
                                                          wrs_to_tag_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`size]
                                                          wrs_to_size_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`length]
                                                          wrs_to_length_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({queue} union {queue}`rep)`key]
                                                          wrs_to_key_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union (singleton (! queue)) (s.heap.rep[! queue])) }
                                                        invariant {
                                                          [@expl:wr ({dist} union {queue} union {queue}`rep)`dLength]
                                                          wrs_to_dLength_framed_by
                                                            (old s)
                                                            s
                                                            (Rgn.union
                                                                (singleton (! dist))
                                                                (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))) }
                                                        invariant { PQUEUE.pqueuePub s }
                                                        invariant {
                                                          let oa = old s.alloct.M.domain in
                                                          Rgn.subset
                                                             (Rgn.diff
                                                                 (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))
                                                                 (singleton null))
                                                             (Rgn.diff s.alloct.M.domain oa) }
                                                        invariant {
                                                          let rep7 = s.heap.rep[! queue] in
                                                          forall n: reference.
                                                            (isAllocated s n) ->
                                                              ((hasNodeType s n) ->
                                                                 ((Rgn.mem n rep7) -> (let key8 = s.heap.key[n] in
                                                                    key8 >= 0))) }
                                                        invariant { (singleton (! dist)) \# (Rgn.union s.pool (img_rep s s.pool)) }
                                                        invariant {
                                                          let rep9 = s.heap.rep[! queue] in
                                                          forall n: reference.
                                                            (isAllocated s n) ->
                                                              ((hasNodeType s n) ->
                                                                 ((Rgn.mem n rep9) ->
                                                                    (
                                                                    let len = s.heap.dLength[! dist] in
                                                                    let tag10 = s.heap.tag[n] in
                                                                    (tag10 >= 0) /\ (tag10 < len)))) }
                                                        invariant { let rep11 = s.heap.rep[! queue] in
                                                                    Rgn.mem (! min) rep11 }
                                                        invariant {
                                                          let len = s.heap.dLength[! dist] in
                                                          forall k: int.
                                                            (0 <= k) ->
                                                              ((k < len) -> (let v = A.get (s.heap.dSlots[! dist]) k in
                                                                    0 <= v)) }
                                                        invariant {
                                                          ((! numVs) = (numVertices (! g))) /\ ((s.heap.dLength[! dist]) = (! numVs)) }
                                                        invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                                                        invariant { (0 <= (! i6)) /\ ((! i6) <= (! eLen)) }
                                                        let startV = ref 0 in
                                                        (let endV = ref 0 in
                                                         (let currWeight = ref 0 in
                                                          (let currEdge = ref (any edge) in
                                                           (((currEdge := ([@expl:currEdge := get(gEdges,i)] A.get (! gEdges) (! i6)));
                                                             (startV
                                                                := ([@expl:startV := startVertex(currEdge)] startVertex (! currEdge)));
                                                             (endV := ([@expl:endV := endVertex(currEdge)] endVertex (! currEdge)));
                                                             (currWeight
                                                                := ([@expl:currWeight := weight(currEdge)] weight (! currEdge)));
                                                             (let d = ref 0 in
                                                              (let candidateDist = ref 0 in
                                                               (((assert {
                                                                    not (Rgn.mem (! dist) (Rgn.union s.pool (img_rep s s.pool))) });
                                                                 (assert {
                                                                    ((Rgn.mem (! dist) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                                    ((not (Rgn.mem (! dist) (s.alloct.M.domain at INIT))) \/
                                                                    ((! dist) = null))) /\
                                                                    true });
                                                                 (d
                                                                    := (
                                                                    [@expl:d := dist.{startV}] 
                                                                    A.get (s.heap.dSlots[! dist]) (! startV)));
                                                                 (candidateDist
                                                                    := (
                                                                    [@expl:candidateDist := d + currWeight] (! d) + (! currWeight)));
                                                                 (assert {
                                                                    not (Rgn.mem (! dist) (Rgn.union s.pool (img_rep s s.pool))) });
                                                                 (assert {
                                                                    ((Rgn.mem (! dist) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                                    ((not (Rgn.mem (! dist) (s.alloct.M.domain at INIT))) \/
                                                                    ((! dist) = null))) /\
                                                                    true });
                                                                 (d
                                                                    := (
                                                                    [@expl:d := dist.{endV}] A.get (s.heap.dSlots[! dist]) (! endV)));
                                                                 (if ((! candidateDist) < (! d))
                                                                  then (
                                                                    ((
                                                                    assert { ((! candidateDist) >= 0) /\ ((! endV) >= 0) });
                                                                    (assert {
                                                                    (Rgn.subset
                                                                    (Rgn.diff
                                                                    (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))
                                                                    (singleton null))
                                                                    (Rgn.union
                                                                    ((Rgn.union s.pool (Rgn.union s.pool (img_rep s s.pool))) at INIT)
                                                                    (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                                                    ((Rgn.subset
                                                                    (Rgn.diff
                                                                    (Rgn.union (singleton (! queue)) (s.heap.rep[! queue]))
                                                                    (singleton null))
                                                                    (Rgn.union
                                                                    ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                                                    (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                                                    true) });
                                                                    (ins
                                                                    := (
                                                                    [@expl:ins := insert(queue,candidateDist,endV)]
                                                                    PQUEUE.insert s (! queue) (! candidateDist) (! endV)));
                                                                    (assert {
                                                                    not (Rgn.mem (! dist) (Rgn.union s.pool (img_rep s s.pool))) });
                                                                    (s.heap.dSlots <-
                                                                    ([@expl:dist.{endV} := candidateDist]
                                                                    M.add
                                                                    (! dist)
                                                                    (A.set (s.heap.dSlots[! dist]) (! endV) (! candidateDist))
                                                                    s.heap.dSlots))))
                                                                  else ());
                                                                 (i6 := ([@expl:i := i + 1] (! i6) + 1));
                                                                 (assert {
                                                                    ((Rgn.mem (! queue) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                                    ((not (Rgn.mem (! queue) (s.alloct.M.domain at INIT))) \/
                                                                    ((! queue) = null))) /\
                                                                    true });
                                                                 (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue))))))))))))
                                                      done))))))))
                                         else ());
                                        (assert {
                                           ((Rgn.mem (! queue) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                              ((not (Rgn.mem (! queue) (s.alloct.M.domain at INIT))) \/ ((! queue) = null))) /\
                                             true });
                                        (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)))))))
                                  done);
                                 (result := ([@expl:result := dist] ! dist));
                                 (! result))))))))))))))))))))))))))))
end

module Main_Link
  
  use prelude.Prelude
  use State
  use Main
  use PQUEUE_REL
  
  lemma pqueuePub_holds_in_main : forall l_s: state, r_s: state, pi: 
                                    PreRefperm.t.
                                    (okRefperm l_s r_s pi) ->
                                      (forall l_g: graph, r_g: graph.
                                         forall l_source: int, r_source: int.
                                           ((l_s.pool = emptyRgn) ->
                                              ((Main.PQUEUE.pqueuePub l_s) ->
                                                 ((Main.hasVertex l_g l_source) -> (Main.PQUEUE.pqueuePub l_s)))) /\
                                             ((r_s.pool = emptyRgn) ->
                                                ((Main.PQUEUE.pqueuePub r_s) ->
                                                   ((Main.hasVertex r_g r_source) -> (Main.PQUEUE.pqueuePub r_s)))))
  
  lemma left_pqueueI_holds_in_main : forall l_s: state, r_s: state, pi: 
                                       PreRefperm.t.
                                       (okRefperm l_s r_s pi) ->
                                         (forall l_g: graph, r_g: graph.
                                            forall l_source: int, r_source: int.
                                              (l_s.pool = emptyRgn) ->
                                                ((Main.PQUEUE.pqueuePub l_s) ->
                                                   ((Main.hasVertex l_g l_source) -> (PQUEUE_REL.PqueueL.pqueueI l_s))))
  
  lemma right_pqueueI_holds_in_main : forall l_s: state, r_s: state, pi: 
                                        PreRefperm.t.
                                        (okRefperm l_s r_s pi) ->
                                          (forall l_g: graph, r_g: graph.
                                             forall l_source: int, r_source: int.
                                               (r_s.pool = emptyRgn) ->
                                                 ((Main.PQUEUE.pqueuePub r_s) ->
                                                    ((Main.hasVertex r_g r_source) -> (PQUEUE_REL.PqueueR.pqueueI r_s))))
  
  lemma pqueueR_holds_in_main : forall l_s: state, r_s: state, pi: PreRefperm.t.
                                  (okRefperm l_s r_s pi) ->
                                    (forall l_g: graph, r_g: graph.
                                       forall l_source: int, r_source: int.
                                         ((l_s.pool = emptyRgn) /\ (r_s.pool = emptyRgn)) ->
                                           (((Main.PQUEUE.pqueuePub l_s) /\ (Main.PQUEUE.pqueuePub r_s)) ->
                                              (((Main.hasVertex l_g l_source) /\ (Main.hasVertex r_g r_source)) ->
                                                 ((l_g = r_g) ->
                                                    ((l_source = r_source) ->
                                                       (((agree_dLength
                                                            l_s
                                                            r_s
                                                            pi
                                                            (Rgn.diff
                                                                (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                           (agree_dLength
                                                              r_s
                                                              l_s
                                                              (PreRefperm.invert pi)
                                                              (Rgn.diff
                                                                  (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                  (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                          (((agree_key
                                                               l_s
                                                               r_s
                                                               pi
                                                               (Rgn.diff
                                                                   (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                   (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                              (agree_key
                                                                 r_s
                                                                 l_s
                                                                 (PreRefperm.invert pi)
                                                                 (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                             (((agree_length
                                                                  l_s
                                                                  r_s
                                                                  pi
                                                                  (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                 (agree_length
                                                                    r_s
                                                                    l_s
                                                                    (
                                                                    PreRefperm.invert pi)
                                                                    (
                                                                    Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                (((agree_size
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (
                                                                    agree_size
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                   (((agree_tag
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_tag
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_rep
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (Rgn.union l_s.pool (img_rep l_s l_s.pool)))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_rep
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (Rgn.union r_s.pool (img_rep r_s r_s.pool)))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_child
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_child
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_head
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_head
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_prev
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_prev
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_sibling
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_sibling
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_sntl
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_sntl
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_dSlots
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_dSlots
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_slots
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_slots
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (pqueueR l_s r_s pi)))))))))))))))))))
  
  val main (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_g: graph) (l_source: int) (r_g: graph) (r_source: int) : 
    (reference,
     reference)
    requires { okRefperm l_s r_s pi }
    requires { (agree_slots
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_slots
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_dSlots
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dSlots
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_sntl
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_sntl
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_sibling
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_sibling
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_prev
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_prev
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_head
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_head
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_child
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_child
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_rep
                  l_s
                  r_s
                  pi
                  (Rgn.diff
                      (Rgn.union l_s.pool (Rgn.union l_s.pool (img_rep l_s l_s.pool)))
                      (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_rep
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff
                        (Rgn.union r_s.pool (Rgn.union r_s.pool (img_rep r_s r_s.pool)))
                        (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_tag l_s r_s pi (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_tag
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_size
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_size
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_length
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_length
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_key l_s r_s pi (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_key
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_dLength
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dLength
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { l_source = r_source }
    requires { l_g = r_g }
    requires { (Main.hasVertex l_g l_source) /\ (Main.hasVertex r_g r_source) }
    requires { (Main.PQUEUE.pqueuePub l_s) /\ (Main.PQUEUE.pqueuePub r_s) }
    requires { (l_s.pool = emptyRgn) /\ (r_s.pool = emptyRgn) }
    writes { l_s.heap.slots }
    writes { l_s.heap.dSlots }
    writes { l_s.heap.sntl }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.head }
    writes { l_s.heap.child }
    writes { l_s.heap.rep }
    writes { l_s.heap.tag }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.key }
    writes { l_s.heap.dLength }
    writes { l_s.pool }
    writes { l_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.dSlots }
    writes { r_s.heap.sntl }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.head }
    writes { r_s.heap.child }
    writes { r_s.heap.rep }
    writes { r_s.heap.tag }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.key }
    writes { r_s.heap.dLength }
    writes { r_s.pool }
    writes { r_s.alloct }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`dSlots] wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`sntl] wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`prev] wrs_to_prev_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`head] wrs_to_head_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`child] wrs_to_child_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union l_s.pool (Rgn.union l_s.pool (img_rep l_s l_s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`tag] wrs_to_tag_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`size] wrs_to_size_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`key] wrs_to_key_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`dSlots] wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`sntl] wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`prev] wrs_to_prev_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`head] wrs_to_head_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`child] wrs_to_child_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union r_s.pool (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`tag] wrs_to_tag_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`size] wrs_to_size_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`key] wrs_to_key_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { let l_s_alloc0 = old l_s.alloct.M.domain in
              let r_s_alloc0 = old r_s.alloct.M.domain in
              let l_snap_r13 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
              let r_snap_r13 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
              let l_snap_r8 = old (Rgn.union l_s.pool (Rgn.union l_s.pool (img_rep l_s l_s.pool))) in
              let r_snap_r8 = old (Rgn.union r_s.pool (Rgn.union r_s.pool (img_rep r_s r_s.pool))) in
              ((agree_dLength l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                (((agree_key l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                    (agree_key r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                   (((agree_length l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                       (agree_length r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                      (((agree_size l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                          (agree_size r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                         (((agree_tag l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                             (agree_tag
                                r_s
                                l_s
                                (PreRefperm.invert pi)
                                (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                            (((agree_rep l_s r_s pi (Rgn.diff l_snap_r8 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                (agree_rep
                                   r_s
                                   l_s
                                   (PreRefperm.invert pi)
                                   (Rgn.diff r_snap_r8 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                               (((agree_child l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                   (agree_child
                                      r_s
                                      l_s
                                      (PreRefperm.invert pi)
                                      (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                  (((agree_head l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                      (agree_head
                                         r_s
                                         l_s
                                         (PreRefperm.invert pi)
                                         (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                     (((agree_prev l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                         (agree_prev
                                            r_s
                                            l_s
                                            (PreRefperm.invert pi)
                                            (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                        (((agree_sibling l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                            (agree_sibling
                                               r_s
                                               l_s
                                               (PreRefperm.invert pi)
                                               (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                           (((agree_sntl l_s r_s pi (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                               (agree_sntl
                                                  r_s
                                                  l_s
                                                  (PreRefperm.invert pi)
                                                  (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                              (((agree_dSlots
                                                   l_s
                                                   r_s
                                                   pi
                                                   (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                  (agree_dSlots
                                                     r_s
                                                     l_s
                                                     (PreRefperm.invert pi)
                                                     (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                                 (((agree_slots
                                                      l_s
                                                      r_s
                                                      pi
                                                      (Rgn.diff l_snap_r13 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                     (agree_slots
                                                        r_s
                                                        l_s
                                                        (PreRefperm.invert pi)
                                                        (Rgn.diff r_snap_r13 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                                    ((agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc0)) /\
                                                       (agree_allfields
                                                          r_s
                                                          l_s
                                                          (PreRefperm.invert pi)
                                                          (Rgn.diff r_s.alloct.M.domain r_s_alloc0))))))))))))))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val initDistances (l_s: state) (r_s: state) (pi12: PreRefperm.t) (l_d: reference) (l_k: int) (r_d: reference) (r_k: int) : 
    (unit,
     unit)
    requires { hasDistArrayType l_s l_d }
    requires { l_d <> null }
    requires { hasDistArrayType r_s r_d }
    requires { r_d <> null }
    requires { okRefperm l_s r_s pi12 }
    requires { (agree_dSlots l_s r_s pi12 (Rgn.diff (singleton l_d) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dSlots r_s l_s (PreRefperm.invert pi12) (Rgn.diff (singleton r_d) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_dLength l_s r_s pi12 (Rgn.diff (singleton l_d) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dLength r_s l_s (PreRefperm.invert pi12) (Rgn.diff (singleton r_d) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (l_k >= 0) /\ (r_k >= 0) }
    writes { l_s.heap.dSlots }
    writes { r_s.heap.dSlots }
    ensures { [@expl:wr {d}`dSlots] wrs_to_dSlots_framed_by (old l_s) l_s (singleton l_d) }
    ensures { [@expl:wr {d}`dSlots] wrs_to_dSlots_framed_by (old r_s) r_s (singleton r_d) }
    ensures { okRefperm l_s r_s pi12 }
    ensures { (let len = l_s.heap.dLength[l_d] in
               forall i: int. (0 <= i) -> ((i < len) -> ((A.get (l_s.heap.dSlots[l_d]) i) = l_k))) /\
                (let len = r_s.heap.dLength[r_d] in
                 forall i: int. (0 <= i) -> ((i < len) -> ((A.get (r_s.heap.dSlots[r_d]) i) = r_k))) }
    ensures { let l_s_alloc14 = old l_s.alloct.M.domain in
              let r_s_alloc14 = old r_s.alloct.M.domain in
              let l_d15 = old (singleton l_d) in
              let r_d15 = old (singleton r_d) in
              ((agree_dSlots l_s r_s pi12 (Rgn.diff l_d15 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_dSlots r_s l_s (PreRefperm.invert pi12) (Rgn.diff r_d15 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                ((agree_allfields l_s r_s pi12 (Rgn.diff l_s.alloct.M.domain l_s_alloc14)) /\
                   (agree_allfields r_s l_s (PreRefperm.invert pi12) (Rgn.diff r_s.alloct.M.domain r_s_alloc14))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
end

module PQUEUE_REL_biinterface
  
  use prelude.Prelude
  use State
  use PqueueL
  use PqueueR
  
  predicate coupling0 (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_pq: reference) (r_pq: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasPqueueType l_s l_pq) ->
         ((hasPqueueType r_s r_pq) ->
            (((l_pq <> null) /\ (r_pq <> null)) ->
               ((PreRefperm.idRef pi l_pq r_pq) ->
                  (let l_sntl = l_s.heap.sntl[l_pq] in
                   let r_sntl = r_s.heap.sntl[r_pq] in
                   let l_rep = l_s.heap.rep[l_pq] in
                   let r_rep = r_s.heap.rep[r_pq] in
                   let l_hd = l_s.heap.head[l_pq] in
                   let r_hd = r_s.heap.head[r_pq] in
                   let l_sz = l_s.heap.size[l_pq] in
                   let r_sz = r_s.heap.size[r_pq] in
                   (l_sz = r_sz) /\
                     (((PreRefperm.idRef pi l_hd r_hd) \/ ((l_hd = null) /\ (r_hd = r_sntl))) /\
                        ((PreRefperm.idRgn pi (rgnSubK l_rep l_s.alloct Node) (rgnSubK r_rep r_s.alloct Node)) /\
                           (forall l_n: reference, r_n: reference.
                              (isAllocated l_s l_n) ->
                                ((hasNodeType l_s l_n) ->
                                   ((Rgn.mem l_n l_rep) ->
                                      ((isAllocated r_s r_n) ->
                                         ((hasNodeType r_s r_n) ->
                                            ((Rgn.mem r_n r_rep) ->
                                               ((PreRefperm.idRef pi l_n r_n) ->
                                                  (let l_k = l_s.heap.key[l_n] in
                                                   let r_k = r_s.heap.key[r_n] in
                                                   let l_t = l_s.heap.tag[l_n] in
                                                   let r_t = r_s.heap.tag[r_n] in
                                                   let l_pre = l_s.heap.prev[l_n] in
                                                   let r_pre = r_s.heap.prev[r_n] in
                                                   let l_sib = l_s.heap.sibling[l_n] in
                                                   let r_sib = r_s.heap.sibling[r_n] in
                                                   let l_chl = l_s.heap.child[l_n] in
                                                   let r_chl = r_s.heap.child[r_n] in
                                                   (l_k = r_k) /\
                                                     ((l_t = r_t) /\
                                                        ((((PreRefperm.idRef pi l_pre r_pre) /\ ((l_pre <> null) /\ (r_pre <> r_sntl))) \/
                                                            ((l_pre = null) /\ (r_pre = r_sntl))) /\
                                                           ((((PreRefperm.idRef pi l_sib r_sib) /\
                                                                ((l_sib <> null) /\ (r_sib <> r_sntl))) \/
                                                               ((l_sib = null) /\ (r_sib = r_sntl))) /\
                                                              (((PreRefperm.idRef pi l_chl r_chl) /\
                                                                  ((l_chl <> null) /\ (r_chl <> r_sntl))) \/
                                                                 ((l_chl = null) /\ (r_chl = r_sntl)))))))))))))))))))))
  
  val isEmpty (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (agree_size l_s r_s pi (singleton l_self)) /\ (agree_size r_s l_s (PreRefperm.invert pi) (singleton r_self)) }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
  
  val findMin (l_s: state) (r_s: state) (pi13: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi13 }
    requires { true /\ true }
    requires { PreRefperm.idRef pi13 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi13 }
    ensures { true /\ true }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi13 l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let hd = l_s.heap.head[l_self] in
                      l_result = hd) /\ (let hd = r_s.heap.head[r_self] in
                                         r_result = hd))
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi13 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi13) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val insert (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (l_t: int) (r_self: reference) (r_k: int) (r_t: int) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { l_t = r_t }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    requires { (0 <= l_t) /\ (0 <= r_t) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    writes { l_s.heap.slots }
    writes { l_s.heap.dSlots }
    writes { l_s.heap.sntl }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.head }
    writes { l_s.heap.child }
    writes { l_s.heap.rep }
    writes { l_s.heap.tag }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.key }
    writes { l_s.heap.dLength }
    writes { l_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.dSlots }
    writes { r_s.heap.sntl }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.head }
    writes { r_s.heap.child }
    writes { r_s.heap.rep }
    writes { r_s.heap.tag }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.key }
    writes { r_s.heap.dLength }
    writes { r_s.alloct }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr {self}`rep`tag] wrs_to_tag_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`key] wrs_to_key_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old l_s) l_s (l_s.heap.rep[l_self]) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr {self}`rep`slots] wrs_to_slots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`dSlots] wrs_to_dSlots_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sntl] wrs_to_sntl_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`sibling] wrs_to_sibling_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`prev] wrs_to_prev_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr {self}`rep`child] wrs_to_child_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr {self}`rep`tag] wrs_to_tag_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr {self}`rep`length] wrs_to_length_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`key] wrs_to_key_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { [@expl:wr {self}`rep`dLength] wrs_to_dLength_framed_by (old r_s) r_s (r_s.heap.rep[r_self]) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep14 = l_s.heap.rep[l_self] in
                      forall n: reference.
                        (isAllocated l_s n) ->
                          ((hasNodeType l_s n) ->
                             ((Rgn.mem n rep14) ->
                                ((n <> l_result) ->
                                   (let ot = old (l_s.heap.tag[n]) in
                                    let ok = old (l_s.heap.key[n]) in
                                    ((l_s.heap.tag[n]) = ot) /\ ((l_s.heap.key[n]) = ok)))))) /\
                       (let rep15 = r_s.heap.rep[r_self] in
                        forall n: reference.
                          (isAllocated r_s n) ->
                            ((hasNodeType r_s n) ->
                               ((Rgn.mem n rep15) ->
                                  ((n <> r_result) ->
                                     (let ot = old (r_s.heap.tag[n]) in
                                      let ok = old (r_s.heap.key[n]) in
                                      ((r_s.heap.tag[n]) = ot) /\ ((r_s.heap.key[n]) = ok)))))))
              end }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.tag[l_result]) = l_t) /\ ((r_s.heap.tag[r_result]) = r_t)) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.key[l_result]) = l_k) /\ ((r_s.heap.key[r_result]) = r_k)) end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let orep = old (l_s.heap.rep[l_self]) in
                      (l_s.heap.rep[l_self]) = (Rgn.union orep (singleton l_result))) /\
                       (let orep = old (r_s.heap.rep[r_self]) in
                        (r_s.heap.rep[r_self]) = (Rgn.union orep (singleton r_result))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep16 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep16) /\
                       (let rep17 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep17))
              end }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val deleteMin (l_s: state) (r_s: state) (pi18: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi18 }
    requires { true /\ true }
    requires { PreRefperm.idRef pi18 l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.slots }
    writes { l_s.heap.dSlots }
    writes { l_s.heap.sntl }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.head }
    writes { l_s.heap.child }
    writes { l_s.heap.rep }
    writes { l_s.heap.tag }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.key }
    writes { l_s.heap.dLength }
    writes { l_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.dSlots }
    writes { r_s.heap.sntl }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.head }
    writes { r_s.heap.child }
    writes { r_s.heap.rep }
    writes { r_s.heap.tag }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.key }
    writes { r_s.heap.dLength }
    writes { r_s.alloct }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi18 }
    ensures { true /\ true }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { (let rep19 = l_s.heap.rep[l_self] in
               forall n: reference.
                 (isAllocated l_s n) ->
                   ((hasNodeType l_s n) ->
                      ((Rgn.mem n rep19) ->
                         (let otag = old (l_s.heap.tag[n]) in
                          let okey = old (l_s.heap.key[n]) in
                          ((l_s.heap.tag[n]) = otag) /\ ((l_s.heap.key[n]) = okey))))) /\
                (let rep20 = r_s.heap.rep[r_self] in
                 forall n: reference.
                   (isAllocated r_s n) ->
                     ((hasNodeType r_s n) ->
                        ((Rgn.mem n rep20) ->
                           (let otag = old (r_s.heap.tag[n]) in
                            let okey = old (r_s.heap.key[n]) in
                            ((r_s.heap.tag[n]) = otag) /\ ((r_s.heap.key[n]) = okey))))) }
    ensures { (let orep = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = orep) /\
                (let orep = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = orep) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi18 l_result r_result) end }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val decreaseKey (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (l_k: int) (r_self: reference) (r_handle: reference) (r_k: int) : 
    (unit,
     unit)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (let key21 = l_s.heap.key[l_handle] in
                l_k <= key21) /\ (let key22 = r_s.heap.key[r_handle] in
                                  r_k <= key22) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    requires { (let rep23 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep23) /\
                 (let rep24 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep24) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.slots }
    writes { l_s.heap.dSlots }
    writes { l_s.heap.sntl }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.head }
    writes { l_s.heap.child }
    writes { l_s.heap.rep }
    writes { l_s.heap.tag }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.key }
    writes { l_s.heap.dLength }
    writes { r_s.heap.slots }
    writes { r_s.heap.dSlots }
    writes { r_s.heap.sntl }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.head }
    writes { r_s.heap.child }
    writes { r_s.heap.rep }
    writes { r_s.heap.tag }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.key }
    writes { r_s.heap.dLength }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dSlots]
              wrs_to_dSlots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sntl]
              wrs_to_sntl_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`sibling]
              wrs_to_sibling_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`prev]
              wrs_to_prev_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`child]
              wrs_to_child_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`tag]
              wrs_to_tag_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`key]
              wrs_to_key_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`dLength]
              wrs_to_dLength_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { (PqueueL.pqueueI l_s) /\ (PqueueR.pqueueI r_s) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s) /\ (PqueueR.PQUEUE.pqueuePub r_s) }
    ensures { ((l_s.heap.key[l_handle]) = l_k) /\ ((r_s.heap.key[r_handle]) = r_k) }
    ensures { (let bsnap_r14 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r14 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r14 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r14 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
end

