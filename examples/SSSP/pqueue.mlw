module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
    | Bag
    | BagArray
    | DistArray
    | Edge
    | EdgeArray
    | Graph
    | Node
    | NodeArray
    | Pqueue
  
  type heap = {
    mutable sntl : M.t reference ;
    mutable ghost rep : M.t rgn ;
    mutable size : M.t int ;
    mutable head : M.t reference ;
    mutable slots : M.t (A.array reference) ;
    mutable length : M.t int ;
    mutable child : M.t reference ;
    mutable sibling : M.t reference ;
    mutable prev : M.t reference ;
    mutable key : M.t int ;
    mutable tag : M.t int ;
    mutable numVerts : M.t int ;
    mutable adjList : M.t reference ;
    mutable eLength : M.t int ;
    mutable eSlots : M.t (A.array reference) ;
    mutable strv : M.t int ;
    mutable endv : M.t int ;
    mutable wght : M.t int ;
    mutable dLength : M.t int ;
    mutable dSlots : M.t (A.array int) ;
    mutable bLength : M.t int ;
    mutable bSlots : M.t (A.array reference) ;
    mutable bagNode : M.t int ;
    mutable bagEdges : M.t reference
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Bag) ->
           (((p \: heap.bagNode) /\ (p \: heap.bagEdges)) /\
              (((heap.bagEdges[p]) = null) \/ (((heap.bagEdges[p]) \: alloct) /\ ((alloct[heap.bagEdges[p]]) = EdgeArray))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = BagArray) ->
           (((p \: heap.bLength) /\ (p \: heap.bSlots)) /\
              (((heap.bLength[p]) = (A.length (heap.bSlots[p]))) /\
                 (((heap.bLength[p]) >= 0) /\
                    (let arr = heap.bSlots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr)) -> (let v = A.get arr i in
                                                   (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Bag))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = DistArray) ->
           (((p \: heap.dLength) /\ (p \: heap.dSlots)) /\
              (((heap.dLength[p]) >= 0) /\ ((heap.dLength[p]) = (A.length (heap.dSlots[p])))))) }
  invariant {
    forall p: reference. (p \: alloct) -> (((alloct[p]) = Edge) -> ((p \: heap.endv) /\ ((p \: heap.strv) /\ (p \: heap.wght)))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = EdgeArray) ->
           (((p \: heap.eLength) /\ (p \: heap.eSlots)) /\
              (((heap.eLength[p]) = (A.length (heap.eSlots[p]))) /\
                 (((heap.eLength[p]) >= 0) /\
                    (let arr = heap.eSlots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr)) -> (let v = A.get arr i in
                                                   (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Edge))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Graph) ->
           (((p \: heap.numVerts) /\ (p \: heap.adjList)) /\
              (((heap.adjList[p]) = null) \/ (((heap.adjList[p]) \: alloct) /\ ((alloct[heap.adjList[p]]) = BagArray))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.key) /\ ((p \: heap.prev) /\ ((p \: heap.sibling) /\ ((p \: heap.child) /\ (p \: heap.tag))))) /\
              ((((heap.sibling[p]) = null) \/ (((heap.sibling[p]) \: alloct) /\ ((alloct[heap.sibling[p]]) = Node))) /\
                 ((((heap.child[p]) = null) \/ (((heap.child[p]) \: alloct) /\ ((alloct[heap.child[p]]) = Node))) /\
                    (((heap.prev[p]) = null) \/ (((heap.prev[p]) \: alloct) /\ ((alloct[heap.prev[p]]) = Node))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = NodeArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\
              (((heap.length[p]) = (A.length (heap.slots[p]))) /\
                 (((heap.length[p]) >= 0) /\
                    (let arr = heap.slots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr)) -> (let v = A.get arr i in
                                                   (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Node))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Pqueue) ->
           (((p \: heap.size) /\ ((p \: heap.rep) /\ ((p \: heap.sntl) /\ (p \: heap.head)))) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 ((((heap.sntl[p]) = null) \/ (((heap.sntl[p]) \: alloct) /\ ((alloct[heap.sntl[p]]) = Node))) /\
                    (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct))))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate typeofRgn (s: state) (r: rgn) (t: reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = t)))
  
  predicate hasBagType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Bag))
  
  predicate hasBagArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = BagArray))
  
  predicate hasDistArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = DistArray))
  
  predicate hasEdgeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Edge))
  
  predicate hasEdgeArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = EdgeArray))
  
  predicate hasGraphType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Graph))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasNodeArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = NodeArray))
  
  predicate hasPqueueType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Pqueue))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_Bag (s: state) : reference
    writes { s.alloct }
    writes { s.heap.bagNode }
    writes { s.heap.bagEdges }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Bag (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasBagType s result }
    ensures { s.heap.bagNode = (M.add result 0 (old s.heap.bagNode)) }
    ensures { s.heap.bagEdges = (M.add result null (old s.heap.bagEdges)) }
  
  val mk_BagArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.bLength }
    writes { s.heap.bSlots }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result BagArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasBagArrayType s result }
    ensures { s.heap.bLength = (M.add result 0 (old s.heap.bLength)) }
    ensures { s.heap.bSlots = (M.add result (A.make 0 null) (old s.heap.bSlots)) }
  
  val mk_DistArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result DistArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { s.heap.dLength = (M.add result 0 (old s.heap.dLength)) }
    ensures { s.heap.dSlots = (M.add result (A.make 0 0) (old s.heap.dSlots)) }
  
  val mk_Edge (s: state) : reference
    writes { s.alloct }
    writes { s.heap.strv }
    writes { s.heap.endv }
    writes { s.heap.wght }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Edge (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasEdgeType s result }
    ensures { s.heap.strv = (M.add result 0 (old s.heap.strv)) }
    ensures { s.heap.endv = (M.add result 0 (old s.heap.endv)) }
    ensures { s.heap.wght = (M.add result 0 (old s.heap.wght)) }
  
  val mk_EdgeArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.eLength }
    writes { s.heap.eSlots }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result EdgeArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasEdgeArrayType s result }
    ensures { s.heap.eLength = (M.add result 0 (old s.heap.eLength)) }
    ensures { s.heap.eSlots = (M.add result (A.make 0 null) (old s.heap.eSlots)) }
  
  val mk_Graph (s: state) : reference
    writes { s.alloct }
    writes { s.heap.numVerts }
    writes { s.heap.adjList }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Graph (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasGraphType s result }
    ensures { s.heap.numVerts = (M.add result 0 (old s.heap.numVerts)) }
    ensures { s.heap.adjList = (M.add result null (old s.heap.adjList)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.child = (M.add result null (old s.heap.child)) }
    ensures { s.heap.sibling = (M.add result null (old s.heap.sibling)) }
    ensures { s.heap.prev = (M.add result null (old s.heap.prev)) }
    ensures { s.heap.key = (M.add result 0 (old s.heap.key)) }
    ensures { s.heap.tag = (M.add result 0 (old s.heap.tag)) }
  
  val mk_NodeArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result NodeArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 null) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_Pqueue (s: state) : reference
    writes { s.alloct }
    writes { s.heap.sntl }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.head }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Pqueue (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasPqueueType s result }
    ensures { s.heap.sntl = (M.add result null (old s.heap.sntl)) }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.size = (M.add result 0 (old s.heap.size)) }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
  
  function img_wght : state -> (rgn -> rgn)
  
  axiom img_wght_ax : forall s: state, r: rgn. (img_wght s r) = emptyRgn
  
  function img_tag : state -> (rgn -> rgn)
  
  axiom img_tag_ax : forall s: state, r: rgn. (img_tag s r) = emptyRgn
  
  function img_strv : state -> (rgn -> rgn)
  
  axiom img_strv_ax : forall s: state, r: rgn. (img_strv s r) = emptyRgn
  
  function img_sntl : state -> (rgn -> rgn)
  
  axiom img_sntl_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_sntl s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.sntl[q])))))
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn. (img_slots s r) = emptyRgn
  
  function img_size : state -> (rgn -> rgn)
  
  axiom img_size_ax : forall s: state, r: rgn. (img_size s r) = emptyRgn
  
  function img_sibling : state -> (rgn -> rgn)
  
  axiom img_sibling_ax : forall s: state, r: rgn, p: reference.
                           (Rgn.mem p (img_sibling s r)) <->
                             (exists q: reference.
                                (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.sibling[q])))))
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_prev : state -> (rgn -> rgn)
  
  axiom img_prev_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_prev s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.prev[q])))))
  
  function img_numVerts : state -> (rgn -> rgn)
  
  axiom img_numVerts_ax : forall s: state, r: rgn. (img_numVerts s r) = emptyRgn
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_key : state -> (rgn -> rgn)
  
  axiom img_key_ax : forall s: state, r: rgn. (img_key s r) = emptyRgn
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Pqueue) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  function img_endv : state -> (rgn -> rgn)
  
  axiom img_endv_ax : forall s: state, r: rgn. (img_endv s r) = emptyRgn
  
  function img_eSlots : state -> (rgn -> rgn)
  
  axiom img_eSlots_ax : forall s: state, r: rgn. (img_eSlots s r) = emptyRgn
  
  function img_eLength : state -> (rgn -> rgn)
  
  axiom img_eLength_ax : forall s: state, r: rgn. (img_eLength s r) = emptyRgn
  
  function img_dSlots : state -> (rgn -> rgn)
  
  axiom img_dSlots_ax : forall s: state, r: rgn. (img_dSlots s r) = emptyRgn
  
  function img_dLength : state -> (rgn -> rgn)
  
  axiom img_dLength_ax : forall s: state, r: rgn. (img_dLength s r) = emptyRgn
  
  function img_child : state -> (rgn -> rgn)
  
  axiom img_child_ax : forall s: state, r: rgn, p: reference.
                         (Rgn.mem p (img_child s r)) <->
                           (exists q: reference.
                              (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.child[q])))))
  
  function img_bagNode : state -> (rgn -> rgn)
  
  axiom img_bagNode_ax : forall s: state, r: rgn. (img_bagNode s r) = emptyRgn
  
  function img_bagEdges : state -> (rgn -> rgn)
  
  axiom img_bagEdges_ax : forall s: state, r: rgn, p: reference.
                            (Rgn.mem p (img_bagEdges s r)) <->
                              (exists q: reference.
                                 (q \: s.alloct) /\ (((s.alloct[q]) = Bag) /\ ((Rgn.mem q r) /\ (p = (s.heap.bagEdges[q])))))
  
  function img_bSlots : state -> (rgn -> rgn)
  
  axiom img_bSlots_ax : forall s: state, r: rgn. (img_bSlots s r) = emptyRgn
  
  function img_bLength : state -> (rgn -> rgn)
  
  axiom img_bLength_ax : forall s: state, r: rgn. (img_bLength s r) = emptyRgn
  
  function img_adjList : state -> (rgn -> rgn)
  
  axiom img_adjList_ax : forall s: state, r: rgn, p: reference.
                           (Rgn.mem p (img_adjList s r)) <->
                             (exists q: reference.
                                (q \: s.alloct) /\ (((s.alloct[q]) = Graph) /\ ((Rgn.mem q r) /\ (p = (s.heap.adjList[q])))))
  
  predicate agree_wght (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasEdgeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.wght[o]) = (sr.heap.wght[pi.lor[o]]))))))
  
  predicate agree_tag (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.tag[o]) = (sr.heap.tag[pi.lor[o]]))))))
  
  predicate agree_strv (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasEdgeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.strv[o]) = (sr.heap.strv[pi.lor[o]]))))))
  
  predicate agree_sntl (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sntl[o]) (sr.heap.sntl[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_size (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.size[o]) = (sr.heap.size[pi.lor[o]]))))))
  
  predicate agree_sibling (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.sibling[o]) (sr.heap.sibling[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_prev (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.prev[o]) (sr.heap.prev[pi.lor[o]]))))))
  
  predicate agree_numVerts (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasGraphType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.numVerts[o]) = (sr.heap.numVerts[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_key (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.key[o]) = (sr.heap.key[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasPqueueType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_endv (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasEdgeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.endv[o]) = (sr.heap.endv[pi.lor[o]]))))))
  
  predicate agree_eSlots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasEdgeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.eSlots[o]) = (sr.heap.eSlots[pi.lor[o]]))))))
  
  predicate agree_eLength (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasEdgeArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.eLength[o]) = (sr.heap.eLength[pi.lor[o]]))))))
  
  predicate agree_dSlots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dSlots[o]) = (sr.heap.dSlots[pi.lor[o]]))))))
  
  predicate agree_dLength (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasDistArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.dLength[o]) = (sr.heap.dLength[pi.lor[o]]))))))
  
  predicate agree_child (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.child[o]) (sr.heap.child[pi.lor[o]]))))))
  
  predicate agree_bagNode (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasBagType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.bagNode[o]) = (sr.heap.bagNode[pi.lor[o]]))))))
  
  predicate agree_bagEdges (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasBagType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.bagEdges[o]) (sr.heap.bagEdges[pi.lor[o]]))))))
  
  predicate agree_bSlots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasBagArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.bSlots[o]) = (sr.heap.bSlots[pi.lor[o]]))))))
  
  predicate agree_bLength (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasBagArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.bLength[o]) = (sr.heap.bLength[pi.lor[o]]))))))
  
  predicate agree_adjList (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasGraphType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.adjList[o]) (sr.heap.adjList[pi.lor[o]]))))))
end
module PQUEUE
  
  use prelude.Prelude
  use State
  
  predicate pqueuePub (s: state) (pl: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p pl) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q pl) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> (Rgn.subset (Rgn.inter prep qrep) (singleton null))))))))
  
  val init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    writes { s.heap.tag }
    writes { s.heap.key }
    writes { s.alloct }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
  
  val init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { pqueuePub s s.pool }
    requires { not (Rgn.mem self s.pool) }
    writes { s.heap.slots }
    writes { s.heap.eSlots }
    writes { s.heap.bSlots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.bagEdges }
    writes { s.heap.adjList }
    writes { s.heap.rep }
    writes { s.heap.wght }
    writes { s.heap.tag }
    writes { s.heap.strv }
    writes { s.heap.size }
    writes { s.heap.numVerts }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.endv }
    writes { s.heap.eLength }
    writes { s.heap.dLength }
    writes { s.heap.bagNode }
    writes { s.heap.bLength }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { Rgn.mem self s.pool }
    ensures { pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
  
  val isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s s.pool }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { pqueuePub s s.pool }
  
  val findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s s.pool }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { pqueuePub s s.pool }
    ensures { let hd = s.heap.head[self] in
              result = hd }
  
  val insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { pqueuePub s s.pool }
    writes { s.heap.slots }
    writes { s.heap.eSlots }
    writes { s.heap.bSlots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.bagEdges }
    writes { s.heap.adjList }
    writes { s.heap.rep }
    writes { s.heap.wght }
    writes { s.heap.tag }
    writes { s.heap.strv }
    writes { s.heap.size }
    writes { s.heap.numVerts }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.endv }
    writes { s.heap.eLength }
    writes { s.heap.dLength }
    writes { s.heap.bagNode }
    writes { s.heap.bLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
  
  val deleteMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { pqueuePub s s.pool }
    writes { s.heap.slots }
    writes { s.heap.eSlots }
    writes { s.heap.bSlots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.bagEdges }
    writes { s.heap.adjList }
    writes { s.heap.rep }
    writes { s.heap.wght }
    writes { s.heap.tag }
    writes { s.heap.strv }
    writes { s.heap.size }
    writes { s.heap.numVerts }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.endv }
    writes { s.heap.eLength }
    writes { s.heap.dLength }
    writes { s.heap.bagNode }
    writes { s.heap.bLength }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { pqueuePub s s.pool }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
  
  val decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { pqueuePub s s.pool }
    writes { s.heap.slots }
    writes { s.heap.eSlots }
    writes { s.heap.bSlots }
    writes { s.heap.dSlots }
    writes { s.heap.sntl }
    writes { s.heap.sibling }
    writes { s.heap.prev }
    writes { s.heap.head }
    writes { s.heap.child }
    writes { s.heap.bagEdges }
    writes { s.heap.adjList }
    writes { s.heap.rep }
    writes { s.heap.wght }
    writes { s.heap.tag }
    writes { s.heap.strv }
    writes { s.heap.size }
    writes { s.heap.numVerts }
    writes { s.heap.length }
    writes { s.heap.key }
    writes { s.heap.endv }
    writes { s.heap.eLength }
    writes { s.heap.dLength }
    writes { s.heap.bagNode }
    writes { s.heap.bLength }
    ensures { result = () }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { pqueuePub s s.pool }
    ensures { (s.heap.key[handle]) = k }
end

module PqueueL
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repClosed (s: state) (rep1: rgn) =
    (typeofRgn s rep1 Node) /\
      ((Rgn.mem null rep1) /\
         ((Rgn.subset (img_sibling s rep1) rep1) /\ ((Rgn.subset (img_child s rep1) rep1) /\ (Rgn.subset (img_prev s rep1) rep1))))
  
  lemma repClosed_DEF : forall s: state.
                          forall r: rgn.
                            (repClosed s r) <->
                              ((typeofRgn s r Node) /\
                                 ((Rgn.mem null r) /\
                                    (forall n: reference.
                                       (isAllocated s n) ->
                                         ((hasNodeType s n) ->
                                            ((Rgn.mem n r) ->
                                               (let sib = s.heap.sibling[n] in
                                                let pre = s.heap.prev[n] in
                                                let chl = s.heap.child[n] in
                                                (Rgn.mem sib r) /\ ((Rgn.mem pre r) /\ (Rgn.mem chl r))))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = (singleton null))))))))
  
  predicate pqueueI (s: state) (r: rgn) =
    forall p: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              (let rep1 = s.heap.rep[p] in
               let sz = s.heap.size[p] in
               let hd = s.heap.head[p] in
               (repClosed s rep1) /\
                 ((sz >= 0) /\ ((Rgn.mem hd rep1) /\ (((sz = 0) <-> (hd = null)) /\ ((nodeP s rep1) /\ (strongDisjoint s r))))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p r) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q r) ->
                                               ((pqueueI s r) ->
                                                  ((Rgn.mem p r) ->
                                                     ((Rgn.mem q r) ->
                                                        ((p <> q) ->
                                                           (let prep = s.heap.rep[p] in
                                                            let qrep = s.heap.rep[q] in
                                                            forall n: reference.
                                                              (isAllocated s n) ->
                                                                ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    requires { (s.heap.sibling[self]) = null }
    requires { (s.heap.prev[self]) = null }
    requires { (s.heap.child[self]) = null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
    ensures { (s.heap.sibling[self]) = null }
    ensures { (s.heap.prev[self]) = null }
    ensures { (s.heap.child[self]) = null } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (let t = ref t in
       (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
         (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
         (! result))))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { not (Rgn.mem self s.pool) }
    requires { pqueueI s s.pool }
    writes { s.pool }
    writes { s.heap.rep }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { Rgn.mem self s.pool }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { pqueueI s s.pool } =
    let result = ref () in
    (let self = ref self in
     (((s.heap.rep <- ([@expl:self.rep := {null}] M.add (! self) (singleton null) s.heap.rep));
       (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
       (! result))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool } =
    let result = ref false in
    (let self = ref self in
     (let sz = ref 0 in
      (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
        (result := ([@expl:result := sz = 0] (! sz) = 0));
        (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (((assert { not ((s.heap.head[! self]) = null) });
       (result := ([@expl:result := self.head] s.heap.head[! self]));
       (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    let result = ref null in
    (let self = ref self in
     (let first = ref first in
      (let second = ref second in
       (let fkey = ref 0 in
        (let skey = ref 0 in
         (let tmp = ref null in
          (let ghost rep3 = ref emptyRgn in
           (((rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
             (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
             (skey := ([@expl:skey := second.key] s.heap.key[! second]));
             (if ((! skey) < (! fkey))
              then (((tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                     (assert { Rgn.mem (! tmp) (! rep3) });
                     (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                     (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                     (assert { let p = s.heap.prev[! first] in
                               Rgn.mem p (! rep3) });
                     (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                     (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                     (if ((! tmp) <>. null)
                      then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                             (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                             (assert { Rgn.mem (! tmp) (! rep3) });
                             (assert { let p = s.heap.prev[! tmp] in
                                       Rgn.mem p (! rep3) });
                             (assert { repClosed s (! rep3) })))
                      else ());
                     (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                     (result := ([@expl:result := second] ! second));
                     (assert { repClosed s (! rep3) })))
              else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                     (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                     (assert { Rgn.mem (! tmp) (! rep3) });
                     (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                     (if ((! tmp) <>. null)
                      then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                             (assert { Rgn.mem (! tmp) (! rep3) });
                             (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                      else ());
                     (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                     (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                     (if ((! tmp) <>. null)
                      then (((tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                             (assert { Rgn.mem (! tmp) (! rep3) });
                             (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                      else ());
                     (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                     (result := ([@expl:result := first] ! first));
                     (assert { repClosed s (! rep3) }))));
             (! result))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  lemma img_rep_lem : forall s: state.
                        forall self1: reference.
                          (isAllocated s self1) -> ((hasPqueueType s self1) -> ((s.heap.rep[self1]) = (s.heap.rep[self1])))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (let k = ref k in
      (let t = ref t in
       (((assert { PQUEUE.pqueuePub s s.pool });
         (result := ([@expl:result := new Node] mk_Node s));
         (assert { pqueueI s s.pool });
         (assert { (! result) <> null });
         ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
         (assert { PQUEUE.pqueuePub s s.pool });
         (assert {
            forall p: reference.
              (isAllocated s p) ->
                ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep3 = s.heap.rep[p] in
                                                                not (Rgn.mem (! result) rep3)))) });
         (assert { pqueueI s s.pool });
         (let ghost rep4 = ref emptyRgn in
          (((rep4 := ([@expl:rep := self.rep] s.heap.rep[! self]));
            (s.heap.rep <-
               ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep4) (singleton (! result))) s.heap.rep));
            (assert {
               forall p: reference.
                 (isAllocated s p) ->
                   ((hasPqueueType s p) ->
                      ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let prep = s.heap.rep[p] in
                                                                  not (Rgn.mem (! result) prep))))) });
            (assert {
               forall p: reference.
                 (isAllocated s p) ->
                   ((hasPqueueType s p) ->
                      ((Rgn.mem p s.pool) ->
                         ((p <> (! self)) ->
                            (let prep = s.heap.rep[p] in
                             let srep = s.heap.rep[! self] in
                             Rgn.subset (Rgn.inter srep prep) (singleton null))))) });
            (assert {
               forall p: reference, q: reference.
                 (isAllocated s p) ->
                   ((hasPqueueType s p) ->
                      ((Rgn.mem p s.pool) ->
                         ((isAllocated s q) ->
                            ((hasPqueueType s q) ->
                               ((Rgn.mem q s.pool) ->
                                  ((p <> q) ->
                                     ((p <> (! self)) ->
                                        ((q <> (! self)) ->
                                           (let prep = s.heap.rep[p] in
                                            let qrep = s.heap.rep[q] in
                                            Rgn.subset (Rgn.inter prep qrep) (singleton null)))))))))) });
            (assert { PQUEUE.pqueuePub s s.pool });
            (assert { let rep5 = s.heap.rep[! self] in
                      repClosed s rep5 });
            (assert { pqueueI s s.pool });
            (let hd = ref null in
             (((hd := ([@expl:hd := self.head] s.heap.head[! self]));
               (if ((! hd) =. null)
                then (((assert { let rep6 = s.heap.rep[! self] in
                                 repClosed s rep6 });
                       (s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                       (assert { (s.heap.head[! self]) = (! result) });
                       (assert { let hd7 = s.heap.head[! self] in
                                 let rep8 = s.heap.rep[! self] in
                                 Rgn.mem hd7 rep8 });
                       (assert {
                          let hd9 = s.heap.head[! self] in
                          ((s.heap.sibling[hd9]) = null) /\ (((s.heap.prev[hd9]) = null) /\ ((s.heap.child[hd9]) = null)) })))
                else (let tmp = ref null in
                      (((tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                        (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                        (assert { let hd10 = s.heap.head[! self] in
                                  let rep11 = s.heap.rep[! self] in
                                  Rgn.mem hd10 rep11 })))));
               (let sz = ref 0 in
                (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
                  (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                  (! result)))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { not ((s.heap.sibling[handle]) = null) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.length[p]) = ((old s.heap.length)[p]))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    let result = ref null in
    (let self = ref self in
     (let handle = ref handle in
      (let trees = ref null in
       (let index = ref 0 in
        (let current = ref null in
         (let tmp = ref null in
          (let fst = ref null in
           (let snd = ref null in
            (let i = ref 0 in
             (let j = ref 0 in
              (((((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                  (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                  (s.heap.slots <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                (s.heap.slots <-
                   ([@expl:trees.{0} := handle] M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                (assert {
                   forall p: reference.
                     (isAllocated s p) ->
                       ((hasNodeArrayType s p) -> ((p <> (! trees)) -> (let s3 = old (s.heap.slots[p]) in
                                                                    (s.heap.slots[p]) = s3))) });
                (index := ([@expl:index := 1] 1));
                (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                (while (! current) <>. null do
                   invariant { 1 <= (! index) }
                   invariant { let l = s.heap.length[! trees] in
                               (! index) < l }
                   invariant { forall k4: int. (0 <= k4) -> ((k4 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k4) = null))) }
                   invariant {
                     let l = s.heap.length[! trees] in
                     forall k5: int. ((! index) <= k5) -> ((k5 < l) -> ((A.get (s.heap.slots[! trees]) k5) = null)) }
                   invariant {
                     forall k6: int.
                       (0 <= k6) ->
                         ((k6 < (! index)) ->
                            (let n = A.get (s.heap.slots[! trees]) k6 in
                             let rep7 = s.heap.rep[! self] in
                             Rgn.mem n rep7)) }
                   invariant { let rep8 = s.heap.rep[! self] in
                               Rgn.mem (! current) rep8 }
                   invariant { let rep9 = s.heap.rep[! self] in
                               repClosed s rep9 }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeType s p) ->
                            ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                               (let sib = old (s.heap.sibling[p]) in
                                let prev10 = old (s.heap.prev[p]) in
                                let child11 = old (s.heap.child[p]) in
                                ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = prev10) /\ ((s.heap.child[p]) = child11))))) }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeArrayType s p) ->
                            ((p <> (! trees)) ->
                               (let slots12 = old (s.heap.slots[p]) in
                                let length13 = old (s.heap.length[p]) in
                                ((s.heap.slots[p]) = slots12) /\ ((s.heap.length[p]) = length13)))) }
                   invariant { PQUEUE.pqueuePub s s.pool }
                   invariant { pqueueI s s.pool }
                   ((assume { let l = s.heap.length[! trees] in
                              (! index) < (l - 1) });
                    (s.heap.slots <-
                       ([@expl:trees.{index} := current]
                        M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                    (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                    (if ((! tmp) <>. null) then (s.heap.sibling <- ([@expl:tmp.sibling := null] M.add (! tmp) null s.heap.sibling))
                     else ());
                    (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                    (index := ([@expl:index := index + 1] (! index) + 1)))
                 done);
                (s.heap.slots <-
                   ([@expl:trees.{index} := null] M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) null) s.heap.slots));
                (assert { let l = s.heap.length[! trees] in
                          (! index) < l });
                (i := ([@expl:i := 0] 0));
                (tmp := ([@expl:tmp := null] null));
                (while ((! i) + 1) < (! index) do
                   invariant {
                     forall k14: int. (0 <= k14) -> ((k14 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k14) = null))) }
                   invariant {
                     let l = s.heap.length[! trees] in
                     forall k15: int. ((! index) <= k15) -> ((k15 < l) -> ((A.get (s.heap.slots[! trees]) k15) = null)) }
                   invariant {
                     forall k16: int.
                       (0 <= k16) ->
                         ((k16 < (! index)) ->
                            (let n = A.get (s.heap.slots[! trees]) k16 in
                             let rep17 = s.heap.rep[! self] in
                             Rgn.mem n rep17)) }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeType s p) ->
                            ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                               (let sib = old (s.heap.sibling[p]) in
                                let prev18 = old (s.heap.prev[p]) in
                                let child19 = old (s.heap.child[p]) in
                                ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = prev18) /\ ((s.heap.child[p]) = child19))))) }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeArrayType s p) ->
                            ((p <> (! trees)) ->
                               (let slots20 = old (s.heap.slots[p]) in
                                let length21 = old (s.heap.length[p]) in
                                ((s.heap.slots[p]) = slots20) /\ ((s.heap.length[p]) = length21)))) }
                   invariant { PQUEUE.pqueuePub s s.pool }
                   invariant { pqueueI s s.pool }
                   invariant { 0 <= (! i) }
                   invariant { (! i) <= (! index) }
                   invariant { let rep22 = s.heap.rep[! self] in
                               Rgn.mem (! tmp) rep22 }
                   ((fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                    (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                    (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                    (s.heap.slots <-
                       ([@expl:trees.{i} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                    (i := ([@expl:i := i + 2] (! i) + 2)))
                 done);
                (j := ([@expl:j := i - 2] (! i) - 2));
                (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                 then (((assert { ((! j) + 2) < (! index) });
                        (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                        (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                        (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                        (s.heap.slots <-
                           ([@expl:trees.{j} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                 else ());
                (while 2 <= (! j) do
                   invariant {
                     forall k23: int. (0 <= k23) -> ((k23 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k23) = null))) }
                   invariant {
                     let l = s.heap.length[! trees] in
                     forall k24: int. ((! index) <= k24) -> ((k24 < l) -> ((A.get (s.heap.slots[! trees]) k24) = null)) }
                   invariant {
                     forall k25: int.
                       (0 <= k25) ->
                         ((k25 < (! index)) ->
                            (let n = A.get (s.heap.slots[! trees]) k25 in
                             let rep26 = s.heap.rep[! self] in
                             Rgn.mem n rep26)) }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeType s p) ->
                            ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                               (let sib = old (s.heap.sibling[p]) in
                                let prev27 = old (s.heap.prev[p]) in
                                let child28 = old (s.heap.child[p]) in
                                ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = prev27) /\ ((s.heap.child[p]) = child28))))) }
                   invariant {
                     forall p: reference.
                       (isAllocated s p) ->
                         ((hasNodeArrayType s p) ->
                            ((p <> (! trees)) ->
                               (let slots29 = old (s.heap.slots[p]) in
                                let length30 = old (s.heap.length[p]) in
                                ((s.heap.slots[p]) = slots29) /\ ((s.heap.length[p]) = length30)))) }
                   invariant { (0 - 2) <= (! j) }
                   invariant { (! j) < (! index) }
                   invariant { PQUEUE.pqueuePub s s.pool }
                   invariant { pqueueI s s.pool }
                   ((fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                    (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                    (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                    (s.heap.slots <-
                       ([@expl:trees.{j - 2} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                    (j := ([@expl:j := j - 2] (! j) - 2)))
                 done);
                (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                (! result)))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.length[p]) = ((old s.heap.length)[p]))) }
    ensures { pqueueI s s.pool }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    let result = ref null in
    (let self = ref self in
     (let handle = ref handle in
      (let tmp = ref null in
       (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
         (if ((! tmp) =. null) then (result := ([@expl:result := handle] ! handle))
          else (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))));
         (! result))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (((result := ([@expl:result := findMin(self)] findMin s (! self)));
       (let tmp = ref null in
        (((tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
          (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
          (if ((! tmp) =. null)
           then (((assume { (s.heap.size[! self]) = 1 });
                  (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head))))
           else (((assume { let sz = s.heap.size[! self] in
                            sz > 1 });
                  (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                  (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
          (let sz = ref 0 in
           (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
             (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
             (! result))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { (s.heap.key[handle]) = k }
    ensures { pqueueI s s.pool } =
    let result = ref () in
    (let self = ref self in
     (let handle = ref handle in
      (let k = ref k in
       (let tmp = ref null in
        (let pos = ref null in
         (((assert { let key3 = s.heap.key[! handle] in
                     key3 >= 0 });
           (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
           (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
           (if ((! handle) <>. (! tmp))
            then (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                   (if ((! tmp) <>. null)
                    then (((pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                           (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev))))
                    else ());
                   (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                   (assert { let rep4 = s.heap.rep[! self] in
                             Rgn.mem (! tmp) rep4 });
                   (if ((! tmp) <>. null)
                    then (((pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                           (if ((! pos) =. (! handle))
                            then (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                   (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                            else (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                   (assert { let rep5 = s.heap.rep[! self] in
                                             (Rgn.mem (! pos) rep5) /\ (Rgn.mem (! tmp) rep5) });
                                   (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                   (assert { let rep6 = s.heap.rep[! self] in
                                             let sib = s.heap.sibling[! tmp] in
                                             Rgn.mem sib rep6 }))));
                           (assert {
                              forall p: reference.
                                (isAllocated s p) ->
                                  ((hasNodeType s p) ->
                                     (let rep7 = s.heap.rep[! self] in
                                      (not (Rgn.mem p rep7)) -> (let sib = old (s.heap.sibling[p]) in
                                                                 (s.heap.sibling[p]) = sib))) })))
                    else ());
                   (s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! handle) null s.heap.sibling));
                   (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                   (assert { (! pos) <> null });
                   (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                   (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
            else ());
           (! result))))))))
end

module PqueueR
  
  use prelude.Prelude
  use State
  use PQUEUE
  
  predicate repOk (s: state) (pq: reference) =
    (hasPqueueType s pq) ->
      ((pq <> null) ->
         (let sntl1 = s.heap.sntl[pq] in
          let rep2 = s.heap.rep[pq] in
          (typeofRgn s rep2 Node) /\
            ((not (Rgn.mem sntl1 rep2)) /\
               ((not (Rgn.mem null rep2)) /\
                  (forall n: reference.
                     (isAllocated s n) ->
                       ((hasNodeType s n) ->
                          ((Rgn.mem n rep2) ->
                             (let chl = s.heap.child[n] in
                              let sib = s.heap.sibling[n] in
                              let pre = s.heap.prev[n] in
                              ((Rgn.mem chl rep2) \/ (chl = sntl1)) /\
                                (((Rgn.mem sib rep2) \/ (sib = sntl1)) /\ ((Rgn.mem pre rep2) \/ (pre = sntl1)))))))))))
  
  lemma repOk_EMPTY : forall s: state.
                        forall p: reference.
                          (isAllocated s p) -> ((hasPqueueType s p) -> (((s.heap.rep[p]) = emptyRgn) -> (repOk s p)))
  
  predicate sntlOk (s: state) (sntl1: reference) =
    (hasNodeType s sntl1) ->
      ((sntl1 <> null) ->
         (((s.heap.tag[sntl1]) = (0 - 1)) /\
            (((s.heap.key[sntl1]) = (0 - 1)) /\
               (((s.heap.sibling[sntl1]) = sntl1) /\ (((s.heap.child[sntl1]) = sntl1) /\ ((s.heap.prev[sntl1]) = sntl1))))))
  
  predicate nodeP (s: state) (r: rgn) =
    forall n: reference.
      (isAllocated s n) ->
        ((hasNodeType s n) -> ((Rgn.mem n r) -> (let t = s.heap.tag[n] in
                                                 let k = s.heap.key[n] in
                                                 (k >= 0) /\ (t >= 0))))
  
  predicate strongDisjoint (s: state) (r: rgn) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasPqueueType s p) ->
           ((Rgn.mem p r) ->
              ((isAllocated s q) ->
                 ((hasPqueueType s q) ->
                    ((Rgn.mem q r) ->
                       (let prep = s.heap.rep[p] in
                        let qrep = s.heap.rep[q] in
                        (p <> q) -> ((Rgn.inter prep qrep) = emptyRgn)))))))
  
  predicate pqueueI (s: state) (pl: rgn) =
    forall pq: reference.
      (isAllocated s pq) ->
        ((hasPqueueType s pq) ->
           ((Rgn.mem pq pl) ->
              (let rep1 = s.heap.rep[pq] in
               let sz = s.heap.size[pq] in
               let sntl2 = s.heap.sntl[pq] in
               let head3 = s.heap.head[pq] in
               (sntl2 <> null) /\
                 ((Rgn.mem sntl2 pl) /\
                    ((not (Rgn.mem sntl2 rep1)) /\
                       ((sntlOk s sntl2) /\
                          ((repOk s pq) /\
                             ((head3 <> null) /\
                                (((head3 <> sntl2) -> (Rgn.mem head3 rep1)) /\
                                   ((sz >= 0) /\
                                      (((sz = 0) <-> (head3 = sntl2)) /\
                                         ((nodeP s rep1) /\
                                            ((forall pq2: reference.
                                                (isAllocated s pq2) ->
                                                  ((hasPqueueType s pq2) ->
                                                     ((Rgn.mem pq2 pl) -> ((pq <> pq2) -> (not ((s.heap.sntl[pq2]) = sntl2)))))) /\
                                               (strongDisjoint s pl))))))))))))))
  
  lemma disjointNotIn : forall s: state.
                          forall r: rgn.
                            forall p: reference, q: reference.
                              (isAllocated s p) ->
                                ((hasPqueueType s p) ->
                                   ((Rgn.mem p r) ->
                                      ((isAllocated s q) ->
                                         ((hasPqueueType s q) ->
                                            ((Rgn.mem q r) ->
                                               ((pqueueI s r) ->
                                                  ((Rgn.mem p r) ->
                                                     ((Rgn.mem q r) ->
                                                        ((p <> q) ->
                                                           (let prep = s.heap.rep[p] in
                                                            let qrep = s.heap.rep[q] in
                                                            forall n: reference.
                                                              (isAllocated s n) ->
                                                                ((hasNodeType s n) -> ((Rgn.mem n prep) -> (not (Rgn.mem n qrep))))))))))))))
  
  let init_Node (s: state) (self: reference) (k: int) (t: int) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    requires { (s.heap.sibling[self]) = null }
    requires { (s.heap.prev[self]) = null }
    requires { (s.heap.child[self]) = null }
    writes { s.heap.key }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = Node) -> ((p <> self) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { (s.heap.key[self]) = k }
    ensures { (s.heap.tag[self]) = t }
    ensures { (s.heap.sibling[self]) = null }
    ensures { (s.heap.prev[self]) = null }
    ensures { (s.heap.child[self]) = null } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (let t = ref t in
       (((s.heap.key <- ([@expl:self.key := k] M.add (! self) (! k) s.heap.key));
         (s.heap.tag <- ([@expl:self.tag := t] M.add (! self) (! t) s.heap.tag));
         (! result))))))
  
  let init_Pqueue (s: state) (self: reference) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { ((s.heap.rep[self]) = emptyRgn) /\ (((s.heap.size[self]) = 0) /\ ((s.heap.head[self]) = null)) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { not (Rgn.mem self s.pool) }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.sntl }
    writes { s.heap.tag }
    ensures { result = () }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (singleton self) (s.heap.rep[self])))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { Rgn.mem self s.pool }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.subset rep1 (singleton null) }
    ensures { pqueueI s s.pool } =
    let result = ref () in
    (let self = ref self in
     (let sntl2 = ref null in
      (((sntl2 := ([@expl:sntl := new Node] mk_Node s));
        ([@expl:Node(sntl,- 1,- 1)] init_Node s (! sntl2) (0 - 1) (0 - 1));
        (assert {
           forall pq: reference.
             (isAllocated s pq) -> ((hasPqueueType s pq) -> ((Rgn.mem pq s.pool) -> (not ((s.heap.sntl[pq]) = (! sntl2))))) });
        (s.heap.rep <- ([@expl:self.rep := {}] M.add (! self) emptyRgn s.heap.rep));
        (s.heap.sntl <- ([@expl:self.sntl := sntl] M.add (! self) (! sntl2) s.heap.sntl));
        (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl2) s.heap.head));
        (s.heap.sibling <- ([@expl:sntl.sibling := sntl] M.add (! sntl2) (! sntl2) s.heap.sibling));
        (s.heap.child <- ([@expl:sntl.child := sntl] M.add (! sntl2) (! sntl2) s.heap.child));
        (s.heap.prev <- ([@expl:sntl.prev := sntl] M.add (! sntl2) (! sntl2) s.heap.prev));
        (s.pool <-
           ([@expl:pool := pool union {self} union {sntl}] Rgn.union (Rgn.union s.pool (singleton (! self))) (singleton (! sntl2))));
        (! result)))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    ensures { ((s.heap.size[self]) = 0) <-> result }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool } =
    let result = ref false in
    (let self = ref self in
     (let sz = ref 0 in
      (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
        (result := ([@expl:result := sz = 0] (! sz) = 0));
        (! result)))))
  
  let findMin (s: state) (self: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let hd = s.heap.head[self] in
              result = hd }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (((assert { let sntl1 = s.heap.sntl[! self] in
                 not ((s.heap.head[! self]) = sntl1) });
       (result := ([@expl:result := self.head] s.heap.head[! self]));
       (! result))))
  
  let link (s: state) (self: reference) (first: reference) (second: reference) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s first }
    requires { first <> null }
    requires { hasNodeType s second }
    requires { second <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               (Rgn.mem first rep2) /\ (Rgn.mem second rep2) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.heap.child }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool }
    ensures { ((result = first) /\ ((s.heap.child[first]) = second)) \/ ((result = second) /\ ((s.heap.child[second]) = first)) }
    ensures { (result = first) \/ (result = second) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    let result = ref null in
    (let self = ref self in
     (let first = ref first in
      (let second = ref second in
       (let fkey = ref 0 in
        (let skey = ref 0 in
         (let tmp = ref null in
          (let ghost rep3 = ref emptyRgn in
           (let sntl4 = ref null in
            (((sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
              (assert { ((! first) <> (! sntl4)) /\ ((! second) <> (! sntl4)) });
              (rep3 := ([@expl:rep := self.rep] s.heap.rep[! self]));
              (fkey := ([@expl:fkey := first.key] s.heap.key[! first]));
              (skey := ([@expl:skey := second.key] s.heap.key[! second]));
              (assert {
                 forall p: reference.
                   (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (repOk s p)))) });
              (if ((! skey) < (! fkey))
               then (((tmp := ([@expl:tmp := first.prev] s.heap.prev[! first]));
                      (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                      (s.heap.prev <- ([@expl:second.prev := tmp] M.add (! second) (! tmp) s.heap.prev));
                      (s.heap.prev <- ([@expl:first.prev := second] M.add (! first) (! second) s.heap.prev));
                      (assert { let p = s.heap.prev[! first] in
                                Rgn.mem p (! rep3) });
                      (tmp := ([@expl:tmp := second.child] s.heap.child[! second]));
                      (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                      (if ((! tmp) <>. (! sntl4))
                       then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                              (assert { let rep5 = s.heap.rep[! self] in
                                        Rgn.mem (! tmp) rep5 });
                              (assert {
                                 forall p: reference.
                                   (isAllocated s p) ->
                                     ((hasPqueueType s p) ->
                                        ((Rgn.mem p s.pool) ->
                                           ((p <> (! self)) -> (let rep6 = s.heap.rep[p] in
                                                                not (Rgn.mem (! tmp) rep6))))) });
                              (assert {
                                 let rep7 = s.heap.rep[! self] in
                                 let p = s.heap.prev[! tmp] in
                                 (p = (! sntl4)) \/ (Rgn.mem p rep7) });
                              (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev));
                              (assert { Rgn.mem (! tmp) (! rep3) });
                              (assert { let p = s.heap.prev[! tmp] in
                                        Rgn.mem p (! rep3) });
                              (assert { repOk s (! self) })))
                       else ());
                      (s.heap.child <- ([@expl:second.child := first] M.add (! second) (! first) s.heap.child));
                      (result := ([@expl:result := second] ! second));
                      (assert { repOk s (! self) })))
               else (((s.heap.prev <- ([@expl:second.prev := first] M.add (! second) (! first) s.heap.prev));
                      (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                      (assert { ((! tmp) <> (! sntl4)) -> (Rgn.mem (! tmp) (! rep3)) });
                      (s.heap.sibling <- ([@expl:first.sibling := tmp] M.add (! first) (! tmp) s.heap.sibling));
                      (if ((! tmp) <>. (! sntl4))
                       then (((tmp := ([@expl:tmp := first.sibling] s.heap.sibling[! first]));
                              (s.heap.prev <- ([@expl:tmp.prev := first] M.add (! tmp) (! first) s.heap.prev))))
                       else ());
                      (tmp := ([@expl:tmp := first.child] s.heap.child[! first]));
                      (s.heap.sibling <- ([@expl:second.sibling := tmp] M.add (! second) (! tmp) s.heap.sibling));
                      (if ((! tmp) <>. (! sntl4))
                       then (((assert { Rgn.mem (! tmp) (! rep3) });
                              (tmp := ([@expl:tmp := second.sibling] s.heap.sibling[! second]));
                              (assert { Rgn.mem (! tmp) (! rep3) });
                              (s.heap.prev <- ([@expl:tmp.prev := second] M.add (! tmp) (! second) s.heap.prev))))
                       else ());
                      (s.heap.child <- ([@expl:first.child := second] M.add (! first) (! second) s.heap.child));
                      (result := ([@expl:result := first] ! first));
                      (assert { repOk s (! self) }))));
              (! result)))))))))))
  
  lemma insert_wr_rgn_eq : forall s: state.
                             forall self1: reference, n: reference.
                               (isAllocated s self1) ->
                                 ((hasPqueueType s self1) ->
                                    ((isAllocated s n) ->
                                       ((hasNodeType s n) ->
                                          (let rep2 = s.heap.rep[self1] in
                                           (Rgn.mem n rep2) -> ((Rgn.union (singleton n) (s.heap.rep[self1])) = (s.heap.rep[self1]))))))
  
  let insert (s: state) (self: reference) (k: int) (t: int) : reference
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { 0 <= k }
    requires { 0 <= t }
    requires { Rgn.mem self s.pool }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.tag }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = (Rgn.union orep (singleton result)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { (s.heap.key[result]) = k }
    ensures { (s.heap.tag[result]) = t }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        ((n <> result) ->
                           (let ot = old (s.heap.tag[n]) in
                            let ok = old (s.heap.key[n]) in
                            ((s.heap.tag[n]) = ot) /\ ((s.heap.key[n]) = ok))))) }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (let k = ref k in
      (let t = ref t in
       (let sntl3 = ref null in
        (((sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
          (result := ([@expl:result := new Node] mk_Node s));
          ([@expl:Node(result,k,t)] init_Node s (! result) (! k) (! t));
          (assert { PQUEUE.pqueuePub s s.pool });
          (assert {
             forall p: reference.
               (isAllocated s p) ->
                 ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let rep4 = s.heap.rep[p] in
                                                                 not (Rgn.mem (! result) rep4)))) });
          (s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! result) (! sntl3) s.heap.sibling));
          (s.heap.child <- ([@expl:result.child := sntl] M.add (! result) (! sntl3) s.heap.child));
          (s.heap.prev <- ([@expl:result.prev := sntl] M.add (! result) (! sntl3) s.heap.prev));
          (let ghost rep5 = ref emptyRgn in
           (((rep5 := ([@expl:rep := self.rep] s.heap.rep[! self]));
             (assert { (repOk s (! self)) /\ (nodeP s (! rep5)) });
             (s.heap.rep <-
                ([@expl:self.rep := rep union {result}] M.add (! self) (Rgn.union (! rep5) (singleton (! result))) s.heap.rep));
             (assert { repOk s (! self) });
             (assert {
                forall p: reference.
                  (isAllocated s p) ->
                    ((hasPqueueType s p) ->
                       ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = old (s.heap.rep[p]) in
                                                                   (s.heap.rep[p]) = r)))) });
             (assert {
                forall p: reference.
                  (isAllocated s p) ->
                    ((hasPqueueType s p) ->
                       ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (let r = s.heap.rep[p] in
                                                                   not (Rgn.mem (! result) r))))) });
             (assert {
                forall p: reference.
                  (isAllocated s p) ->
                    ((hasPqueueType s p) ->
                       ((Rgn.mem p s.pool) ->
                          ((p <> (! self)) ->
                             (let r = s.heap.rep[p] in
                              let r2 = s.heap.rep[! self] in
                              Rgn.subset (Rgn.inter r r2) (singleton null))))) });
             (assert { PQUEUE.pqueuePub s s.pool });
             (assert { let r = s.heap.rep[! self] in
                       nodeP s r });
             (assert {
                forall p: reference.
                  (isAllocated s p) -> ((hasPqueueType s p) -> ((Rgn.mem p s.pool) -> (let r = s.heap.rep[p] in
                                                                    nodeP s r))) });
             (let hd = ref null in
              (((hd := ([@expl:hd := self.head] s.heap.head[! self]));
                (if ((! hd) =. (! sntl3))
                 then (((s.heap.head <- ([@expl:self.head := result] M.add (! self) (! result) s.heap.head));
                        (assert { repOk s (! self) })))
                 else (let tmp = ref null in
                       (((tmp := ([@expl:tmp := link(self,hd,result)] link s (! self) (! hd) (! result)));
                         (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head));
                         (assert {
                            let hd6 = s.heap.head[! self] in
                            let rep7 = s.heap.rep[! self] in
                            (hd6 <> null) /\ (Rgn.mem hd6 rep7) })))));
                (let sz = ref 0 in
                 (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
                   (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                   (! result))))))))))))))))
  
  let combineAux (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { let sntl3 = s.heap.sntl[self] in
               (not ((s.heap.sibling[handle]) = sntl3)) /\ (not ((s.heap.sibling[handle]) = null)) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.length[p]) = ((old s.heap.length)[p]))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { pqueueI s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 } =
    let result = ref null in
    (let self = ref self in
     (let handle = ref handle in
      (let trees = ref null in
       (let index = ref 0 in
        (let current = ref null in
         (let sntl4 = ref null in
          (let tmp = ref null in
           (let fst = ref null in
            (let snd = ref null in
             (let i = ref 0 in
              (let j = ref 0 in
               (((sntl4 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
                 (((trees := ([@expl:trees := new(NodeArray){1024}] mk_NodeArray s));
                   (s.heap.length <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) 1024 s.heap.length));
                   (s.heap.slots <- ([@expl:trees := new(NodeArray){1024}] M.add (! trees) (A.make 1024 null) s.heap.slots))));
                 (s.heap.slots <-
                    ([@expl:trees.{0} := handle] M.add (! trees) (A.set (s.heap.slots[! trees]) 0 (! handle)) s.heap.slots));
                 (assert { not ((A.get (s.heap.slots[! trees]) 0) = null) });
                 (assert {
                    forall p: reference.
                      (isAllocated s p) ->
                        ((hasNodeArrayType s p) -> ((p <> (! trees)) -> (let s5 = old (s.heap.slots[p]) in
                                                                    (s.heap.slots[p]) = s5))) });
                 (index := ([@expl:index := 1] 1));
                 (current := ([@expl:current := handle.sibling] s.heap.sibling[! handle]));
                 (while (! current) <>. (! sntl4) do
                    invariant { 1 <= (! index) }
                    invariant { let l = s.heap.length[! trees] in
                                (! index) < l }
                    invariant {
                      forall k6: int. (0 <= k6) -> ((k6 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k6) = (! sntl4)))) }
                    invariant {
                      forall k7: int.
                        (0 <= k7) ->
                          ((k7 < (! index)) ->
                             (let n = A.get (s.heap.slots[! trees]) k7 in
                              let rep8 = s.heap.rep[! self] in
                              Rgn.mem n rep8)) }
                    invariant { ((! current) <> (! sntl4)) -> (let rep9 = s.heap.rep[! self] in
                                                               Rgn.mem (! current) rep9) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeType s p) ->
                             ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                (let sib = old (s.heap.sibling[p]) in
                                 let pre = old (s.heap.prev[p]) in
                                 let chl = old (s.heap.child[p]) in
                                 ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeArrayType s p) ->
                             ((p <> (! trees)) ->
                                (let slots10 = old (s.heap.slots[p]) in
                                 let length11 = old (s.heap.length[p]) in
                                 ((s.heap.slots[p]) = slots10) /\ ((s.heap.length[p]) = length11)))) }
                    invariant { PQUEUE.pqueuePub s s.pool }
                    invariant { pqueueI s s.pool }
                    ((assume { let l = s.heap.length[! trees] in
                               (! index) < (l - 1) });
                     (s.heap.slots <-
                        ([@expl:trees.{index} := current]
                         M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! current)) s.heap.slots));
                     (tmp := ([@expl:tmp := current.prev] s.heap.prev[! current]));
                     (s.heap.sibling <- ([@expl:tmp.sibling := sntl] M.add (! tmp) (! sntl4) s.heap.sibling));
                     (current := ([@expl:current := current.sibling] s.heap.sibling[! current]));
                     (index := ([@expl:index := index + 1] (! index) + 1)))
                  done);
                 (s.heap.slots <-
                    ([@expl:trees.{index} := sntl] M.add (! trees) (A.set (s.heap.slots[! trees]) (! index) (! sntl4)) s.heap.slots));
                 (i := ([@expl:i := 0] 0));
                 (tmp := ([@expl:tmp := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                 (while ((! i) + 1) < (! index) do
                    invariant {
                      forall k12: int. (0 <= k12) -> ((k12 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k12) = (! sntl4)))) }
                    invariant {
                      forall k13: int.
                        (0 <= k13) ->
                          ((k13 < (! index)) ->
                             (let n = A.get (s.heap.slots[! trees]) k13 in
                              let rep14 = s.heap.rep[! self] in
                              Rgn.mem n rep14)) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeType s p) ->
                             ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                (let sib = old (s.heap.sibling[p]) in
                                 let pre = old (s.heap.prev[p]) in
                                 let chl = old (s.heap.child[p]) in
                                 ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeArrayType s p) ->
                             ((p <> (! trees)) ->
                                (let slots15 = old (s.heap.slots[p]) in
                                 let length16 = old (s.heap.length[p]) in
                                 ((s.heap.slots[p]) = slots15) /\ ((s.heap.length[p]) = length16)))) }
                    invariant { let rep17 = s.heap.rep[! self] in
                                (Rgn.mem (! tmp) rep17) /\ ((! tmp) <> null) }
                    invariant { PQUEUE.pqueuePub s s.pool }
                    invariant { pqueueI s s.pool }
                    invariant { 0 <= (! i) }
                    invariant { (! i) <= (! index) }
                    ((fst := ([@expl:fst := trees.{i}] A.get (s.heap.slots[! trees]) (! i)));
                     (snd := ([@expl:snd := trees.{i + 1}] A.get (s.heap.slots[! trees]) ((! i) + 1)));
                     (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                     (s.heap.slots <-
                        ([@expl:trees.{i} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! i) (! tmp)) s.heap.slots));
                     (i := ([@expl:i := i + 2] (! i) + 2)))
                  done);
                 (j := ([@expl:j := i - 2] (! i) - 2));
                 (if (((! j) >= 0)  && ((! j) = ((! index) - 3)))
                  then (((assert { ((! j) + 2) < (! index) });
                         (fst := ([@expl:fst := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                         (snd := ([@expl:snd := trees.{j + 2}] A.get (s.heap.slots[! trees]) ((! j) + 2)));
                         (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                         (s.heap.slots <-
                            ([@expl:trees.{j} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) (! j) (! tmp)) s.heap.slots))))
                  else ());
                 (while 2 <= (! j) do
                    invariant {
                      forall k18: int. (0 <= k18) -> ((k18 < (! index)) -> (not ((A.get (s.heap.slots[! trees]) k18) = (! sntl4)))) }
                    invariant {
                      forall k19: int.
                        (0 <= k19) ->
                          ((k19 < (! index)) ->
                             (let n = A.get (s.heap.slots[! trees]) k19 in
                              let rep20 = s.heap.rep[! self] in
                              Rgn.mem n rep20)) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeType s p) ->
                             ((not (Rgn.mem p (s.heap.rep[! self]))) ->
                                (let sib = old (s.heap.sibling[p]) in
                                 let pre = old (s.heap.prev[p]) in
                                 let chl = old (s.heap.child[p]) in
                                 ((s.heap.sibling[p]) = sib) /\ (((s.heap.prev[p]) = pre) /\ ((s.heap.child[p]) = chl))))) }
                    invariant {
                      forall p: reference.
                        (isAllocated s p) ->
                          ((hasNodeArrayType s p) ->
                             ((p <> (! trees)) ->
                                (let slots21 = old (s.heap.slots[p]) in
                                 let length22 = old (s.heap.length[p]) in
                                 ((s.heap.slots[p]) = slots21) /\ ((s.heap.length[p]) = length22)))) }
                    invariant { let rep23 = s.heap.rep[! self] in
                                (Rgn.mem (! tmp) rep23) /\ ((! tmp) <> null) }
                    invariant { (0 - 2) <= (! j) }
                    invariant { (! j) < (! index) }
                    invariant { PQUEUE.pqueuePub s s.pool }
                    invariant { pqueueI s s.pool }
                    ((fst := ([@expl:fst := trees.{j - 2}] A.get (s.heap.slots[! trees]) ((! j) - 2)));
                     (snd := ([@expl:snd := trees.{j}] A.get (s.heap.slots[! trees]) (! j)));
                     (tmp := ([@expl:tmp := link(self,fst,snd)] link s (! self) (! fst) (! snd)));
                     (assert { ((! tmp) <> null) /\ (typeofRgn s (singleton (! tmp)) Node) });
                     (s.heap.slots <-
                        ([@expl:trees.{j - 2} := tmp] M.add (! trees) (A.set (s.heap.slots[! trees]) ((! j) - 2) (! tmp)) s.heap.slots));
                     (j := ([@expl:j := j - 2] (! j) - 2)))
                  done);
                 (result := ([@expl:result := trees.{0}] A.get (s.heap.slots[! trees]) 0));
                 (! result))))))))))))))
  
  let combine (s: state) (self: reference) (handle: reference): reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep2 = s.heap.rep[self] in
               Rgn.mem handle rep2 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) -> ((not (Rgn.mem p (s.heap.rep[self]))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = NodeArray) -> ((s.heap.length[p]) = ((old s.heap.length)[p]))) }
    ensures { pqueueI s s.pool }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let ohd = old (s.heap.head[self]) in
              (s.heap.head[self]) = ohd } =
    let result = ref null in
    (let self = ref self in
     (let handle = ref handle in
      (let tmp = ref null in
       (let sntl3 = ref null in
        (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
          (sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
          (if ((! tmp) =. (! sntl3)) then (result := ([@expl:result := handle] ! handle))
           else (result := ([@expl:result := combineAux(self,handle)] combineAux s (! self) (! handle))));
          (! result)))))))
  
  let deleteMin (s: state) (self: reference) : reference diverges
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { not ((s.heap.size[self]) = 0) }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.alloct }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { let rep2 = s.heap.rep[self] in
              forall n: reference.
                (isAllocated s n) ->
                  ((hasNodeType s n) ->
                     ((Rgn.mem n rep2) ->
                        (let otag = old (s.heap.tag[n]) in
                         let okey = old (s.heap.key[n]) in
                         ((s.heap.tag[n]) = otag) /\ ((s.heap.key[n]) = okey)))) }
    ensures { pqueueI s s.pool } =
    let result = ref null in
    (let self = ref self in
     (((result := ([@expl:result := findMin(self)] findMin s (! self)));
       (let tmp = ref null in
        (let sntl3 = ref null in
         (((sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
           (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
           (tmp := ([@expl:tmp := tmp.child] s.heap.child[! tmp]));
           (if ((! tmp) =. (! sntl3))
            then (((assume { (s.heap.size[! self]) = 1 });
                   (s.heap.head <- ([@expl:self.head := sntl] M.add (! self) (! sntl3) s.heap.head))))
            else (((assume { let sz = s.heap.size[! self] in
                             sz > 1 });
                   (tmp := ([@expl:tmp := combine(self,tmp)] combine s (! self) (! tmp)));
                   (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head)))));
           (let sz = ref 0 in
            (((sz := ([@expl:sz := self.size] s.heap.size[! self]));
              (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
              (! result)))))))))))
  
  let decreaseKey (s: state) (self: reference) (handle: reference) (k: int) : unit
    requires { hasPqueueType s self }
    requires { self <> null }
    requires { hasNodeType s handle }
    requires { handle <> null }
    requires { Rgn.mem self s.pool }
    requires { let rep1 = s.heap.rep[self] in
               Rgn.mem handle rep1 }
    requires { 0 <= k }
    requires { let key2 = s.heap.key[handle] in
               k <= key2 }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { PQUEUE.pqueuePub s s.pool }
    requires { pqueueI s s.pool }
    writes { s.heap.child }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.prev }
    writes { s.heap.sibling }
    ensures { result = () }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (s.heap.rep[self]) (singleton self)))) ->
                        ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) }
    ensures { PQUEUE.pqueuePub s s.pool }
    ensures { (s.heap.key[handle]) = k }
    ensures { pqueueI s s.pool } =
    let result = ref () in
    (let self = ref self in
     (let handle = ref handle in
      (let k = ref k in
       (let tmp = ref null in
        (let pos = ref null in
         (let sntl3 = ref null in
          (((sntl3 := ([@expl:sntl := self.sntl] s.heap.sntl[! self]));
            (s.heap.key <- ([@expl:handle.key := k] M.add (! handle) (! k) s.heap.key));
            (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
            (assert { repOk s (! self) });
            (if ((! handle) <>. (! tmp))
             then (((tmp := ([@expl:tmp := handle.sibling] s.heap.sibling[! handle]));
                    (if ((! tmp) <>. (! sntl3))
                     then (((pos := ([@expl:pos := handle.prev] s.heap.prev[! handle]));
                            (s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! tmp) (! pos) s.heap.prev));
                            (assert { repOk s (! self) })))
                     else ());
                    (tmp := ([@expl:tmp := handle.prev] s.heap.prev[! handle]));
                    (if ((! tmp) <>. (! sntl3))
                     then (((pos := ([@expl:pos := tmp.child] s.heap.child[! tmp]));
                            (if ((! pos) =. (! handle))
                             then (((pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                    (s.heap.child <- ([@expl:tmp.child := pos] M.add (! tmp) (! pos) s.heap.child))))
                             else (((assert { not ((s.heap.prev[! handle]) = (! sntl3)) });
                                    (pos := ([@expl:pos := handle.sibling] s.heap.sibling[! handle]));
                                    (s.heap.sibling <- ([@expl:tmp.sibling := pos] M.add (! tmp) (! pos) s.heap.sibling));
                                    (assert {
                                       ((! pos) <> (! sntl3)) ->
                                         (let rep4 = s.heap.rep[! self] in
                                          let s5 = s.heap.sibling[! tmp] in
                                          Rgn.mem s5 rep4) }))));
                            (assert {
                               forall p: reference.
                                 (isAllocated s p) ->
                                   ((hasNodeType s p) ->
                                      (let r = s.heap.rep[! self] in
                                       (not (Rgn.mem p r)) -> (let sib = old (s.heap.sibling[p]) in
                                                               (s.heap.sibling[p]) = sib))) })))
                     else ());
                    (s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! handle) (! sntl3) s.heap.sibling));
                    (pos := ([@expl:pos := self.head] s.heap.head[! self]));
                    (tmp := ([@expl:tmp := link(self,pos,handle)] link s (! self) (! pos) (! handle)));
                    (s.heap.head <- ([@expl:self.head := tmp] M.add (! self) (! tmp) s.heap.head))))
             else ());
            (! result)))))))))
end

module PQUEUE_REL
  
  use prelude.Prelude
  use State
  use PqueueL
  use PqueueR
  
  predicate coupling0 (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_pq: reference) (r_pq: reference) =
    (hasPqueueType l_s l_pq) ->
      ((hasPqueueType r_s r_pq) ->
         (((l_pq <> null) /\ (r_pq <> null)) ->
            ((PreRefperm.idRef pi l_pq r_pq) ->
               (let l_sntl = l_s.heap.sntl[l_pq] in
                let r_sntl = r_s.heap.sntl[r_pq] in
                let l_rep = l_s.heap.rep[l_pq] in
                let r_rep = r_s.heap.rep[r_pq] in
                let l_hd = l_s.heap.head[l_pq] in
                let r_hd = r_s.heap.head[r_pq] in
                let l_sz = l_s.heap.size[l_pq] in
                let r_sz = r_s.heap.size[r_pq] in
                (l_sz = r_sz) /\
                  (((PreRefperm.idRef pi l_hd r_hd) \/ ((l_hd = null) /\ (r_hd = r_sntl))) /\
                     (forall l_n: reference, r_n: reference.
                        (isAllocated l_s l_n) ->
                          ((hasNodeType l_s l_n) ->
                             ((Rgn.mem l_n l_rep) ->
                                ((isAllocated r_s r_n) ->
                                   ((hasNodeType r_s r_n) ->
                                      ((Rgn.mem r_n r_rep) ->
                                         ((PreRefperm.idRef pi l_n r_n) ->
                                            (let l_k = l_s.heap.key[l_n] in
                                             let r_k = r_s.heap.key[r_n] in
                                             let l_t = l_s.heap.tag[l_n] in
                                             let r_t = r_s.heap.tag[r_n] in
                                             let l_pre = l_s.heap.prev[l_n] in
                                             let r_pre = r_s.heap.prev[r_n] in
                                             let l_sib = l_s.heap.sibling[l_n] in
                                             let r_sib = r_s.heap.sibling[r_n] in
                                             let l_chl = l_s.heap.child[l_n] in
                                             let r_chl = r_s.heap.child[r_n] in
                                             (l_k = r_k) /\
                                               ((l_t = r_t) /\
                                                  ((((PreRefperm.idRef pi l_pre r_pre) /\ ((l_pre <> null) /\ (r_pre <> r_sntl))) \/
                                                      ((l_pre = null) /\ (r_pre = r_sntl))) /\
                                                     ((((PreRefperm.idRef pi l_sib r_sib) /\ ((l_sib <> null) /\ (r_sib <> r_sntl))) \/
                                                         ((l_sib = null) /\ (r_sib = r_sntl))) /\
                                                        (((PreRefperm.idRef pi l_chl r_chl) /\ ((l_chl <> null) /\ (r_chl <> r_sntl))) \/
                                                           ((l_chl = null) /\ (r_chl = r_sntl)))))))))))))))))))
  
  predicate coupling (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_pl: rgn) (r_pl: rgn) =
    (forall l_pq: reference, r_pq: reference.
       (isAllocated l_s l_pq) ->
         ((hasPqueueType l_s l_pq) ->
            ((Rgn.mem l_pq l_pl) ->
               ((isAllocated r_s r_pq) ->
                  ((hasPqueueType r_s r_pq) ->
                     ((Rgn.mem r_pq r_pl) -> ((PreRefperm.idRef pi l_pq r_pq) -> (coupling0 l_s r_s pi l_pq r_pq)))))))) /\
      (((PqueueL.pqueueI l_s l_pl) /\ (PqueueR.pqueueI r_s r_pl)) /\
         ((PqueueL.PQUEUE.pqueuePub l_s l_pl) /\ (PqueueR.PQUEUE.pqueuePub r_s r_pl)))
  
  let isEmpty (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi l_s.pool r_s.pool }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (agree_size l_s r_s pi (singleton l_self)) /\ (agree_size r_s l_s (PreRefperm.invert pi) (singleton r_self)) }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi l_s.pool r_s.pool }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              ((((((((((((((((((((((((agree_head l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_head r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) /\
                                      ((agree_size l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                         (agree_size r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                     ((agree_rep l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                        (agree_rep r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                    ((agree_sntl l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_sntl r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                   ((agree_length l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                      (agree_length r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                  ((agree_slots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                     (agree_slots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                 ((agree_tag l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                    (agree_tag r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                ((agree_key l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                   (agree_key r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                               ((agree_prev l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                  (agree_prev r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                              ((agree_sibling l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                 (agree_sibling r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                             ((agree_child l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                (agree_child r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                            ((agree_adjList l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                               (agree_adjList r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                           ((agree_numVerts l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                              (agree_numVerts r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                          ((agree_eSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                             (agree_eSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                         ((agree_eLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                            (agree_eLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                        ((agree_wght l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                           (agree_wght r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                       ((agree_endv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                          (agree_endv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                      ((agree_strv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                         (agree_strv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                     ((agree_dSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                        (agree_dSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                    ((agree_dLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                       (agree_dLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                   ((agree_bSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                      (agree_bSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                  ((agree_bLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                     (agree_bLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                 ((agree_bagEdges l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                    (agree_bagEdges r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                ((agree_bagNode l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                   (agree_bagNode r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) } =
    let l_result = ref false in
    (let r_result = ref false in
     (let l_self = ref l_self in
      (let r_self = ref r_self in
       (let l_sz = ref 0 in
        (let r_sz = ref 0 in
         (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
             (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
           (l_result := ([@expl:result := sz = 0] (! l_sz) = 0));
           (r_result := ([@expl:result := sz = 0] (! r_sz) = 0));
           (! l_result, ! r_result))))))))
  
  let findMin (l_s: state) (r_s: state) (pi6: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi6 }
    requires { coupling l_s r_s pi6 l_s.pool r_s.pool }
    requires { PreRefperm.idRef pi6 l_self r_self }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { okRefperm l_s r_s pi6 }
    ensures { coupling l_s r_s pi6 l_s.pool r_s.pool }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi6 l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let hd = l_s.heap.head[l_self] in
                      l_result = hd) /\ (let hd = r_s.heap.head[r_self] in
                                         r_result = hd))
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              ((((((((((((((((((((((((agree_head l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_head r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) /\
                                      ((agree_size l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                         (agree_size r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                     ((agree_rep l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                        (agree_rep r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                    ((agree_sntl l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_sntl r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                   ((agree_length l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                      (agree_length r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                  ((agree_slots l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                     (agree_slots r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                 ((agree_tag l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                    (agree_tag r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                ((agree_key l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                   (agree_key r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                               ((agree_prev l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                  (agree_prev r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                              ((agree_sibling l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                 (agree_sibling r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                             ((agree_child l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                (agree_child r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                            ((agree_adjList l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                               (agree_adjList r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                           ((agree_numVerts l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                              (agree_numVerts r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                          ((agree_eSlots l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                             (agree_eSlots r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                         ((agree_eLength l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                            (agree_eLength r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                        ((agree_wght l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                           (agree_wght r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                       ((agree_endv l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                          (agree_endv r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                      ((agree_strv l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                         (agree_strv r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                     ((agree_dSlots l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                        (agree_dSlots r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                    ((agree_dLength l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                       (agree_dLength r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                   ((agree_bSlots l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                      (agree_bSlots r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                  ((agree_bLength l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                     (agree_bLength r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                 ((agree_bagEdges l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                    (agree_bagEdges r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                ((agree_bagNode l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                   (agree_bagNode r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    let l_result = ref null in
    (let r_result = ref null in
     (let l_self = ref l_self in
      (let r_self = ref r_self in
       (((assert {
            (not ((l_s.heap.head[! l_self]) = null)) /\
              (let sntl7 = r_s.heap.sntl[! r_self] in
               not ((r_s.heap.head[! r_self]) = sntl7)) });
         (l_result := ([@expl:result := self.head] l_s.heap.head[! l_self]));
         (r_result := ([@expl:result := self.head] r_s.heap.head[! r_self]));
         (! l_result, ! r_result))))))
  
  val link (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_first: reference) (l_second: reference) (r_self: reference) (r_first: reference) (r_second: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_first }
    requires { l_first <> null }
    requires { hasNodeType l_s l_second }
    requires { l_second <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_first }
    requires { r_first <> null }
    requires { hasNodeType r_s r_second }
    requires { r_second <> null }
    requires { okRefperm l_s r_s pi }
    requires { PreRefperm.idRef pi l_second r_second }
    requires { PreRefperm.idRef pi l_first r_first }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { coupling l_s r_s pi l_s.pool r_s.pool }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (let rep8 = l_s.heap.rep[l_self] in
                (Rgn.mem l_first rep8) /\ (Rgn.mem l_second rep8)) /\
                 (let rep9 = r_s.heap.rep[r_self] in
                  (Rgn.mem r_first rep9) /\ (Rgn.mem r_second rep9)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.child }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.child }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.sibling[p]) = ((old l_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.prev[p]) = ((old l_s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.child[p]) = ((old l_s.heap.child)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.sibling[p]) = ((old r_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.prev[p]) = ((old r_s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.child[p]) = ((old r_s.heap.child)[p])))) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi l_s.pool r_s.pool }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              ((((((((((((((((((((((((agree_head l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_head r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) /\
                                      ((agree_size l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                         (agree_size r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                     ((agree_rep l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                        (agree_rep r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                    ((agree_sntl l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_sntl r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                   ((agree_length l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                      (agree_length r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                  ((agree_slots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                     (agree_slots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                 ((agree_tag l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                    (agree_tag r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                ((agree_key l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                   (agree_key r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                               ((agree_prev l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                  (agree_prev r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                              ((agree_sibling l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                 (agree_sibling r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                             ((agree_child l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                (agree_child r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                            ((agree_adjList l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                               (agree_adjList r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                           ((agree_numVerts l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                              (agree_numVerts r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                          ((agree_eSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                             (agree_eSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                         ((agree_eLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                            (agree_eLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                        ((agree_wght l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                           (agree_wght r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                       ((agree_endv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                          (agree_endv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                      ((agree_strv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                         (agree_strv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                     ((agree_dSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                        (agree_dSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                    ((agree_dLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                       (agree_dLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                   ((agree_bSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                      (agree_bSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                  ((agree_bLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                     (agree_bLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                 ((agree_bagEdges l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                    (agree_bagEdges r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                ((agree_bagNode l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                   (agree_bagNode r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (((l_result = l_first) \/ (l_result = l_second)) /\ ((r_result = r_first) \/ (r_result = r_second)))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((((l_result = l_first) /\ ((l_s.heap.child[l_first]) = l_second)) \/
                        ((l_result = l_second) /\ ((l_s.heap.child[l_second]) = l_first))) /\
                       (((r_result = r_first) /\ ((r_s.heap.child[r_first]) = r_second)) \/
                          ((r_result = r_second) /\ ((r_s.heap.child[r_second]) = r_first))))
              end }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let insert (l_s: state) (r_s: state) (pi10: PreRefperm.t) (l_self: reference) (l_k: int) (l_t: int) (r_self: reference) (r_k: int) (r_t: int) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi10 }
    requires { coupling l_s r_s pi10 l_s.pool r_s.pool }
    requires { l_t = r_t }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi10 l_self r_self }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    requires { (0 <= l_t) /\ (0 <= r_t) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    writes { pi10 }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.rep }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.tag }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.rep }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.tag }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old l_s.alloct)) -> ((p \: l_s.alloct) /\ ((l_s.alloct[p]) = ((old l_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.slots[p]) = ((old l_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.eSlots[p]) = ((old l_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.bSlots[p]) = ((old l_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.dSlots[p]) = ((old l_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.sntl[p]) = ((old l_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.sibling[p]) = ((old l_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.prev[p]) = ((old l_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.head[p]) = ((old l_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.child[p]) = ((old l_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.bagEdges[p]) = ((old l_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.adjList[p]) = ((old l_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.rep[p]) = ((old l_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.wght[p]) = ((old l_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.tag[p]) = ((old l_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.strv[p]) = ((old l_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.size[p]) = ((old l_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.numVerts[p]) = ((old l_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.length[p]) = ((old l_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.key[p]) = ((old l_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.endv[p]) = ((old l_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.eLength[p]) = ((old l_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.dLength[p]) = ((old l_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.bagNode[p]) = ((old l_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.bLength[p]) = ((old l_s.heap.bLength)[p])))) }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old r_s.alloct)) -> ((p \: r_s.alloct) /\ ((r_s.alloct[p]) = ((old r_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.slots[p]) = ((old r_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.eSlots[p]) = ((old r_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.bSlots[p]) = ((old r_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.dSlots[p]) = ((old r_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.sntl[p]) = ((old r_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.sibling[p]) = ((old r_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.prev[p]) = ((old r_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.head[p]) = ((old r_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.child[p]) = ((old r_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.bagEdges[p]) = ((old r_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.adjList[p]) = ((old r_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.rep[p]) = ((old r_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.wght[p]) = ((old r_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.tag[p]) = ((old r_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.strv[p]) = ((old r_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.size[p]) = ((old r_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.numVerts[p]) = ((old r_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.length[p]) = ((old r_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.key[p]) = ((old r_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.endv[p]) = ((old r_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.eLength[p]) = ((old r_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.dLength[p]) = ((old r_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.bagNode[p]) = ((old r_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.bLength[p]) = ((old r_s.heap.bLength)[p])))) }
    ensures { okRefperm l_s r_s pi10 }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep11 = l_s.heap.rep[l_self] in
                      forall n: reference.
                        (isAllocated l_s n) ->
                          ((hasNodeType l_s n) ->
                             ((Rgn.mem n rep11) ->
                                ((n <> l_result) ->
                                   (let ot = old (l_s.heap.tag[n]) in
                                    let ok = old (l_s.heap.key[n]) in
                                    ((l_s.heap.tag[n]) = ot) /\ ((l_s.heap.key[n]) = ok)))))) /\
                       (let rep12 = r_s.heap.rep[r_self] in
                        forall n: reference.
                          (isAllocated r_s n) ->
                            ((hasNodeType r_s n) ->
                               ((Rgn.mem n rep12) ->
                                  ((n <> r_result) ->
                                     (let ot = old (r_s.heap.tag[n]) in
                                      let ok = old (r_s.heap.key[n]) in
                                      ((r_s.heap.tag[n]) = ot) /\ ((r_s.heap.key[n]) = ok)))))))
              end }
    ensures { coupling l_s r_s pi10 l_s.pool r_s.pool }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi10 l_result r_result) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.tag[l_result]) = l_t) /\ ((r_s.heap.tag[r_result]) = r_t)) end }
    ensures { match result with | (l_result, r_result) -> (((l_s.heap.key[l_result]) = l_k) /\ ((r_s.heap.key[r_result]) = r_k)) end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let orep = old (l_s.heap.rep[l_self]) in
                      (l_s.heap.rep[l_self]) = (Rgn.union orep (singleton l_result))) /\
                       (let orep = old (r_s.heap.rep[r_self]) in
                        (r_s.heap.rep[r_self]) = (Rgn.union orep (singleton r_result))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep13 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep13) /\
                       (let rep14 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep14))
              end }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    let l_result = ref null in
    (let r_result = ref null in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let l_t = ref l_t in
        (let r_self = ref r_self in
         (let r_k = ref r_k in
          (let r_t = ref r_t in
           (((assert { coupling0 l_s r_s pi10 (! l_self) (! r_self) });
             (let l_sntl = ref null in
              (let r_sntl = ref null in
               ((((();
                   (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                 (((l_result := ([@expl:result := new Node] mk_Node l_s));
                   (r_result := ([@expl:result := new Node] mk_Node r_s))));
                 ((([@expl:Node(result,k,t)] PqueueL.init_Node l_s (! l_result) (! l_k) (! l_t));
                   ([@expl:Node(result,k,t)] PqueueR.init_Node r_s (! r_result) (! r_k) (! r_t))));
                 ((();
                   (r_s.heap.sibling <- ([@expl:result.sibling := sntl] M.add (! r_result) (! r_sntl) r_s.heap.sibling));
                   (r_s.heap.child <- ([@expl:result.child := sntl] M.add (! r_result) (! r_sntl) r_s.heap.child));
                   (r_s.heap.prev <- ([@expl:result.prev := sntl] M.add (! r_result) (! r_sntl) r_s.heap.prev))));
                 (PreRefperm.updateRefperm pi10 (! l_result) (! r_result));
                 (assert { PreRefperm.idRef pi10 (! l_result) (! r_result) });
                 (assert {
                    (((l_s.heap.sibling[! l_result]) = null) /\
                       (((l_s.heap.child[! l_result]) = null) /\ ((l_s.heap.prev[! l_result]) = null))) /\
                      (((r_s.heap.sibling[! r_result]) = (! r_sntl)) /\
                         (((r_s.heap.child[! r_result]) = (! r_sntl)) /\ ((r_s.heap.prev[! r_result]) = (! r_sntl)))) });
                 (let ghost l_rep = ref emptyRgn in
                  (let ghost r_rep = ref emptyRgn in
                   (((((l_rep := ([@expl:rep := self.rep] l_s.heap.rep[! l_self]));
                       (r_rep := ([@expl:rep := self.rep] r_s.heap.rep[! r_self]))));
                     (((l_s.heap.rep <-
                          ([@expl:self.rep := rep union {result}]
                           M.add (! l_self) (Rgn.union (! l_rep) (singleton (! l_result))) l_s.heap.rep));
                       (r_s.heap.rep <-
                          ([@expl:self.rep := rep union {result}]
                           M.add (! r_self) (Rgn.union (! r_rep) (singleton (! r_result))) r_s.heap.rep))));
                     (let l_hd = ref null in
                      (let r_hd = ref null in
                       (((((l_hd := ([@expl:hd := self.head] l_s.heap.head[! l_self]));
                           (r_hd := ([@expl:hd := self.head] r_s.heap.head[! r_self]))));
                         (assert { ((l_s.heap.head[! l_self]) = null) <-> ((r_s.heap.head[! r_self]) = (! r_sntl)) });
                         ((([@expl:guard agreement] assert { ((! l_hd) = null) = ((! r_hd) = (! r_sntl)) });
                           (if ((! l_hd) =. null)
                            then (((((l_s.heap.head <- ([@expl:self.head := result] M.add (! l_self) (! l_result) l_s.heap.head));
                                     (r_s.heap.head <- ([@expl:self.head := result] M.add (! r_self) (! r_result) r_s.heap.head))));
                                   (assert {
                                      let l_hd = l_s.heap.head[! l_self] in
                                      let r_hd = r_s.heap.head[! r_self] in
                                      PreRefperm.idRef pi10 l_hd r_hd });
                                   (assert {
                                      forall l_pq: reference, r_pq: reference.
                                        (isAllocated l_s l_pq) ->
                                          ((hasPqueueType l_s l_pq) ->
                                             ((Rgn.mem l_pq l_s.pool) ->
                                                ((isAllocated r_s r_pq) ->
                                                   ((hasPqueueType r_s r_pq) ->
                                                      ((Rgn.mem r_pq r_s.pool) ->
                                                         ((PreRefperm.idRef pi10 l_pq r_pq) ->
                                                            (let l_hd = l_s.heap.head[l_pq] in
                                                             let r_hd = r_s.heap.head[r_pq] in
                                                             (PreRefperm.idRef pi10 l_hd r_hd) \/
                                                               ((l_hd = null) /\ ((r_s.heap.sntl[r_pq]) = r_hd))))))))) });
                                   (assert { coupling0 l_s r_s pi10 (! l_self) (! r_self) })))
                            else (((assert { coupling0 l_s r_s pi10 (! l_self) (! r_self) });
                                   (let l_tmp = ref null in
                                    (let r_tmp = ref null in
                                     (((assume {
                                          ((PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool)) /\
                                            ((PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool)) });
                                       (match link l_s r_s pi10 (! l_self) (! l_hd) (! l_result) (! r_self) (! r_hd) (! r_result)
                                        with
                                          | (l_link_res, r_link_res) ->
                                              (((l_tmp := ([@expl:tmp := link(self,hd,result)] l_link_res));
                                                (r_tmp := ([@expl:tmp := link(self,hd,result)] r_link_res))))
                                        end);
                                       (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                                       (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))))))));
                         (let l_sz = ref 0 in
                          (let r_sz = ref 0 in
                           (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                               (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                             (assert { (! l_sz) = (! r_sz) });
                             (((l_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! l_self) ((! l_sz) + 1) l_s.heap.size));
                               (r_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! r_self) ((! r_sz) + 1) r_s.heap.size))));
                             (assume {
                                ((PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool)) /\
                                  ((PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool)) });
                             (! l_result, ! r_result))))))))))))))))))))))))))
  
  val combine (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (r_self: reference) (r_handle: reference) : 
    (reference,
     reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi l_s.pool r_s.pool }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (let rep15 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep15) /\
                 (let rep16 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep16) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.slots }
    writes { l_s.heap.sibling }
    writes { l_s.heap.prev }
    writes { l_s.heap.child }
    writes { l_s.heap.length }
    writes { l_s.alloct }
    writes { r_s.heap.slots }
    writes { r_s.heap.sibling }
    writes { r_s.heap.prev }
    writes { r_s.heap.child }
    writes { r_s.heap.length }
    writes { r_s.alloct }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old l_s.alloct)) -> ((p \: l_s.alloct) /\ ((l_s.alloct[p]) = ((old l_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = NodeArray) -> ((l_s.heap.slots[p]) = ((old l_s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.sibling[p]) = ((old l_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.prev[p]) = ((old l_s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (l_s.heap.rep[l_self]))) -> ((l_s.heap.child[p]) = ((old l_s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = NodeArray) -> ((l_s.heap.length[p]) = ((old l_s.heap.length)[p]))) }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old r_s.alloct)) -> ((p \: r_s.alloct) /\ ((r_s.alloct[p]) = ((old r_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = NodeArray) -> ((r_s.heap.slots[p]) = ((old r_s.heap.slots)[p]))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.sibling[p]) = ((old r_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.prev[p]) = ((old r_s.heap.prev)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (r_s.heap.rep[r_self]))) -> ((r_s.heap.child[p]) = ((old r_s.heap.child)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = NodeArray) -> ((r_s.heap.length[p]) = ((old r_s.heap.length)[p]))) }
    ensures { okRefperm l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              ((((((((((((((((((((((((agree_head l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_head r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) /\
                                      ((agree_size l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                         (agree_size r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                     ((agree_rep l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                        (agree_rep r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                    ((agree_sntl l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                       (agree_sntl r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                   ((agree_length l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                      (agree_length r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                  ((agree_slots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                     (agree_slots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                 ((agree_tag l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                    (agree_tag r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                                ((agree_key l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                   (agree_key r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                               ((agree_prev l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                  (agree_prev r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                              ((agree_sibling l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                 (agree_sibling r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                             ((agree_child l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                                (agree_child r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                            ((agree_adjList l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                               (agree_adjList r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                           ((agree_numVerts l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                              (agree_numVerts r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                          ((agree_eSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                             (agree_eSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                         ((agree_eLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                            (agree_eLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                        ((agree_wght l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                           (agree_wght r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                       ((agree_endv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                          (agree_endv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                      ((agree_strv l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                         (agree_strv r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                     ((agree_dSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                        (agree_dSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                    ((agree_dLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                       (agree_dLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                   ((agree_bSlots l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                      (agree_bSlots r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                  ((agree_bLength l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                     (agree_bLength r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                 ((agree_bagEdges l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                    (agree_bagEdges r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)))) /\
                ((agree_bagNode l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                   (agree_bagNode r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc))) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi l_result r_result) end }
    ensures { coupling l_s r_s pi l_s.pool r_s.pool }
    ensures { (let ohd = old (l_s.heap.head[l_self]) in
               (l_s.heap.head[l_self]) = ohd) /\
                (let ohd = old (r_s.heap.head[r_self]) in
                 (r_s.heap.head[r_self]) = ohd) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep17 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep17) /\
                       (let rep18 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep18))
              end }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  let deleteMin (l_s: state) (r_s: state) (pi19: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi19 }
    requires { PreRefperm.idRef pi19 l_self r_self }
    requires { coupling l_s r_s pi19 l_s.pool r_s.pool }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (not ((l_s.heap.size[l_self]) = 0)) /\ (not ((r_s.heap.size[r_self]) = 0)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.length }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.length }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    writes { r_s.heap.size }
    writes { r_s.heap.slots }
    ensures { match result with | (l_result, _) -> (hasNodeType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasNodeType r_s r_result) end }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old l_s.alloct)) -> ((p \: l_s.alloct) /\ ((l_s.alloct[p]) = ((old l_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.slots[p]) = ((old l_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.eSlots[p]) = ((old l_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bSlots[p]) = ((old l_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.dSlots[p]) = ((old l_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.sntl[p]) = ((old l_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.sibling[p]) = ((old l_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.prev[p]) = ((old l_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.head[p]) = ((old l_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.child[p]) = ((old l_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bagEdges[p]) = ((old l_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.adjList[p]) = ((old l_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.rep[p]) = ((old l_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.wght[p]) = ((old l_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.tag[p]) = ((old l_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.strv[p]) = ((old l_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.size[p]) = ((old l_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.numVerts[p]) = ((old l_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.length[p]) = ((old l_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.key[p]) = ((old l_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.endv[p]) = ((old l_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.eLength[p]) = ((old l_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.dLength[p]) = ((old l_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bagNode[p]) = ((old l_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bLength[p]) = ((old l_s.heap.bLength)[p])))) }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old r_s.alloct)) -> ((p \: r_s.alloct) /\ ((r_s.alloct[p]) = ((old r_s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.slots[p]) = ((old r_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.eSlots[p]) = ((old r_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bSlots[p]) = ((old r_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.dSlots[p]) = ((old r_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.sntl[p]) = ((old r_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.sibling[p]) = ((old r_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.prev[p]) = ((old r_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.head[p]) = ((old r_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.child[p]) = ((old r_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bagEdges[p]) = ((old r_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.adjList[p]) = ((old r_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.rep[p]) = ((old r_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.wght[p]) = ((old r_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.tag[p]) = ((old r_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.strv[p]) = ((old r_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.size[p]) = ((old r_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.numVerts[p]) = ((old r_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.length[p]) = ((old r_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.key[p]) = ((old r_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.endv[p]) = ((old r_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.eLength[p]) = ((old r_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.dLength[p]) = ((old r_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bagNode[p]) = ((old r_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bLength[p]) = ((old r_s.heap.bLength)[p])))) }
    ensures { okRefperm l_s r_s pi19 }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { (let rep20 = l_s.heap.rep[l_self] in
               forall n: reference.
                 (isAllocated l_s n) ->
                   ((hasNodeType l_s n) ->
                      ((Rgn.mem n rep20) ->
                         (let otag = old (l_s.heap.tag[n]) in
                          let okey = old (l_s.heap.key[n]) in
                          ((l_s.heap.tag[n]) = otag) /\ ((l_s.heap.key[n]) = okey))))) /\
                (let rep21 = r_s.heap.rep[r_self] in
                 forall n: reference.
                   (isAllocated r_s n) ->
                     ((hasNodeType r_s n) ->
                        ((Rgn.mem n rep21) ->
                           (let otag = old (r_s.heap.tag[n]) in
                            let okey = old (r_s.heap.key[n]) in
                            ((r_s.heap.tag[n]) = otag) /\ ((r_s.heap.key[n]) = okey))))) }
    ensures { (let orep = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = orep) /\
                (let orep = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = orep) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { match result with | (l_result, r_result) -> (PreRefperm.idRef pi19 l_result r_result) end }
    ensures { coupling l_s r_s pi19 l_s.pool r_s.pool }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    let l_result = ref null in
    (let r_result = ref null in
     (let l_self = ref l_self in
      (let r_self = ref r_self in
       (((match findMin l_s r_s pi19 (! l_self) (! r_self)
          with
            | (l_findMin_res, r_findMin_res) ->
                (((l_result := ([@expl:result := findMin(self)] l_findMin_res));
                  (r_result := ([@expl:result := findMin(self)] r_findMin_res))))
          end);
         (let l_tmp = ref null in
          (let r_tmp = ref null in
           (let l_sntl = ref null in
            (let r_sntl = ref null in
             ((((();
                 (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
               (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                 (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
               (((l_tmp := ([@expl:tmp := tmp.child] l_s.heap.child[! l_tmp]));
                 (r_tmp := ([@expl:tmp := tmp.child] r_s.heap.child[! r_tmp]))));
               ((([@expl:guard agreement] assert { ((! l_tmp) = null) = ((! r_tmp) = (! r_sntl)) });
                 (if ((! l_tmp) =. null)
                  then (((assume { ((l_s.heap.size[! l_self]) = 1) /\ ((r_s.heap.size[! r_self]) = 1) });
                         (l_s.heap.head <- ([@expl:self.head := null] M.add (! l_self) null l_s.heap.head));
                         (r_s.heap.head <- ([@expl:self.head := sntl] M.add (! r_self) (! r_sntl) r_s.heap.head))))
                  else (((assume { (let sz = l_s.heap.size[! l_self] in
                                    sz > 1) /\ (let sz = r_s.heap.size[! r_self] in
                                                sz > 1) });
                         (match combine l_s r_s pi19 (! l_self) (! l_tmp) (! r_self) (! r_tmp)
                          with
                            | (l_combine_res, r_combine_res) ->
                                (((l_tmp := ([@expl:tmp := combine(self,tmp)] l_combine_res));
                                  (r_tmp := ([@expl:tmp := combine(self,tmp)] r_combine_res))))
                          end);
                         (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                         (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head)))))));
               (let l_sz = ref 0 in
                (let r_sz = ref 0 in
                 (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                     (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                   (((l_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! l_self) ((! l_sz) - 1) l_s.heap.size));
                     (r_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! r_self) ((! r_sz) - 1) r_s.heap.size))));
                   (assume { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) });
                   (! l_result, ! r_result))))))))))))))))
  
  let decreaseKey (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_handle: reference) (l_k: int) (r_self: reference) (r_handle: reference) (r_k: int) : 
    (unit,
     unit)
    requires { hasPqueueType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_handle }
    requires { l_handle <> null }
    requires { hasPqueueType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_handle }
    requires { r_handle <> null }
    requires { okRefperm l_s r_s pi }
    requires { coupling l_s r_s pi l_s.pool r_s.pool }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_handle r_handle }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    requires { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (let key22 = l_s.heap.key[l_handle] in
                l_k <= key22) /\ (let key23 = r_s.heap.key[r_handle] in
                                  r_k <= key23) }
    requires { (0 <= l_k) /\ (0 <= r_k) }
    requires { (let rep24 = l_s.heap.rep[l_self] in
                Rgn.mem l_handle rep24) /\
                 (let rep25 = r_s.heap.rep[r_self] in
                  Rgn.mem r_handle rep25) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.child }
    writes { l_s.heap.head }
    writes { l_s.heap.key }
    writes { l_s.heap.prev }
    writes { l_s.heap.sibling }
    writes { r_s.heap.child }
    writes { r_s.heap.head }
    writes { r_s.heap.key }
    writes { r_s.heap.prev }
    writes { r_s.heap.sibling }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.slots[p]) = ((old l_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.eSlots[p]) = ((old l_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bSlots[p]) = ((old l_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.dSlots[p]) = ((old l_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.sntl[p]) = ((old l_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.sibling[p]) = ((old l_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.prev[p]) = ((old l_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.head[p]) = ((old l_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.child[p]) = ((old l_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bagEdges[p]) = ((old l_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.adjList[p]) = ((old l_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.rep[p]) = ((old l_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.wght[p]) = ((old l_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.tag[p]) = ((old l_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.strv[p]) = ((old l_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.size[p]) = ((old l_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.numVerts[p]) = ((old l_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.length[p]) = ((old l_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.key[p]) = ((old l_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.endv[p]) = ((old l_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.eLength[p]) = ((old l_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.dLength[p]) = ((old l_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bagNode[p]) = ((old l_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old l_s.alloct)) ->
                  (((l_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (l_s.heap.rep[l_self]) (singleton l_self)))) ->
                        ((l_s.heap.bLength[p]) = ((old l_s.heap.bLength)[p])))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.slots[p]) = ((old r_s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.eSlots[p]) = ((old r_s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bSlots[p]) = ((old r_s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.dSlots[p]) = ((old r_s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.sntl[p]) = ((old r_s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.sibling[p]) = ((old r_s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.prev[p]) = ((old r_s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.head[p]) = ((old r_s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.child[p]) = ((old r_s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bagEdges[p]) = ((old r_s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.adjList[p]) = ((old r_s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.rep[p]) = ((old r_s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.wght[p]) = ((old r_s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.tag[p]) = ((old r_s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.strv[p]) = ((old r_s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.size[p]) = ((old r_s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.numVerts[p]) = ((old r_s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.length[p]) = ((old r_s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.key[p]) = ((old r_s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.endv[p]) = ((old r_s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.eLength[p]) = ((old r_s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.dLength[p]) = ((old r_s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bagNode[p]) = ((old r_s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old r_s.alloct)) ->
                  (((r_s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (r_s.heap.rep[r_self]) (singleton r_self)))) ->
                        ((r_s.heap.bLength[p]) = ((old r_s.heap.bLength)[p])))) }
    ensures { okRefperm l_s r_s pi }
    ensures { coupling l_s r_s pi l_s.pool r_s.pool }
    ensures { (PqueueL.pqueueI l_s l_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool) }
    ensures { (PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueR.PQUEUE.pqueuePub r_s r_s.pool) }
    ensures { ((l_s.heap.key[l_handle]) = l_k) /\ ((r_s.heap.key[r_handle]) = r_k) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_handle = ref l_handle in
       (let l_k = ref l_k in
        (let r_self = ref r_self in
         (let r_handle = ref r_handle in
          (let r_k = ref r_k in
           (let l_tmp = ref null in
            (let r_tmp = ref null in
             (let l_pos = ref null in
              (let r_pos = ref null in
               (let l_sntl = ref null in
                (let r_sntl = ref null in
                 ((((();
                     (r_sntl := ([@expl:sntl := self.sntl] r_s.heap.sntl[! r_self]))));
                   (((l_s.heap.key <- ([@expl:handle.key := k] M.add (! l_handle) (! l_k) l_s.heap.key));
                     (r_s.heap.key <- ([@expl:handle.key := k] M.add (! r_handle) (! r_k) r_s.heap.key))));
                   (((l_tmp := ([@expl:tmp := self.head] l_s.heap.head[! l_self]));
                     (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                   ((([@expl:guard agreement] assert { ((! l_handle) <> (! l_tmp)) = ((! r_handle) <> (! r_tmp)) });
                     (if ((! l_handle) <>. (! l_tmp))
                      then (((((l_tmp := ([@expl:tmp := handle.sibling] l_s.heap.sibling[! l_handle]));
                               (r_tmp := ([@expl:tmp := handle.sibling] r_s.heap.sibling[! r_handle]))));
                             ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                               (if ((! l_tmp) <>. null)
                                then (((((l_pos := ([@expl:pos := handle.prev] l_s.heap.prev[! l_handle]));
                                         (r_pos := ([@expl:pos := handle.prev] r_s.heap.prev[! r_handle]))));
                                       (l_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! l_tmp) (! l_pos) l_s.heap.prev));
                                       (r_s.heap.prev <- ([@expl:tmp.prev := pos] M.add (! r_tmp) (! r_pos) r_s.heap.prev))))
                                else ((();
                                       ())))));
                             (((l_tmp := ([@expl:tmp := handle.prev] l_s.heap.prev[! l_handle]));
                               (r_tmp := ([@expl:tmp := handle.prev] r_s.heap.prev[! r_handle]))));
                             ((([@expl:guard agreement] assert { ((! l_tmp) <> null) = ((! r_tmp) <> (! r_sntl)) });
                               (if ((! l_tmp) <>. null)
                                then (((((l_pos := ([@expl:pos := tmp.child] l_s.heap.child[! l_tmp]));
                                         (r_pos := ([@expl:pos := tmp.child] r_s.heap.child[! r_tmp]))));
                                       (assert {
                                          ((not ((l_s.heap.prev[! l_handle]) = null)) /\ (not ((r_s.heap.prev[! r_handle]) = null))) /\
                                            (not ((r_s.heap.prev[! r_handle]) = (! r_sntl))) });
                                       (assert {
                                          (PreRefperm.idRef pi (! l_tmp) (! r_tmp)) /\
                                            (((! l_tmp) <> null) /\ ((! r_tmp) <> (! r_sntl))) });
                                       (assert {
                                          let l_c = l_s.heap.child[! l_tmp] in
                                          let r_c = r_s.heap.child[! r_tmp] in
                                          ((PreRefperm.idRef pi l_c r_c) /\ ((l_c <> null) /\ (r_c <> (! r_sntl)))) \/
                                            ((l_c = null) /\ (r_c = (! r_sntl))) });
                                       ([@expl:guard agreement] assert { ((! l_pos) = (! l_handle)) = ((! r_pos) = (! r_handle)) });
                                       (if ((! l_pos) =. (! l_handle))
                                        then (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                 (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                               (l_s.heap.child <- ([@expl:tmp.child := pos] M.add (! l_tmp) (! l_pos) l_s.heap.child));
                                               (r_s.heap.child <- ([@expl:tmp.child := pos] M.add (! r_tmp) (! r_pos) r_s.heap.child))))
                                        else (((((l_pos := ([@expl:pos := handle.sibling] l_s.heap.sibling[! l_handle]));
                                                 (r_pos := ([@expl:pos := handle.sibling] r_s.heap.sibling[! r_handle]))));
                                               (l_s.heap.sibling <-
                                                  ([@expl:tmp.sibling := pos] M.add (! l_tmp) (! l_pos) l_s.heap.sibling));
                                               (r_s.heap.sibling <-
                                                  ([@expl:tmp.sibling := pos] M.add (! r_tmp) (! r_pos) r_s.heap.sibling)))))))
                                else ((();
                                       ())))));
                             (((l_s.heap.sibling <- ([@expl:handle.sibling := null] M.add (! l_handle) null l_s.heap.sibling));
                               (r_s.heap.sibling <- ([@expl:handle.sibling := sntl] M.add (! r_handle) (! r_sntl) r_s.heap.sibling))));
                             (((l_pos := ([@expl:pos := self.head] l_s.heap.head[! l_self]));
                               (r_pos := ([@expl:pos := self.head] r_s.heap.head[! r_self]))));
                             (assume {
                                ((PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueL.pqueueI l_s l_s.pool)) /\
                                  ((PqueueR.PQUEUE.pqueuePub r_s r_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool)) });
                             (match link l_s r_s pi (! l_self) (! l_pos) (! l_handle) (! r_self) (! r_pos) (! r_handle)
                              with
                                | (l_link_res, r_link_res) ->
                                    (((l_tmp := ([@expl:tmp := link(self,pos,handle)] l_link_res));
                                      (r_tmp := ([@expl:tmp := link(self,pos,handle)] r_link_res))))
                              end);
                             (l_s.heap.head <- ([@expl:self.head := tmp] M.add (! l_self) (! l_tmp) l_s.heap.head));
                             (r_s.heap.head <- ([@expl:self.head := tmp] M.add (! r_self) (! r_tmp) r_s.heap.head))))
                      else ((();
                             ())))));
                   (assume {
                      ((PqueueL.PQUEUE.pqueuePub l_s l_s.pool) /\ (PqueueL.pqueueI l_s l_s.pool)) /\
                        ((PqueueR.PQUEUE.pqueuePub r_s r_s.pool) /\ (PqueueR.pqueueI r_s r_s.pool)) });
                   (! l_result, ! r_result))))))))))))))))
end

module GRAPH
  
  use prelude.Prelude
  use State
  
  predicate edgeWeightInv (s: state) (edg: reference) (k: int) =
    (hasEdgeType s edg) -> ((edg <> null) -> (let weight = s.heap.wght[edg] in
                                              (0 <= weight) /\ (weight < k)))
  
  predicate edgeArrayWeightInv (s: state) (edgs: reference) (k: int) =
    (hasEdgeArrayType s edgs) ->
      ((edgs <> null) ->
         (let len = s.heap.eLength[edgs] in
          forall i: int. (0 <= i) -> ((i < len) -> (let edg = A.get (s.heap.eSlots[edgs]) i in
                                                    edgeWeightInv s edg k))))
  
  predicate bagWeightsInv (s: state) (b: reference) (k: int) =
    (hasBagType s b) -> ((b <> null) -> (let edges = s.heap.bagEdges[b] in
                                         edgeArrayWeightInv s edges k))
  
  predicate bagInv (s: state) (b: reference) =
    (hasBagType s b) ->
      ((b <> null) ->
         (let bNode = s.heap.bagNode[b] in
          let edges = s.heap.bagEdges[b] in
          let len = s.heap.eLength[edges] in
          forall i: int.
            (0 <= i) ->
              ((i < len) -> (let edg = A.get (s.heap.eSlots[edges]) i in
                             ((s.heap.strv[edg]) = bNode) \/ ((s.heap.endv[edg]) = bNode)))))
  
  predicate inRange (s: state) (e: reference) (k: int) =
    (hasEdgeType s e) ->
      ((e <> null) ->
         (let src = s.heap.strv[e] in
          let trgt = s.heap.endv[e] in
          (0 <= src) /\ ((src < k) /\ ((0 <= trgt) /\ (trgt < k)))))
  
  predicate edgesInRange (s: state) (edgs: reference) (k: int) =
    (hasEdgeArrayType s edgs) ->
      ((edgs <> null) ->
         (let len = s.heap.eLength[edgs] in
          forall i: int. (0 <= i) -> ((i < len) -> (let edg = A.get (s.heap.eSlots[edgs]) i in
                                                    inRange s edg k))))
  
  predicate bagInRange (s: state) (b: reference) (k: int) =
    (hasBagType s b) -> ((b <> null) -> (let edgs = s.heap.bagEdges[b] in
                                         edgesInRange s edgs k))
  
  predicate graphInv (s: state) (g: reference) =
    (hasGraphType s g) ->
      ((g <> null) ->
         (let adjLs = s.heap.adjList[g] in
          let numVs = s.heap.numVerts[g] in
          ((s.heap.bLength[adjLs]) = numVs) /\
            ((forall i: int. (0 <= i) -> ((i < numVs) -> (let v = A.get (s.heap.bSlots[adjLs]) i in
                                                          v <> null))) /\
               (forall i: int.
                  (0 <= i) ->
                    ((i < numVs) ->
                       (let bag = A.get (s.heap.bSlots[adjLs]) i in
                        (bagInRange s bag numVs) /\ ((bagInv s bag) /\ (((s.heap.bagNode[bag]) = i) /\ (bagWeightsInv s bag 100)))))))))
  
  predicate hasVertex (s: state) (g: reference) (v: int) =
    (hasGraphType s g) -> ((g <> null) -> (let numVerts1 = s.heap.numVerts[g] in
                                           (0 <= v) /\ (v < numVerts1)))
  
  val getEdges (s: state) (g: reference) : reference
    requires { hasGraphType s g }
    requires { g <> null }
    requires { graphInv s g }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasEdgeArrayType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { graphInv s g }
    ensures { let numVs = s.heap.numVerts[g] in
              edgesInRange s result numVs }
    ensures { let len = s.heap.eLength[result] in
              forall i: int.
                (0 <= i) -> ((i < len) -> (let edg = A.get (s.heap.eSlots[result]) i in
                                           (edg <> null) /\ (edgeWeightInv s edg 100))) }
    ensures { let oa = old s.alloct.M.domain in
              (Rgn.diff s.alloct.M.domain oa) = (singleton result) }
end

module CLIENT
  
  use prelude.Prelude
  use State
end

module Client
  use prelude.Prelude
  use State
  use CLIENT
  use PQUEUE
  use GRAPH
  
  val initDistances (s: state) (d: reference) (k: int) : unit
    requires { hasDistArrayType s d }
    requires { d <> null }
    writes { s.heap.dSlots }
    ensures { result = () }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = DistArray) -> ((p <> d) -> ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { let len = s.heap.dLength[d] in
              forall i: int. (0 <= i) -> ((i < len) -> ((A.get (s.heap.dSlots[d]) i) = k)) }
  
  let dijkstra_NODEC (s: state) (g: reference) (source: int) : reference diverges
    requires { hasGraphType s g }
    requires { g <> null }
    requires { s.pool = emptyRgn }
    requires { GRAPH.graphInv s g }
    requires { GRAPH.hasVertex s g source }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.adjList }
    writes { s.heap.bLength }
    writes { s.heap.bSlots }
    writes { s.heap.bagEdges }
    writes { s.heap.bagNode }
    writes { s.heap.child }
    writes { s.heap.dLength }
    writes { s.heap.dSlots }
    writes { s.heap.eLength }
    writes { s.heap.eSlots }
    writes { s.heap.endv }
    writes { s.heap.head }
    writes { s.heap.key }
    writes { s.heap.length }
    writes { s.heap.numVerts }
    writes { s.heap.prev }
    writes { s.heap.rep }
    writes { s.heap.sibling }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.sntl }
    writes { s.heap.strv }
    writes { s.heap.tag }
    writes { s.heap.wght }
    ensures { result <> null }
    ensures { hasDistArrayType s result }
    ensures { [@expl:wr frame alloc]
              forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ ((s.alloct[p]) = ((old s.alloct)[p]))) }
    ensures { [@expl:write frame slots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.slots[p]) = ((old s.heap.slots)[p])))) }
    ensures { [@expl:write frame eSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.eSlots[p]) = ((old s.heap.eSlots)[p])))) }
    ensures { [@expl:write frame bSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.bSlots[p]) = ((old s.heap.bSlots)[p])))) }
    ensures { [@expl:write frame dSlots]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.dSlots[p]) = ((old s.heap.dSlots)[p])))) }
    ensures { [@expl:write frame sntl]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.sntl[p]) = ((old s.heap.sntl)[p])))) }
    ensures { [@expl:write frame sibling]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.sibling[p]) = ((old s.heap.sibling)[p])))) }
    ensures { [@expl:write frame prev]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.prev[p]) = ((old s.heap.prev)[p])))) }
    ensures { [@expl:write frame head]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.head[p]) = ((old s.heap.head)[p])))) }
    ensures { [@expl:write frame child]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.child[p]) = ((old s.heap.child)[p])))) }
    ensures { [@expl:write frame bagEdges]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.bagEdges[p]) = ((old s.heap.bagEdges)[p])))) }
    ensures { [@expl:write frame adjList]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.adjList[p]) = ((old s.heap.adjList)[p])))) }
    ensures { [@expl:write frame rep]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (Rgn.union (img_rep s s.pool) s.pool) s.pool))) ->
                        ((s.heap.rep[p]) = ((old s.heap.rep)[p])))) }
    ensures { [@expl:write frame wght]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.wght[p]) = ((old s.heap.wght)[p])))) }
    ensures { [@expl:write frame tag]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.tag[p]) = ((old s.heap.tag)[p])))) }
    ensures { [@expl:write frame strv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.strv[p]) = ((old s.heap.strv)[p])))) }
    ensures { [@expl:write frame size]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Pqueue) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.size[p]) = ((old s.heap.size)[p])))) }
    ensures { [@expl:write frame numVerts]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Graph) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.numVerts[p]) = ((old s.heap.numVerts)[p])))) }
    ensures { [@expl:write frame length]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = NodeArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.length[p]) = ((old s.heap.length)[p])))) }
    ensures { [@expl:write frame key]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Node) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.key[p]) = ((old s.heap.key)[p])))) }
    ensures { [@expl:write frame endv]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Edge) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.endv[p]) = ((old s.heap.endv)[p])))) }
    ensures { [@expl:write frame eLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = EdgeArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.eLength[p]) = ((old s.heap.eLength)[p])))) }
    ensures { [@expl:write frame dLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = DistArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.dLength[p]) = ((old s.heap.dLength)[p])))) }
    ensures { [@expl:write frame bagNode]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = Bag) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.bagNode[p]) = ((old s.heap.bagNode)[p])))) }
    ensures { [@expl:write frame bLength]
              forall p: reference.
                (p \: (old s.alloct)) ->
                  (((s.alloct[p]) = BagArray) ->
                     ((not (Rgn.mem p (Rgn.union (img_rep s s.pool) s.pool))) -> ((s.heap.bLength[p]) = ((old s.heap.bLength)[p])))) } =
    let result = ref null in
    (let g = ref g in
     (let source = ref source in
      (let dist = ref null in
       (let queue = ref null in
        (let min = ref null in
         (let minTag = ref 0 in
          (let minKey = ref 0 in
           (let numVs = ref 0 in
            (let ins = ref null in
             (let isEmp = ref false in
              (((numVs := ([@expl:numVs := g.numVerts] s.heap.numVerts[! g]));
                (queue := ([@expl:queue := new Pqueue] mk_Pqueue s));
                ([@expl:Pqueue(queue)] PQUEUE.init_Pqueue s (! queue));
                (((dist := ([@expl:dist := new(DistArray){numVs}] mk_DistArray s));
                  (s.heap.dLength <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (! numVs) s.heap.dLength));
                  (s.heap.dSlots <- ([@expl:dist := new(DistArray){numVs}] M.add (! dist) (A.make (! numVs) 0) s.heap.dSlots))));
                ([@expl:initDistances(dist,100)] initDistances s (! dist) 100);
                (assert {
                   let len = s.heap.dLength[! dist] in
                   forall k: int. (0 <= k) -> ((k < len) -> ((A.get (s.heap.dSlots[! dist]) k) = 100)) });
                (ins := ([@expl:ins := insert(queue,0,source)] PQUEUE.insert s (! queue) 0 (! source)));
                (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                (assume { GRAPH.graphInv s (! g) });
                (min := ([@expl:min := ins] ! ins));
                (while not (! isEmp) do
                   invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                   invariant { GRAPH.graphInv s (! g) }
                   invariant { PQUEUE.pqueuePub s s.pool }
                   invariant { (s.heap.numVerts[! g]) = (! numVs) }
                   invariant { (s.heap.dLength[! dist]) = (! numVs) }
                   invariant {
                     let len = s.heap.dLength[! dist] in
                     forall k: int. (0 <= k) -> ((k < len) -> (let v = A.get (s.heap.dSlots[! dist]) k in
                                                               0 <= v)) }
                   invariant { let rep1 = s.heap.rep[! queue] in
                               Rgn.mem (! min) rep1 }
                   invariant {
                     let rep2 = s.heap.rep[! queue] in
                     forall n: reference.
                       (isAllocated s n) -> ((hasNodeType s n) -> ((Rgn.mem n rep2) -> (let key3 = s.heap.key[n] in
                                                                    key3 >= 0))) }
                   invariant {
                     let rep4 = s.heap.rep[! queue] in
                     let len = s.heap.dLength[! dist] in
                     forall n: reference.
                       (isAllocated s n) ->
                         ((hasNodeType s n) -> ((Rgn.mem n rep4) -> (let tag5 = s.heap.tag[n] in
                                                                    (tag5 >= 0) /\ (tag5 < len)))) }
                   invariant { typeofRgn s (s.heap.rep[! queue]) Node }
                   invariant { typeofRgn s (singleton (! queue)) Pqueue }
                   invariant { typeofRgn s (singleton (! g)) Graph }
                   invariant { typeofRgn s (singleton (! dist)) DistArray }
                   invariant { typeofRgn s (singleton (! min)) Node }
                   invariant { (! dist) <> null }
                   ((min := ([@expl:min := deleteMin(queue)] PQUEUE.deleteMin s (! queue)));
                    (assert { (typeofRgn s (singleton (! min)) Node) /\ (let rep6 = s.heap.rep[! queue] in
                                                                    Rgn.mem (! min) rep6) });
                    (minTag := ([@expl:minTag := min.tag] s.heap.tag[! min]));
                    (assert { ((! minTag) >= 0) /\ (let len = s.heap.dLength[! dist] in
                                                    (! minTag) < len) });
                    (minKey := ([@expl:minKey := min.key] s.heap.key[! min]));
                    (let i = ref 0 in
                     (((i := ([@expl:i := dist.{minTag}] A.get (s.heap.dSlots[! dist]) (! minTag)));
                       (if ((! minKey) < (! i))
                        then (((s.heap.dSlots <-
                                  ([@expl:dist.{minTag} := minKey]
                                   M.add (! dist) (A.set (s.heap.dSlots[! dist]) (! minTag) (! minKey)) s.heap.dSlots));
                               (let eLen = ref 0 in
                                (let edges = ref null in
                                 (((isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                                   (assume { GRAPH.graphInv s (! g) });
                                   (edges := ([@expl:edges := getEdges(g)] GRAPH.getEdges s (! g)));
                                   (eLen := ([@expl:eLen := edges.eLength] s.heap.eLength[! edges]));
                                   (let edge = ref null in
                                    (((edge := ([@expl:edge := null] null));
                                      (i := ([@expl:i := 0] 0));
                                      (while (0 <= (! i))  && ((! i) < (! eLen)) do
                                         invariant { (! isEmp) <-> ((s.heap.size[! queue]) = 0) }
                                         invariant { (s.heap.eLength[! edges]) = (! eLen) }
                                         invariant { 0 <= (! i) }
                                         invariant { (! i) <= (! eLen) }
                                         invariant { (s.heap.numVerts[! g]) = (! numVs) }
                                         invariant { (s.heap.dLength[! dist]) = (! numVs) }
                                         invariant { GRAPH.graphInv s (! g) }
                                         invariant { GRAPH.edgesInRange s (! edges) (! numVs) }
                                         invariant { PQUEUE.pqueuePub s s.pool }
                                         invariant {
                                           let len = s.heap.dLength[! dist] in
                                           forall k: int.
                                             (0 <= k) -> ((k < len) -> (let v = A.get (s.heap.dSlots[! dist]) k in
                                                                    0 <= v)) }
                                         invariant { let rep7 = s.heap.rep[! queue] in
                                                     Rgn.mem (! min) rep7 }
                                         invariant {
                                           let rep8 = s.heap.rep[! queue] in
                                           forall n: reference.
                                             (isAllocated s n) ->
                                               ((hasNodeType s n) -> ((Rgn.mem n rep8) -> (let key9 = s.heap.key[n] in
                                                                    key9 >= 0))) }
                                         invariant {
                                           let rep10 = s.heap.rep[! queue] in
                                           let len = s.heap.dLength[! dist] in
                                           forall n: reference.
                                             (isAllocated s n) ->
                                               ((hasNodeType s n) ->
                                                  ((Rgn.mem n rep10) -> (let tag11 = s.heap.tag[n] in
                                                                    (tag11 >= 0) /\ (tag11 < len)))) }
                                         invariant { typeofRgn s (s.heap.rep[! queue]) Node }
                                         invariant { typeofRgn s (singleton (! queue)) Pqueue }
                                         invariant { typeofRgn s (singleton (! g)) Graph }
                                         invariant { typeofRgn s (singleton (! dist)) DistArray }
                                         invariant { typeofRgn s (singleton (! edges)) EdgeArray }
                                         invariant { typeofRgn s (singleton (! edge)) Edge }
                                         invariant {
                                           forall k: int.
                                             (0 <= k) ->
                                               ((k < (! eLen)) ->
                                                  (let v = A.get (s.heap.eSlots[! edges]) k in
                                                   (v <> null) /\ ((typeofRgn s (singleton v) Edge) /\ (GRAPH.edgeWeightInv s v 100)))) }
                                         invariant { (! dist) <> null }
                                         let startVertex = ref 0 in
                                         (let endVertex = ref 0 in
                                          (let weight = ref 0 in
                                           (((edge := ([@expl:edge := edges.{i}] A.get (s.heap.eSlots[! edges]) (! i)));
                                             (startVertex := ([@expl:startVertex := edge.strv] s.heap.strv[! edge]));
                                             (endVertex := ([@expl:endVertex := edge.endv] s.heap.endv[! edge]));
                                             (weight := ([@expl:weight := edge.wght] s.heap.wght[! edge]));
                                             (assert { (! weight) >= 0 });
                                             (let d = ref 0 in
                                              (let candidateDist = ref 0 in
                                               (((d := ([@expl:d := dist.{startVertex}] A.get (s.heap.dSlots[! dist]) (! startVertex)));
                                                 (candidateDist := ([@expl:candidateDist := d + weight] (! d) + (! weight)));
                                                 (d := ([@expl:d := dist.{endVertex}] A.get (s.heap.dSlots[! dist]) (! endVertex)));
                                                 (if ((! candidateDist) < (! d))
                                                  then (((assert { (! candidateDist) >= 0 });
                                                         (assert { (! endVertex) >= 0 });
                                                         (assert { (s.heap.numVerts[! g]) = (! numVs) });
                                                         (assert { let num = s.heap.dLength[! dist] in
                                                                   (! endVertex) < num });
                                                         (assert { let rep12 = s.heap.rep[! queue] in
                                                                   not (Rgn.mem (! edges) rep12) });
                                                         (ins
                                                            := ([@expl:ins := insert(queue,candidateDist,endVertex)]
                                                                PQUEUE.insert s (! queue) (! candidateDist) (! endVertex)));
                                                         (assert {
                                                            ((s.heap.tag[! ins]) = (! endVertex)) /\
                                                              ((s.heap.key[! ins]) = (! candidateDist)) });
                                                         (assert { GRAPH.edgesInRange s (! edges) (! numVs) });
                                                         (s.heap.dSlots <-
                                                            ([@expl:dist.{endVertex} := candidateDist]
                                                             M.add
                                                                (! dist)
                                                                (A.set (s.heap.dSlots[! dist]) (! endVertex) (! candidateDist))
                                                                s.heap.dSlots))))
                                                  else ());
                                                 (i := ([@expl:i := i + 1] (! i) + 1));
                                                 (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                                                 (assert { (s.heap.numVerts[! g]) = (! numVs) });
                                                 (assume { GRAPH.graphInv s (! g) })))))))))
                                       done))))))))))
                        else ());
                       (isEmp := ([@expl:isEmp := isEmpty(queue)] PQUEUE.isEmpty s (! queue)));
                       (assume { GRAPH.graphInv s (! g) })))))
                 done);
                (result := ([@expl:result := dist] ! dist));
                (! result)))))))))))))
end

