module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  use partition.Partition
  use kruskal_aux.Kruskal_aux
  
  type reftype = 
    | IntArray
    | List
    | Node
    | Ufind
  
  type heap = {
    mutable id : M.t reference ;
    mutable ghost rep : M.t rgn ;
    mutable ghost part : M.t partition ;
    mutable value : M.t int ;
    mutable nxt : M.t reference ;
    mutable head : M.t reference ;
    mutable ghost lrep : M.t rgn ;
    mutable slots : M.t (A.array int) ;
    mutable length : M.t int
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = IntArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\ (((heap.length[p]) >= 0) /\ ((heap.length[p]) = (A.length (heap.slots[p])))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = List) ->
           (((p \: heap.head) /\ (p \: heap.lrep)) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 (forall q: reference. (Rgn.mem q (heap.lrep[p])) -> ((q = null) \/ (q \: alloct)))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.value) /\ (p \: heap.nxt)) /\
              (((heap.nxt[p]) = null) \/ (((heap.nxt[p]) \: alloct) /\ ((alloct[heap.nxt[p]]) = Node))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Ufind) ->
           (((p \: heap.id) /\ ((p \: heap.rep) /\ (p \: heap.part))) /\
              ((((heap.id[p]) = null) \/ (((heap.id[p]) \: alloct) /\ ((alloct[heap.id[p]]) = IntArray))) /\
                 (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct)))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasIntArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = IntArray))
  
  predicate hasListType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = List))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasUfindType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Ufind))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_IntArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result IntArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasIntArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 0) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_List (s: state) : reference
    writes { s.alloct }
    writes { s.heap.head }
    writes { s.heap.lrep }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result List (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasListType s result }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
    ensures { s.heap.lrep = (M.add result emptyRgn (old s.heap.lrep)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.value }
    writes { s.heap.nxt }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.value = (M.add result 0 (old s.heap.value)) }
    ensures { s.heap.nxt = (M.add result null (old s.heap.nxt)) }
  
  val mk_Ufind (s: state) : reference
    writes { s.alloct }
    writes { s.heap.id }
    writes { s.heap.rep }
    writes { s.heap.part }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Ufind (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasUfindType s result }
    ensures { s.heap.id = (M.add result null (old s.heap.id)) }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.part = (M.add result pEmpty (old s.heap.part)) }
  
  function img_value : state -> (rgn -> rgn)
  
  axiom img_value_ax : forall s: state, r: rgn. (img_value s r) = emptyRgn
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn. (img_slots s r) = emptyRgn
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Ufind) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_part : state -> (rgn -> rgn)
  
  axiom img_part_ax : forall s: state, r: rgn. (img_part s r) = emptyRgn
  
  function img_nxt : state -> (rgn -> rgn)
  
  axiom img_nxt_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_nxt s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.nxt[q])))))
  
  function img_lrep : state -> (rgn -> rgn)
  
  axiom img_lrep_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_lrep s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = List) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.lrep[q])))))
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_id : state -> (rgn -> rgn)
  
  axiom img_id_ax : forall s: state, r: rgn, p: reference.
                      (Rgn.mem p (img_id s r)) <->
                        (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Ufind) /\ ((Rgn.mem q r) /\ (p = (s.heap.id[q])))))
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = List) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. (p \: pre.alloct) -> ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_slots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = IntArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.slots[p]) = (post.heap.slots[p]))))
  
  predicate wrs_to_length_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = IntArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.length[p]) = (post.heap.length[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = List) -> ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate wrs_to_lrep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = List) -> ((not (Rgn.mem p r)) -> ((pre.heap.lrep[p]) = (post.heap.lrep[p]))))
  
  predicate wrs_to_value_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.value[p]) = (post.heap.value[p]))))
  
  predicate wrs_to_nxt_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.nxt[p]) = (post.heap.nxt[p]))))
  
  predicate wrs_to_id_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Ufind) -> ((not (Rgn.mem p r)) -> ((pre.heap.id[p]) = (post.heap.id[p]))))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Ufind) -> ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_part_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Ufind) -> ((not (Rgn.mem p r)) -> ((pre.heap.part[p]) = (post.heap.part[p]))))
  
  predicate agree_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.value[o]) = (sr.heap.value[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasIntArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasUfindType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_part (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasUfindType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.part[o]) = (sr.heap.part[pi.lor[o]]))))))
  
  predicate agree_nxt (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.nxt[o]) (sr.heap.nxt[pi.lor[o]]))))))
  
  predicate agree_lrep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasListType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.lrep[o]) (sr.heap.lrep[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasIntArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_id (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasUfindType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.id[o]) (sr.heap.id[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasListType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_slots sl sr pi w) /\
      ((agree_length sl sr pi w) /\
         ((agree_head sl sr pi w) /\
            ((agree_lrep sl sr pi w) /\
               ((agree_value sl sr pi w) /\
                  ((agree_nxt sl sr pi w) /\ ((agree_id sl sr pi w) /\ ((agree_rep sl sr pi w) /\ (agree_part sl sr pi w))))))))
end

module MAIN
  
  use prelude.Prelude
  use State
end

module UNIONFIND
  use prelude.Prelude
  use State
  use export partition.Partition
  
  predicate ufPub (s: state) =
    forall p: reference, q: reference.
      (isAllocated s p) ->
        ((hasUfindType s p) ->
           ((Rgn.mem p s.pool) ->
              ((isAllocated s q) ->
                 ((hasUfindType s q) ->
                    ((Rgn.mem q s.pool) ->
                       ((p <> q) -> (let prep = s.heap.rep[p] in
                                     let qrep = s.heap.rep[q] in
                                     (prep \# qrep) /\ (not (Rgn.mem p qrep)))))))))
  
  val init_Ufind (s: state) (self: reference) (k: int) : unit
    requires { hasUfindType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { (s.heap.rep[self]) = emptyRgn }
    requires { k > 0 }
    requires { ufPub s }
    writes { s.heap.part }
    writes { s.heap.slots }
    writes { s.heap.nxt }
    writes { s.heap.head }
    writes { s.heap.id }
    writes { s.heap.rep }
    writes { s.heap.lrep }
    writes { s.heap.value }
    writes { s.heap.length }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r28 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r28 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.part[self]) = (pMake k) }
    ensures { let prt = s.heap.part[self] in
              (pSize prt) = k }
    ensures { Rgn.mem self s.pool }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (s.heap.rep[self]) (Rgn.diff s.alloct.M.domain oa) }
    ensures { ufPub s }
  
  val find (s: state) (self: reference) (k: int) : int
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= k) /\ (let p = s.heap.part[self] in
                            k < (pSize p)) }
    requires { ufPub s }
    ensures { let bsnap_r28 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r28 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              mem result (pFind k p) }
    ensures { (0 <= result) /\ (let p = s.heap.part[self] in
                                result < (pSize p)) }
    ensures { ufPub s }
  
  val ufUnion (s: state) (self: reference) (x: int) (y: int) : unit
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= x) /\ (let p = s.heap.part[self] in
                            x < (pSize p)) }
    requires { (0 <= y) /\ (let p = s.heap.part[self] in
                            y < (pSize p)) }
    requires { ufPub s }
    writes { s.heap.part }
    writes { s.heap.slots }
    writes { s.heap.nxt }
    writes { s.heap.head }
    writes { s.heap.id }
    writes { s.heap.rep }
    writes { s.heap.lrep }
    writes { s.heap.value }
    writes { s.heap.length }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r28 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r28 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              mem x (pFind y p) }
    ensures { let op = old (s.heap.part[self]) in
              let p = s.heap.part[self] in
              (pSize op) = (pSize p) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { ufPub s }
end

module QuickFind
  
  use prelude.Prelude
  use State
  use UNIONFIND
  
  predicate ufInv (s: state) (p: reference) =
    (hasUfindType s p) ->
      ((p <> null) /\
         (let id1 = s.heap.id[p] in
          (id1 <> null) /\
            (let len = s.heap.length[id1] in
             let prt = s.heap.part[p] in
             (len = (UNIONFIND.pSize prt)) /\
               (((s.heap.rep[p]) = (singleton id1)) /\
                  ((forall x: int. ((0 <= x) /\ (x < len)) -> (let idx = A.get (s.heap.slots[id1]) x in
                                                               (0 <= idx) /\ (idx < len))) /\
                     ((forall x: int.
                         ((0 <= x) /\ (x < len)) -> (let idx = A.get (s.heap.slots[id1]) x in
                                                     (A.get (s.heap.slots[id1]) idx) = idx)) /\
                        (forall x: int, y: int.
                           ((0 <= x) /\ (x < len)) ->
                             (((0 <= y) /\ (y < len)) ->
                                (let idx = A.get (s.heap.slots[id1]) x in
                                 let idy = A.get (s.heap.slots[id1]) y in
                                 (UNIONFIND.mem y (UNIONFIND.pFind x prt)) <-> (idx = idy))))))))))
  
  predicate ufPriv (s: state) = forall p: reference. (isAllocated s p) -> ((hasUfindType s p) -> ((Rgn.mem p s.pool) -> (ufInv s p)))
  
  lemma qfind1 : forall s: state.
                   forall p: reference, x: int.
                     (isAllocated s p) ->
                       ((hasUfindType s p) ->
                          ((Rgn.mem p s.pool) ->
                             ((ufPriv s) ->
                                (let prt = s.heap.part[p] in
                                 let id1 = s.heap.id[p] in
                                 ((0 <= x) /\ (x < (UNIONFIND.pSize prt))) ->
                                   (let idx = A.get (s.heap.slots[id1]) x in
                                    UNIONFIND.mem idx (UNIONFIND.pFind x prt))))))
  
  lemma qfind2 : forall s: state.
                   forall p: reference, x: int, i: int.
                     (isAllocated s p) ->
                       ((hasUfindType s p) ->
                          ((Rgn.mem p s.pool) ->
                             ((ufPriv s) ->
                                (let prt = s.heap.part[p] in
                                 let id1 = s.heap.id[p] in
                                 ((0 <= x) /\ (x < (UNIONFIND.pSize prt))) ->
                                   (((0 <= i) /\ (i < (UNIONFIND.pSize prt))) ->
                                      ((UNIONFIND.mem i (UNIONFIND.pFind x prt)) ->
                                         (((A.get (s.heap.slots[id1]) i) = i) -> ((A.get (s.heap.slots[id1]) x) = i))))))))
  
  let init_Ufind (s: state) (self: reference) (k: int) : unit diverges
    requires { hasUfindType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { (s.heap.rep[self]) = emptyRgn }
    requires { k > 0 }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.id }
    writes { s.heap.length }
    writes { s.heap.part }
    writes { s.heap.rep }
    writes { s.heap.slots }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.part[self]) = (UNIONFIND.pMake k) }
    ensures { let prt = s.heap.part[self] in
              (UNIONFIND.pSize prt) = k }
    ensures { Rgn.mem self s.pool }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (s.heap.rep[self]) (Rgn.diff s.alloct.M.domain oa) }
    ensures { UNIONFIND.ufPub s }
    ensures { ufPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let i = ref 0 in
         (let prt = ref null in
          (((assert { hasIntArrayType s (! prt) });
            (assert { ufPriv s });
            (((prt := ([@expl:prt := new(IntArray){k}] mk_IntArray s));
              (s.heap.length <- ([@expl:prt := new(IntArray){k}] M.add (! prt) (! k) s.heap.length));
              (s.heap.slots <- ([@expl:prt := new(IntArray){k}] M.add (! prt) (A.make (! k) 0) s.heap.slots))));
            (i := ([@expl:i := 0] 0));
            (assert { ufPriv s });
            (assert {
               forall p: reference.
                 (isAllocated s p) ->
                   ((hasUfindType s p) -> ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (not ((s.heap.id[p]) = (! prt)))))) });
            (while (! i) < (! k) do
               invariant { [@expl:locals type invariant] (hasIntArrayType s (! prt)) /\ (hasUfindType s (! self)) }
               invariant { alloc_does_not_shrink (old s) s }
               invariant { [@expl:wr {prt}`slots] wrs_to_slots_framed_by (old s) s (singleton (! prt)) }
               invariant { UNIONFIND.ufPub s }
               invariant { ufPriv s }
               invariant { forall j: int. (0 <= j) -> ((j < (! i)) -> ((A.get (s.heap.slots[! prt]) j) = j)) }
               invariant { (0 <= (! i)) /\ ((! i) <= (! k)) }
               invariant {
                 forall p: reference.
                   (isAllocated s p) ->
                     ((hasUfindType s p) -> ((Rgn.mem p s.pool) -> ((p <> (! self)) -> (not ((s.heap.id[p]) = (! prt)))))) }
               invariant { let s1 = s.heap.slots[! prt] in
                           (A.length s1) = (! k) }
               ((s.heap.slots <- ([@expl:prt.{i} := i] M.add (! prt) (A.set (s.heap.slots[! prt]) (! i) (! i)) s.heap.slots));
                (i := ([@expl:i := i + 1] (! i) + 1)))
             done);
            (s.heap.id <- ([@expl:self.id := prt] M.add (! self) (! prt) s.heap.id));
            (s.heap.part <- ([@expl:self.part := pMake(k)] M.add (! self) (UNIONFIND.pMake (! k)) s.heap.part));
            (let ghost rep2 = ref emptyRgn in
             (((assert { isValidRgn s (! rep2) });
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (rep2 := ([@expl:rep := self.rep] s.heap.rep[! self]));
               (s.heap.rep <- ([@expl:self.rep := rep union {prt}] M.add (! self) (Rgn.union (! rep2) (singleton (! prt))) s.heap.rep));
               (assert { ufInv s (! self) });
               (assert { UNIONFIND.ufPub s });
               (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
               (! result))))))))))
  
  let find (s: state) (self: reference) (k: int) : int
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= k) /\ (let p = s.heap.part[self] in
                            k < (UNIONFIND.pSize p)) }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              UNIONFIND.mem result (UNIONFIND.pFind k p) }
    ensures { (0 <= result) /\ (let p = s.heap.part[self] in
                                result < (UNIONFIND.pSize p)) }
    ensures { UNIONFIND.ufPub s }
    ensures { let id1 = s.heap.id[self] in
              (A.get (s.heap.slots[id1]) result) = result }
    ensures { ufPriv s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (let k = ref k in
        (let id2 = ref null in
         (((assert { hasIntArrayType s (! id2) });
           (assert {
              ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                 ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                true });
           (id2 := ([@expl:id := self.id] s.heap.id[! self]));
           (assert {
              ((Rgn.mem (! id2) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                 ((not (Rgn.mem (! id2) (s.alloct.M.domain at INIT))) \/ ((! id2) = null))) /\
                true });
           (result := ([@expl:result := id.{k}] A.get (s.heap.slots[! id2]) (! k)));
           (! result))))))
  
  let ufUnion (s: state) (self: reference) (x: int) (y: int) : unit diverges
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= x) /\ (let p = s.heap.part[self] in
                            x < (UNIONFIND.pSize p)) }
    requires { (0 <= y) /\ (let p = s.heap.part[self] in
                            y < (UNIONFIND.pSize p)) }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    writes { s.heap.part }
    writes { s.heap.slots }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              UNIONFIND.mem x (UNIONFIND.pFind y p) }
    ensures { let op = old (s.heap.part[self]) in
              let p = s.heap.part[self] in
              (UNIONFIND.pSize op) = (UNIONFIND.pSize p) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { UNIONFIND.ufPub s }
    ensures { ufPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let x = ref x in
        (let y = ref y in
         (let ina = ref null in
          (((assert { hasIntArrayType s (! ina) });
            (let xroot = ref 0 in
             (let yroot = ref 0 in
              (let ghost sid = ref (A.make 0 0) in
               (((assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (ina := ([@expl:ina := self.id] s.heap.id[! self]));
                 (assert {
                    ((Rgn.mem (! ina) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! ina) (s.alloct.M.domain at INIT))) \/ ((! ina) = null))) /\
                      true });
                 (sid := ([@expl:sid := ina.slots] s.heap.slots[! ina]));
                 (assert {
                    (Rgn.subset
                        (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                        (Rgn.union
                            ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                            (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                      true });
                 (xroot := ([@expl:xroot := find(self,x)] find s (! self) (! x)));
                 (assert {
                    (Rgn.subset
                        (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                        (Rgn.union
                            ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                            (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                      true });
                 (yroot := ([@expl:yroot := find(self,y)] find s (! self) (! y)));
                 (if (not ((! xroot) = (! yroot)))
                  then (((assert { ufInv s (! self) });
                         (let ghost prt = ref (any partition) in
                          (((assert {
                               ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                  ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                                 true });
                            (prt := ([@expl:prt := self.part] s.heap.part[! self]));
                            (s.heap.part <-
                               ([@expl:self.part := pUnion(prt,pFind(x,prt),pFind(y,prt))]
                                M.add
                                   (! self)
                                   (UNIONFIND.pUnion (! prt) (UNIONFIND.pFind (! x) (! prt)) (UNIONFIND.pFind (! y) (! prt)))
                                   s.heap.part));
                            (let i = ref 0 in
                             (let len = ref 0 in
                              (((i := ([@expl:i := 0] 0));
                                (assert {
                                   ((Rgn.mem (! ina) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                      ((not (Rgn.mem (! ina) (s.alloct.M.domain at INIT))) \/ ((! ina) = null))) /\
                                     true });
                                (len := ([@expl:len := ina.length] s.heap.length[! ina]));
                                (assert {
                                   forall j: int. ((0 <= j) /\ (j < (! len))) -> ((A.get (s.heap.slots[! ina]) j) = (A.get (! sid) j)) });
                                (while (! i) < (! len) do
                                   invariant { [@expl:locals type invariant] (hasIntArrayType s (! ina)) /\ (hasUfindType s (! self)) }
                                   invariant { alloc_does_not_shrink (old s) s }
                                   invariant { [@expl:wr {ina}`slots] wrs_to_slots_framed_by (old s) s (singleton (! ina)) }
                                   invariant {
                                     forall j: int.
                                       ((0 <= j) /\ (j < (! i))) ->
                                         (let inaj = A.get (s.heap.slots[! ina]) j in
                                          let prt1 = s.heap.part[! self] in
                                          (not (UNIONFIND.mem j (UNIONFIND.pFind (! x) prt1))) ->
                                            ((UNIONFIND.mem j (UNIONFIND.pFind j prt1)) /\
                                               ((inaj = (A.get (! sid) j)) /\ ((A.get (s.heap.slots[! ina]) inaj) = inaj)))) }
                                   invariant {
                                     forall j: int.
                                       ((0 <= j) /\ (j < (! i))) ->
                                         (((A.get (! sid) j) = (! xroot)) -> ((A.get (s.heap.slots[! ina]) j) = (! yroot))) }
                                   invariant {
                                     forall j: int.
                                       ((0 <= j) /\ (j < (! len))) ->
                                         (((A.get (! sid) j) <> (! xroot)) -> ((A.get (s.heap.slots[! ina]) j) = (A.get (! sid) j))) }
                                   invariant {
                                     forall j: int, k2: int.
                                       let prt3 = s.heap.part[! self] in
                                       ((0 <= j) /\ (j < (! i))) ->
                                         (((0 <= k2) /\ (k2 < (! i))) ->
                                            ((UNIONFIND.mem j (UNIONFIND.pFind k2 prt3)) ->
                                               (let inaj = A.get (s.heap.slots[! ina]) j in
                                                (A.get (s.heap.slots[! ina]) k2) = inaj))) }
                                   invariant {
                                     forall j: int.
                                       ((0 <= j) /\ (j < (! i))) ->
                                         (let prt4 = s.heap.part[! self] in
                                          (UNIONFIND.mem j (UNIONFIND.pFind (! x) prt4)) ->
                                            ((A.get (s.heap.slots[! ina]) j) = (! yroot))) }
                                   invariant { (0 <= (! i)) /\ ((! i) <= (! len)) }
                                   invariant {
                                     forall j: int.
                                       (((! i) <= j) /\ (j < (! len))) -> ((A.get (s.heap.slots[! ina]) j) = (A.get (! sid) j)) }
                                   let inai = ref 0 in
                                   (((assert {
                                        ((Rgn.mem (! ina) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                                           ((not (Rgn.mem (! ina) (s.alloct.M.domain at INIT))) \/ ((! ina) = null))) /\
                                          true });
                                     (inai := ([@expl:inai := ina.{i}] A.get (s.heap.slots[! ina]) (! i)));
                                     (if ((! inai) = (! xroot))
                                      then (((assert { (A.get (! sid) (! i)) = (! xroot) });
                                             (s.heap.slots <-
                                                ([@expl:ina.{i} := yroot]
                                                 M.add (! ina) (A.set (s.heap.slots[! ina]) (! i) (! yroot)) s.heap.slots))))
                                      else (assert { (A.get (! sid) (! i)) <> (! xroot) }));
                                     (i := ([@expl:i := i + 1] (! i) + 1))))
                                 done);
                                (assert { (! i) = (! len) });
                                (assert { ufInv s (! self) }))))))))))
                  else ());
                 (! result))))))))))))
  
  lemma boundary_frames_invariant_QuickFind : forall s: state, t: state, pi: 
                                                PreRefperm.t.
                                                (okRefperm s t pi) ->
                                                  ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                     ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                        ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                           ((ufPriv s) -> (ufPriv t)))))
end

module QuickUnion
  
  use prelude.Prelude
  use State
  use UNIONFIND
  
  predicate ufInv (s: state) (p: reference) =
    (hasUfindType s p) ->
      ((p <> null) /\
         (let id1 = s.heap.id[p] in
          (id1 <> null) /\
            (let len = s.heap.length[id1] in
             let prt = s.heap.part[p] in
             (len = (UNIONFIND.pSize prt)) /\
               (((s.heap.rep[p]) = (singleton id1)) /\
                  ((forall x: int. ((0 <= x) /\ (x < len)) -> (let idx = A.get (s.heap.slots[id1]) x in
                                                               (0 <= idx) /\ (idx < len))) /\
                     (forall x: int.
                        ((0 <= x) /\ (x < len)) -> (let idx = A.get (s.heap.slots[id1]) x in
                                                    UNIONFIND.mem idx (UNIONFIND.pFind x prt))))))))
  
  predicate ufPriv (s: state) = forall p: reference. (isAllocated s p) -> ((hasUfindType s p) -> ((Rgn.mem p s.pool) -> (ufInv s p)))
  
  let init_Ufind (s: state) (self: reference) (k: int) : unit diverges
    requires { hasUfindType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { (s.heap.rep[self]) = emptyRgn }
    requires { k > 0 }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.id }
    writes { s.heap.length }
    writes { s.heap.part }
    writes { s.heap.rep }
    writes { s.heap.slots }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r10 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r10 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.part[self]) = (UNIONFIND.pMake k) }
    ensures { let prt = s.heap.part[self] in
              (UNIONFIND.pSize prt) = k }
    ensures { Rgn.mem self s.pool }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (s.heap.rep[self]) (Rgn.diff s.alloct.M.domain oa) }
    ensures { UNIONFIND.ufPub s }
    ensures { ufPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let i = ref 0 in
         (let ina = ref null in
          (((assert { hasIntArrayType s (! ina) });
            (((ina := ([@expl:ina := new(IntArray){k}] mk_IntArray s));
              (s.heap.length <- ([@expl:ina := new(IntArray){k}] M.add (! ina) (! k) s.heap.length));
              (s.heap.slots <- ([@expl:ina := new(IntArray){k}] M.add (! ina) (A.make (! k) 0) s.heap.slots))));
            (i := ([@expl:i := 0] 0));
            (while (! i) < (! k) do
               invariant { [@expl:locals type invariant] (hasIntArrayType s (! ina)) /\ (hasUfindType s (! self)) }
               invariant { alloc_does_not_shrink (old s) s }
               invariant { [@expl:wr {ina}`slots] wrs_to_slots_framed_by (old s) s (singleton (! ina)) }
               invariant { forall j: int. (0 <= j) -> ((j < (! i)) -> ((A.get (s.heap.slots[! ina]) j) = j)) }
               invariant { (0 <= (! i)) /\ ((! i) <= (! k)) }
               ((s.heap.slots <- ([@expl:ina.{i} := i] M.add (! ina) (A.set (s.heap.slots[! ina]) (! i) (! i)) s.heap.slots));
                (i := ([@expl:i := i + 1] (! i) + 1)))
             done);
            (s.heap.id <- ([@expl:self.id := ina] M.add (! self) (! ina) s.heap.id));
            (s.heap.part <- ([@expl:self.part := pMake(k)] M.add (! self) (UNIONFIND.pMake (! k)) s.heap.part));
            (let ghost rep1 = ref emptyRgn in
             (((assert { isValidRgn s (! rep1) });
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (rep1 := ([@expl:rep := self.rep] s.heap.rep[! self]));
               (s.heap.rep <- ([@expl:self.rep := rep union {ina}] M.add (! self) (Rgn.union (! rep1) (singleton (! ina))) s.heap.rep));
               (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
               (! result))))))))))
  
  let find (s: state) (self: reference) (k: int) : int diverges
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= k) /\ (let p = s.heap.part[self] in
                            k < (UNIONFIND.pSize p)) }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    ensures { let bsnap_r10 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r10 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              UNIONFIND.mem result (UNIONFIND.pFind k p) }
    ensures { (0 <= result) /\ (let p = s.heap.part[self] in
                                result < (UNIONFIND.pSize p)) }
    ensures { UNIONFIND.ufPub s }
    ensures { let id1 = s.heap.id[self] in
              (A.get (s.heap.slots[id1]) result) = result }
    ensures { ufPriv s } =
    label INIT in
      let result = ref 0 in
      (let self = ref self in
       (let k = ref k in
        (let id2 = ref null in
         (((assert { hasIntArrayType s (! id2) });
           (let idy = ref 0 in
            (let y = ref 0 in
             (((assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (id2 := ([@expl:id := self.id] s.heap.id[! self]));
               (y := ([@expl:y := k] ! k));
               (assert {
                  ((Rgn.mem (! id2) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! id2) (s.alloct.M.domain at INIT))) \/ ((! id2) = null))) /\
                    true });
               (idy := ([@expl:idy := id.{y}] A.get (s.heap.slots[! id2]) (! y)));
               (while not ((! y) = (! idy)) do
                  invariant { [@expl:locals type invariant] (hasIntArrayType s (! id2)) /\ (hasUfindType s (! self)) }
                  invariant { alloc_does_not_shrink (old s) s }
                  invariant { (A.get (s.heap.slots[! id2]) (! y)) = (! idy) }
                  invariant { ufInv s (! self) }
                  invariant { let prt = s.heap.part[! self] in
                              UNIONFIND.mem (! y) (UNIONFIND.pFind (! k) prt) }
                  invariant { (0 <= (! y)) /\ (let prt = s.heap.part[! self] in
                                               (! y) < (UNIONFIND.pSize prt)) }
                  ((assert {
                      ((Rgn.mem (! id2) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                         ((not (Rgn.mem (! id2) (s.alloct.M.domain at INIT))) \/ ((! id2) = null))) /\
                        true });
                   (y := ([@expl:y := id.{y}] A.get (s.heap.slots[! id2]) (! y)));
                   (assert {
                      ((Rgn.mem (! id2) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                         ((not (Rgn.mem (! id2) (s.alloct.M.domain at INIT))) \/ ((! id2) = null))) /\
                        true });
                   (idy := ([@expl:idy := id.{y}] A.get (s.heap.slots[! id2]) (! y))))
                done);
               (result := ([@expl:result := y] ! y));
               (! result))))))))))
  
  let ufUnion (s: state) (self: reference) (x: int) (y: int) : unit diverges
    requires { hasUfindType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { (0 <= x) /\ (let p = s.heap.part[self] in
                            x < (UNIONFIND.pSize p)) }
    requires { (0 <= y) /\ (let p = s.heap.part[self] in
                            y < (UNIONFIND.pSize p)) }
    requires { UNIONFIND.ufPub s }
    requires { ufPriv s }
    writes { s.heap.part }
    writes { s.heap.slots }
    ensures { result = () }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`lrep] wrs_to_lrep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`id] wrs_to_id_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`nxt] wrs_to_nxt_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`part] wrs_to_part_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r10 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r10 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let p = s.heap.part[self] in
              UNIONFIND.mem x (UNIONFIND.pFind y p) }
    ensures { let op = old (s.heap.part[self]) in
              let p = s.heap.part[self] in
              (UNIONFIND.pSize op) = (UNIONFIND.pSize p) }
    ensures { let orep = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = orep }
    ensures { UNIONFIND.ufPub s }
    ensures { ufPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let x = ref x in
        (let y = ref y in
         (let ina = ref null in
          (((assert { hasIntArrayType s (! ina) });
            (let xroot = ref 0 in
             (let yroot = ref 0 in
              (((assert {
                   ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                      ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                     true });
                (ina := ([@expl:ina := self.id] s.heap.id[! self]));
                (assert {
                   (Rgn.subset
                       (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                       (Rgn.union
                           ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                           (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                     true });
                (xroot := ([@expl:xroot := find(self,x)] find s (! self) (! x)));
                (assert {
                   (Rgn.subset
                       (Rgn.diff (Rgn.union (singleton (! self)) (s.heap.rep[! self])) (singleton null))
                       (Rgn.union
                           ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)
                           (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                     true });
                (yroot := ([@expl:yroot := find(self,y)] find s (! self) (! y)));
                (if (not ((! xroot) = (! yroot)))
                 then (let ghost prt = ref (any partition) in
                       (((assert {
                            ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                               ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                              true });
                         (prt := ([@expl:prt := self.part] s.heap.part[! self]));
                         (s.heap.part <-
                            ([@expl:self.part := pUnion(prt,pFind(x,prt),pFind(y,prt))]
                             M.add
                                (! self)
                                (UNIONFIND.pUnion (! prt) (UNIONFIND.pFind (! x) (! prt)) (UNIONFIND.pFind (! y) (! prt)))
                                s.heap.part));
                         (s.heap.slots <-
                            ([@expl:ina.{xroot} := yroot] M.add (! ina) (A.set (s.heap.slots[! ina]) (! xroot) (! yroot)) s.heap.slots)))))
                 else ());
                (! result)))))))))))
  
  lemma boundary_frames_invariant_QuickUnion : forall s: state, t: state, pi: 
                                                 PreRefperm.t.
                                                 (okRefperm s t pi) ->
                                                   ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                      ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                         ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                            ((ufPriv s) -> (ufPriv t)))))
end

module UFREL
  
  use prelude.Prelude
  use State
  use QuickFind
  use QuickUnion
  use export partition.Partition
  
  predicate samePartition (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (r_p: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             ((QuickFind.UNIONFIND.pSize l_prt) = (QuickUnion.UNIONFIND.pSize r_prt)) /\ (pEq l_prt r_prt))))
  
  predicate eqReps (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (r_p: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             forall l_i: int, r_i: int.
               (((0 <= l_i) /\ (l_i < (QuickFind.UNIONFIND.pSize l_prt))) /\ ((0 <= r_i) /\ (r_i < (QuickUnion.UNIONFIND.pSize r_prt)))) ->
                 ((l_i = r_i) ->
                    (let l_id = l_s.heap.id[l_p] in
                     let r_id = r_s.heap.id[r_p] in
                     ((A.get (l_s.heap.slots[l_id]) l_i) = l_i) <-> ((A.get (r_s.heap.slots[r_id]) r_i) = r_i))))))
  
  predicate eqRepsExcept (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (l_x: int) (r_p: reference) (r_x: int) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             forall l_i: int, r_i: int.
               (((0 <= l_i) /\ (l_i < (QuickFind.UNIONFIND.pSize l_prt))) /\ ((0 <= r_i) /\ (r_i < (QuickUnion.UNIONFIND.pSize r_prt)))) ->
                 (((l_i <> l_x) /\ (r_i <> r_x)) ->
                    ((l_i = r_i) ->
                       (let l_id = l_s.heap.id[l_p] in
                        let r_id = r_s.heap.id[r_p] in
                        ((A.get (l_s.heap.slots[l_id]) l_i) = l_i) <-> ((A.get (r_s.heap.slots[r_id]) r_i) = r_i)))))))
  
  predicate ufCoupling_aux (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (okRefperm l_s r_s pi) ->
      ((PreRefperm.idRgn pi l_s.pool r_s.pool) /\
         (forall l_p: reference, r_p: reference.
            (isAllocated l_s l_p) ->
              ((hasUfindType l_s l_p) ->
                 ((Rgn.mem l_p l_s.pool) ->
                    ((isAllocated r_s r_p) ->
                       ((hasUfindType r_s r_p) ->
                          ((Rgn.mem r_p r_s.pool) ->
                             ((PreRefperm.idRef pi l_p r_p) -> ((samePartition l_s r_s pi l_p r_p) /\ (eqReps l_s r_s pi l_p r_p))))))))))
  
  predicate ufCoupling (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (okRefperm l_s r_s pi) ->
      (((QuickFind.UNIONFIND.ufPub l_s) /\ (QuickUnion.UNIONFIND.ufPub r_s)) /\
         (((QuickFind.ufPriv l_s) /\ (QuickUnion.ufPriv r_s)) /\ (ufCoupling_aux l_s r_s pi)))
  
  let find (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (int, int) diverges
    requires { hasUfindType l_s l_self }
    requires { l_self <> null }
    requires { hasUfindType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { ufCoupling l_s r_s pi }
    requires { PreRefperm.idRgn pi l_s.pool r_s.pool }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { ((0 <= l_k) /\ (let prt = l_s.heap.part[l_self] in
                               l_k < (QuickFind.UNIONFIND.pSize prt))) /\
                 ((0 <= r_k) /\ (let prt = r_s.heap.part[r_self] in
                                 r_k < (QuickUnion.UNIONFIND.pSize prt))) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { ufCoupling l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let id1 = l_s.heap.id[l_self] in
                      (A.get (l_s.heap.slots[id1]) l_result) = l_result) /\
                       (let id2 = r_s.heap.id[r_self] in
                        (A.get (r_s.heap.slots[id2]) r_result) = r_result))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (((0 <= l_result) /\ (let p = l_s.heap.part[l_self] in
                                          l_result < (QuickFind.UNIONFIND.pSize p))) /\
                       ((0 <= r_result) /\ (let p = r_s.heap.part[r_self] in
                                            r_result < (QuickUnion.UNIONFIND.pSize p))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let p = l_s.heap.part[l_self] in
                      QuickFind.UNIONFIND.mem l_result (QuickFind.UNIONFIND.pFind l_k p)) /\
                       (let p = r_s.heap.part[r_self] in
                        QuickUnion.UNIONFIND.mem r_result (QuickUnion.UNIONFIND.pFind r_k p)))
              end }
    ensures { (let bsnap_r19 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r19 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r19 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r19 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) } =
    label INIT in
      let l_result = ref 0 in
      (let r_result = ref 0 in
       (let l_self = ref l_self in
        (let l_k = ref l_k in
         (let r_self = ref r_self in
          (let r_k = ref r_k in
           (((let id3 = ref null in
              (((assert { hasIntArrayType l_s (! id3) });
                (id3 := ([@expl:id := self.id] l_s.heap.id[! l_self]));
                (l_result := ([@expl:result := id.{k}] A.get (l_s.heap.slots[! id3]) (! l_k))))));
             (let id4 = ref null in
              (((assert { hasIntArrayType r_s (! id4) });
                (let idy = ref 0 in
                 (let y5 = ref 0 in
                  (((id4 := ([@expl:id := self.id] r_s.heap.id[! r_self]));
                    (y5 := ([@expl:y := k] ! r_k));
                    (idy := ([@expl:idy := id.{y}] A.get (r_s.heap.slots[! id4]) (! y5)));
                    (while not ((! y5) = (! idy)) do
                       invariant { [@expl:locals type invariant] (hasIntArrayType r_s (! id4)) /\ (hasUfindType r_s (! r_self)) }
                       invariant { alloc_does_not_shrink (old r_s) r_s }
                       invariant { (A.get (r_s.heap.slots[! id4]) (! y5)) = (! idy) }
                       invariant { QuickUnion.ufInv r_s (! r_self) }
                       invariant {
                         let prt = r_s.heap.part[! r_self] in
                         QuickUnion.UNIONFIND.mem (! y5) (QuickUnion.UNIONFIND.pFind (! r_k) prt) }
                       invariant { (0 <= (! y5)) /\ (let prt = r_s.heap.part[! r_self] in
                                                     (! y5) < (QuickUnion.UNIONFIND.pSize prt)) }
                       ((y5 := ([@expl:y := id.{y}] A.get (r_s.heap.slots[! id4]) (! y5)));
                        (idy := ([@expl:idy := id.{y}] A.get (r_s.heap.slots[! id4]) (! y5))))
                     done);
                    (r_result := ([@expl:result := y] ! y5));
                    (! l_result, ! r_result)))))))))))))))
  
  let ufUnion (l_s: state) (r_s: state) (pi6: PreRefperm.t) (l_self: reference) (l_x: int) (l_y: int) (r_self: reference) (r_x: int) (r_y: int) : 
    (unit,
     unit) diverges
    requires { hasUfindType l_s l_self }
    requires { l_self <> null }
    requires { hasUfindType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi6 }
    requires { ufCoupling l_s r_s pi6 }
    requires { (l_x = r_x) /\ (l_y = r_y) }
    requires { PreRefperm.idRef pi6 l_self r_self }
    requires { (agree_allfields l_s r_s pi6 (singleton l_self)) /\ (agree_allfields r_s l_s (PreRefperm.invert pi6) (singleton r_self)) }
    requires { PreRefperm.idRgn pi6 l_s.pool r_s.pool }
    requires { ((0 <= l_y) /\ (let p = l_s.heap.part[l_self] in
                               l_y < (QuickFind.UNIONFIND.pSize p))) /\
                 ((0 <= r_y) /\ (let p = r_s.heap.part[r_self] in
                                 r_y < (QuickUnion.UNIONFIND.pSize p))) }
    requires { ((0 <= l_x) /\ (let p = l_s.heap.part[l_self] in
                               l_x < (QuickFind.UNIONFIND.pSize p))) /\
                 ((0 <= r_x) /\ (let p = r_s.heap.part[r_self] in
                                 r_x < (QuickUnion.UNIONFIND.pSize p))) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.part }
    writes { l_s.heap.slots }
    writes { r_s.heap.part }
    writes { r_s.heap.slots }
    ensures { [@expl:wr {self}`part] wrs_to_part_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr ({self} union {self}`id)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (singleton (l_s.heap.id[l_self]))) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`id] wrs_to_id_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`part] wrs_to_part_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr ({self} union {self}`id)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (singleton (r_s.heap.id[r_self]))) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`id] wrs_to_id_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old r_s) r_s (singleton r_self) }
    ensures { okRefperm l_s r_s pi6 }
    ensures { ufCoupling l_s r_s pi6 }
    ensures { (let op = old (l_s.heap.part[l_self]) in
               let p = l_s.heap.part[l_self] in
               (QuickFind.UNIONFIND.pSize op) = (QuickFind.UNIONFIND.pSize p)) /\
                (let op = old (r_s.heap.part[r_self]) in
                 let p = r_s.heap.part[r_self] in
                 (QuickUnion.UNIONFIND.pSize op) = (QuickUnion.UNIONFIND.pSize p)) }
    ensures { (let p = l_s.heap.part[l_self] in
               QuickFind.UNIONFIND.mem l_x (QuickFind.UNIONFIND.pFind l_y p)) /\
                (let p = r_s.heap.part[r_self] in
                 QuickUnion.UNIONFIND.mem r_x (QuickUnion.UNIONFIND.pFind r_y p)) }
    ensures { (let oid = old (l_s.heap.id[l_self]) in
               (l_s.heap.id[l_self]) = oid) /\
                (let oid = old (r_s.heap.id[r_self]) in
                 (r_s.heap.id[r_self]) = oid) }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_id = old (singleton (l_s.heap.id[l_self])) in
              let r_id = old (singleton (r_s.heap.id[r_self])) in
              let l_o_self = old (singleton l_self) in
              let r_o_self = old (singleton r_self) in
              (agree_allfields l_s r_s pi6 (Rgn.diff l_s.alloct.M.domain (Rgn.union l_s_alloc l_o_self))) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi6) (Rgn.diff r_s.alloct.M.domain (Rgn.union r_s_alloc r_o_self))) }
    ensures { (let bsnap_r19 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r19 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r19 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r19 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    label INIT in
      let l_result = ref () in
      (let r_result = ref () in
       (let l_self = ref l_self in
        (let l_x = ref l_x in
         (let l_y = ref l_y in
          (let r_self = ref r_self in
           (let r_x = ref r_x in
            (let r_y = ref r_y in
             (let l_ina = ref null in
              (let r_ina = ref null in
               (let l_xroot = ref 0 in
                (let r_xroot = ref 0 in
                 (let l_yroot = ref 0 in
                  (let r_yroot = ref 0 in
                   (let ghost l_sid = ref (A.make 0 0) in
                    (let ghost r_sid = ref (A.make 0 0) in
                     (((((l_ina := ([@expl:ina := self.id] l_s.heap.id[! l_self]));
                         (r_ina := ([@expl:ina := self.id] r_s.heap.id[! r_self]))));
                       (assert {
                          (forall p: reference.
                             (isAllocated l_s p) ->
                               ((hasUfindType l_s p) ->
                                  ((Rgn.mem p l_s.pool) -> ((p <> (! l_self)) -> (not ((l_s.heap.id[p]) = (! l_ina))))))) /\
                            (forall p: reference.
                               (isAllocated r_s p) ->
                                 ((hasUfindType r_s p) ->
                                    ((Rgn.mem p r_s.pool) -> ((p <> (! r_self)) -> (not ((r_s.heap.id[p]) = (! r_ina))))))) });
                       (((l_sid := ([@expl:sid := ina.slots] l_s.heap.slots[! l_ina]));
                         ()));
                       (match find l_s r_s pi6 (! l_self) (! l_x) (! r_self) (! r_x)
                        with
                          | (l_find_res, r_find_res) ->
                              (((l_xroot := ([@expl:xroot := find(self,x)] l_find_res));
                                (r_xroot := ([@expl:xroot := find(self,x)] r_find_res))))
                        end);
                       (match find l_s r_s pi6 (! l_self) (! l_y) (! r_self) (! r_y)
                        with
                          | (l_find_res, r_find_res) ->
                              (((l_yroot := ([@expl:yroot := find(self,y)] l_find_res));
                                (r_yroot := ([@expl:yroot := find(self,y)] r_find_res))))
                        end);
                       ((([@expl:guard agreement] assert { ((! l_xroot) <> (! l_yroot)) = ((! r_xroot) <> (! r_yroot)) });
                         (if (not ((! l_xroot) = (! l_yroot)))
                          then (((assert { eqReps l_s r_s pi6 (! l_self) (! r_self) });
                                 (assert { eqRepsExcept l_s r_s pi6 (! l_self) (! l_xroot) (! r_self) (! r_xroot) });
                                 (let ghost l_prt = ref (any partition) in
                                  (let ghost r_prt = ref (any partition) in
                                   (((((l_prt := ([@expl:prt := self.part] l_s.heap.part[! l_self]));
                                       (r_prt := ([@expl:prt := self.part] r_s.heap.part[! r_self]))));
                                     (((l_s.heap.part <-
                                          ([@expl:self.part := pUnion(prt,pFind(x,prt),pFind(y,prt))]
                                           M.add
                                              (! l_self)
                                              (QuickFind.UNIONFIND.pUnion
                                                  (! l_prt)
                                                  (QuickFind.UNIONFIND.pFind (! l_x) (! l_prt))
                                                  (QuickFind.UNIONFIND.pFind (! l_y) (! l_prt)))
                                              l_s.heap.part));
                                       (r_s.heap.part <-
                                          ([@expl:self.part := pUnion(prt,pFind(x,prt),pFind(y,prt))]
                                           M.add
                                              (! r_self)
                                              (QuickUnion.UNIONFIND.pUnion
                                                  (! r_prt)
                                                  (QuickUnion.UNIONFIND.pFind (! r_x) (! r_prt))
                                                  (QuickUnion.UNIONFIND.pFind (! r_y) (! r_prt)))
                                              r_s.heap.part))));
                                     (assert { samePartition l_s r_s pi6 (! l_self) (! r_self) });
                                     (let l_i = ref 0 in
                                      (let r_i = ref 0 in
                                       (let l_len = ref 0 in
                                        (let r_len = ref 0 in
                                         (((((l_i := ([@expl:i := 0] 0));
                                             ()));
                                           (((l_len := ([@expl:len := ina.length] l_s.heap.length[! l_ina]));
                                             ()));
                                           (assert {
                                              forall l_p: reference, r_p: reference.
                                                (isAllocated l_s l_p) ->
                                                  ((hasUfindType l_s l_p) ->
                                                     ((Rgn.mem l_p l_s.pool) ->
                                                        ((isAllocated r_s r_p) ->
                                                           ((hasUfindType r_s r_p) ->
                                                              ((Rgn.mem r_p r_s.pool) ->
                                                                 (((l_p <> (! l_self)) /\ (r_p <> (! r_self))) ->
                                                                    (
                                                                    (PreRefperm.idRef pi6 l_p r_p) ->
                                                                    ((samePartition l_s r_s pi6 l_p r_p) /\
                                                                    (eqReps l_s r_s pi6 l_p r_p))))))))) });
                                           (((while (! l_i) < (! l_len) do
                                                invariant {
                                                  [@expl:locals type invariant]
                                                  (hasIntArrayType l_s (! l_ina)) /\ (hasUfindType l_s (! l_self)) }
                                                invariant { alloc_does_not_shrink (old l_s) l_s }
                                                invariant {
                                                  [@expl:wr {ina}`slots] wrs_to_slots_framed_by (old l_s) l_s (singleton (! l_ina)) }
                                                invariant {
                                                  forall p: reference.
                                                    (isAllocated l_s p) ->
                                                      ((hasUfindType l_s p) ->
                                                         ((Rgn.mem p l_s.pool) ->
                                                            ((p <> (! l_self)) -> (not ((l_s.heap.id[p]) = (! l_ina)))))) }
                                                invariant {
                                                  forall j: int.
                                                    ((0 <= j) /\ (j < (! l_i))) ->
                                                      (let inaj = A.get (l_s.heap.slots[! l_ina]) j in
                                                       (not (QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind (! l_x) (! l_prt)))) ->
                                                         ((QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind j (! l_prt))) /\
                                                            ((inaj = (A.get (! l_sid) j)) /\
                                                               ((A.get (l_s.heap.slots[! l_ina]) inaj) = inaj)))) }
                                                invariant {
                                                  forall j: int.
                                                    ((0 <= j) /\ (j < (! l_len))) ->
                                                      (((A.get (! l_sid) j) <> (! l_xroot)) ->
                                                         ((A.get (l_s.heap.slots[! l_ina]) j) = (A.get (! l_sid) j))) }
                                                invariant {
                                                  forall j: int.
                                                    ((0 <= j) /\ (j < (! l_i))) ->
                                                      (((A.get (! l_sid) j) = (! l_xroot)) ->
                                                         ((A.get (l_s.heap.slots[! l_ina]) j) = (! l_yroot))) }
                                                invariant {
                                                  forall j: int, k7: int.
                                                    ((0 <= j) /\ (j < (! l_i))) ->
                                                      (((0 <= k7) /\ (k7 < (! l_i))) ->
                                                         ((QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind k7 (! l_prt))) ->
                                                            (let inaj = A.get (l_s.heap.slots[! l_ina]) j in
                                                             (A.get (l_s.heap.slots[! l_ina]) k7) = inaj))) }
                                                invariant {
                                                  forall j: int.
                                                    ((0 <= j) /\ (j < (! l_i))) ->
                                                      ((QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind (! l_x) (! l_prt))) ->
                                                         ((A.get (l_s.heap.slots[! l_ina]) j) = (! l_yroot))) }
                                                invariant { (0 <= (! l_i)) /\ ((! l_i) <= (! l_len)) }
                                                invariant {
                                                  forall j: int.
                                                    (((! l_i) <= j) /\ (j < (! l_len))) ->
                                                      ((A.get (l_s.heap.slots[! l_ina]) j) = (A.get (! l_sid) j)) }
                                                let inai = ref 0 in
                                                (((inai := ([@expl:inai := ina.{i}] A.get (l_s.heap.slots[! l_ina]) (! l_i)));
                                                  (if ((! inai) = (! l_xroot))
                                                   then (((assert { (A.get (! l_sid) (! l_i)) = (! l_xroot) });
                                                          (l_s.heap.slots <-
                                                             ([@expl:ina.{i} := yroot]
                                                              M.add
                                                                 (! l_ina)
                                                                 (A.set (l_s.heap.slots[! l_ina]) (! l_i) (! l_yroot))
                                                                 l_s.heap.slots))))
                                                   else (assert { (A.get (! l_sid) (! l_i)) <> (! l_xroot) }));
                                                  (l_i := ([@expl:i := i + 1] (! l_i) + 1));
                                                  (assume {
                                                     forall j: int.
                                                       ((0 <= j) /\ (j < (! l_i))) ->
                                                         (let inaj = A.get (l_s.heap.slots[! l_ina]) j in
                                                          (not (QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind (! l_x) (! l_prt)))) ->
                                                            ((QuickFind.UNIONFIND.mem j (QuickFind.UNIONFIND.pFind j (! l_prt))) /\
                                                               ((inaj = (A.get (! l_sid) j)) /\
                                                                  ((A.get (l_s.heap.slots[! l_ina]) inaj) = inaj)))) })))
                                              done);
                                             (assert {
                                                forall p: reference.
                                                  (isAllocated r_s p) ->
                                                    ((hasUfindType r_s p) ->
                                                       ((Rgn.mem p r_s.pool) ->
                                                          ((p <> (! r_self)) -> (not ((r_s.heap.id[p]) = (! r_ina)))))) });
                                             (r_s.heap.slots <-
                                                ([@expl:ina.{xroot} := yroot]
                                                 M.add
                                                    (! r_ina)
                                                    (A.set (r_s.heap.slots[! r_ina]) (! r_xroot) (! r_yroot))
                                                    r_s.heap.slots))));
                                           (assert { eqReps l_s r_s pi6 (! l_self) (! r_self) });
                                           (assert {
                                              forall l_p: reference, r_p: reference.
                                                (isAllocated l_s l_p) ->
                                                  ((hasUfindType l_s l_p) ->
                                                     ((Rgn.mem l_p l_s.pool) ->
                                                        ((isAllocated r_s r_p) ->
                                                           ((hasUfindType r_s r_p) ->
                                                              ((Rgn.mem r_p r_s.pool) ->
                                                                 (((l_p <> (! l_self)) /\ (r_p <> (! r_self))) ->
                                                                    (
                                                                    (PreRefperm.idRef pi6 l_p r_p) ->
                                                                    ((samePartition l_s r_s pi6 l_p r_p) /\
                                                                    (eqReps l_s r_s pi6 l_p r_p))))))))) })))))))))))))
                          else ((();
                                 ())))));
                       (assert { eqReps l_s r_s pi6 (! l_self) (! r_self) });
                       (assume {
                          ((QuickFind.UNIONFIND.ufPub l_s) /\ (QuickUnion.UNIONFIND.ufPub r_s)) /\
                            ((QuickFind.ufPriv l_s) /\ (QuickUnion.ufPriv r_s)) });
                       (! l_result, ! r_result))))))))))))))))))
  
  lemma boundary_frames_coupling_UFREL : forall s: state, t: state, s': state, t': state, pi: 
                                           PreRefperm.t, pi': PreRefperm.t, rho: 
                                           PreRefperm.t.
                                           (okRefperm s t pi) ->
                                             ((okRefperm s' t' pi') ->
                                                ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                   ((PreRefperm.identity pi' s'.alloct.M.domain t'.alloct.M.domain) ->
                                                      ((okRefperm s s' rho) ->
                                                         ((okRefperm t t' rho) ->
                                                            ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                               ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                                  ((PreRefperm.idRgn pi' s'.pool t'.pool) ->
                                                                    ((agree_allfields
                                                                    s'
                                                                    t'
                                                                    pi'
                                                                    (Rgn.union s'.pool (img_rep s' s'.pool))) ->
                                                                    ((ufCoupling s s' rho) -> (ufCoupling t t' rho)))))))))))
  
  lemma ufCoupling_is_refperm_monotonic : forall s: state, t: state, pi: 
                                            PreRefperm.t.
                                            (okRefperm s t pi) ->
                                              ((ufCoupling s t pi) ->
                                                 (forall rho: PreRefperm.t.
                                                    (okRefperm s t rho) -> ((PreRefperm.extends pi rho) -> (ufCoupling s t rho))))
end

module Main
  
  use prelude.Prelude
  use State
  use MAIN
  use UNIONFIND
  use export kruskal_aux.Kruskal_aux
  
  predicate lrep_closed (s: state) (xs: reference) =
    (hasListType s xs) ->
      ((xs <> null) ->
         (let hd = s.heap.head[xs] in
          let lrep1 = s.heap.lrep[xs] in
          (typeofRgn s lrep1 (L.Cons Node L.Nil)) /\
            ((Rgn.subset (img_nxt s lrep1) lrep1) /\ ((Rgn.mem null lrep1) /\ (Rgn.mem hd lrep1)))))
  
  let init_Node (s: state) (self: reference) (v: int) (n: reference) : unit
    requires { hasNodeType s self }
    requires { self <> null }
    requires { hasNodeType s n }
    requires { not (Rgn.mem self (Rgn.union s.pool (img_rep s s.pool))) }
    requires { (s.heap.nxt[self]) = null }
    writes { s.heap.nxt }
    writes { s.heap.value }
    ensures { result = () }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old s) s (singleton self) }
    ensures { (s.heap.nxt[self]) = n }
    ensures { (s.heap.value[self]) = v } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let v = ref v in
        (let n = ref n in
         (((assert { not (Rgn.mem (! self) (Rgn.union s.pool (img_rep s s.pool))) });
           (s.heap.nxt <- ([@expl:self.nxt := n] M.add (! self) (! n) s.heap.nxt));
           (assert { not (Rgn.mem (! self) (Rgn.union s.pool (img_rep s s.pool))) });
           (s.heap.value <- ([@expl:self.value := v] M.add (! self) (! v) s.heap.value));
           (! result))))))
  
  let init_List (s: state) (self: reference) : unit
    requires { hasListType s self }
    requires { self <> null }
    requires { not (Rgn.mem self (Rgn.union s.pool (img_rep s s.pool))) }
    writes { s.heap.head }
    writes { s.heap.lrep }
    ensures { result = () }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { (s.heap.head[self]) = null }
    ensures { (s.heap.lrep[self]) = (singleton null) }
    ensures { lrep_closed s self } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (((assert { not (Rgn.mem (! self) (Rgn.union s.pool (img_rep s s.pool))) });
         (s.heap.lrep <- ([@expl:self.lrep := {null}] M.add (! self) (singleton null) s.heap.lrep));
         (assert { not (Rgn.mem (! self) (Rgn.union s.pool (img_rep s s.pool))) });
         (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head));
         (! result))))
  
  let main (s: state) (g: graph) : reference diverges
    requires { (numVertices g) > 0 }
    requires { s.pool = emptyRgn }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.head }
    writes { s.heap.id }
    writes { s.heap.length }
    writes { s.heap.lrep }
    writes { s.heap.nxt }
    writes { s.heap.part }
    writes { s.heap.rep }
    writes { s.heap.slots }
    writes { s.heap.value }
    ensures { result <> null }
    ensures { hasListType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({} union pool union pool`rep)`part]
              wrs_to_part_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`nxt]
              wrs_to_nxt_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`head]
              wrs_to_head_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`id]
              wrs_to_id_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`lrep]
              wrs_to_lrep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`value]
              wrs_to_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { true } =
    label INIT in
      let result = ref null in
      (let g = ref g in
       (let uf = ref null in
        (((assert { hasUfindType s (! uf) });
          (let es = ref (A.make 0 (any edge)) in
           (((es := ([@expl:es := edges(g)] edges (! g)));
             (let nverts = ref 0 in
              (((nverts := ([@expl:nverts := numVertices(g)] numVertices (! g)));
                (uf := ([@expl:uf := new Ufind] mk_Ufind s));
                (assert {
                   (Rgn.subset
                       (Rgn.diff (Rgn.union (singleton (! uf)) (s.heap.rep[! uf])) (singleton null))
                       (Rgn.union
                           ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                           (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                     true });
                ([@expl:Ufind(uf,nverts)] UNIONFIND.init_Ufind s (! uf) (! nverts));
                (assert { let prt = s.heap.part[! uf] in
                          (! nverts) = (UNIONFIND.pSize prt) });
                (let l = ref null in
                 (((assert { hasListType s (! l) });
                   (l := ([@expl:l := new List] mk_List s));
                   (assert {
                      ((Rgn.mem (! l) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                         ((not (Rgn.mem (! l) (s.alloct.M.domain at INIT))) \/ ((! l) = null))) /\
                        true });
                   ([@expl:List(l)] init_List s (! l));
                   (assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                   (let i = ref 0 in
                    (((while (! i) < (numEdges (! es)) do
                         invariant {
                           [@expl:locals type invariant]
                           (hasListType s (! l)) /\ ((hasListType s (! result)) /\ (hasUfindType s (! uf))) }
                         invariant { alloc_does_not_shrink (old s) s }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`part]
                           wrs_to_part_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`slots]
                           wrs_to_slots_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`nxt]
                           wrs_to_nxt_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`head]
                           wrs_to_head_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`id]
                           wrs_to_id_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`rep]
                           wrs_to_rep_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l} union {l}`lrep)`lrep]
                           wrs_to_lrep_framed_by
                             (old s)
                             s
                             (Rgn.union
                                 (singleton (! uf))
                                 (Rgn.union (s.heap.rep[! uf]) (Rgn.union (singleton (! l)) (s.heap.lrep[! l])))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`value]
                           wrs_to_value_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           [@expl:wr ({uf} union {uf}`rep union {l}`lrep)`length]
                           wrs_to_length_framed_by
                             (old s)
                             s
                             (Rgn.union (singleton (! uf)) (Rgn.union (s.heap.rep[! uf]) (s.heap.lrep[! l]))) }
                         invariant {
                           let s_alloc = old s.alloct.M.domain in
                           Rgn.subset (s.heap.rep[! uf]) (Rgn.diff s.alloct.M.domain s_alloc) }
                         invariant { Rgn.mem (! uf) s.pool }
                         invariant { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) }
                         invariant { let s_alloc = old s.alloct.M.domain in
                                     let lrep1 = s.heap.lrep[! l] in
                                     lrep1 \# s_alloc }
                         invariant { let prt = s.heap.part[! uf] in
                                     (! nverts) = (UNIONFIND.pSize prt) }
                         invariant { (0 <= (! i)) /\ ((! i) <= (numEdges (! es))) }
                         invariant { UNIONFIND.ufPub s }
                         let curredge = ref (any edge) in
                         (let startv = ref 0 in
                          (let endv = ref 0 in
                           (((curredge := ([@expl:curredge := get(es,i)] A.get (! es) (! i)));
                             (startv := ([@expl:startv := startVertex(curredge)] startVertex (! curredge)));
                             (endv := ([@expl:endv := endVertex(curredge)] endVertex (! curredge)));
                             (let srepr = ref 0 in
                              (let erepr = ref 0 in
                               (((assert {
                                    (Rgn.subset
                                        (Rgn.diff (Rgn.union (singleton (! uf)) (s.heap.rep[! uf])) (singleton null))
                                        (Rgn.union
                                            ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                            (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                      true });
                                 (srepr := ([@expl:srepr := find(uf,startv)] UNIONFIND.find s (! uf) (! startv)));
                                 (assert {
                                    (Rgn.subset
                                        (Rgn.diff (Rgn.union (singleton (! uf)) (s.heap.rep[! uf])) (singleton null))
                                        (Rgn.union
                                            ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                            (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                      true });
                                 (erepr := ([@expl:erepr := find(uf,endv)] UNIONFIND.find s (! uf) (! endv)));
                                 (if (not ((! srepr) = (! erepr)))
                                  then (((assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                                         (assert {
                                            (Rgn.subset
                                                (Rgn.diff (Rgn.union (singleton (! uf)) (s.heap.rep[! uf])) (singleton null))
                                                (Rgn.union
                                                    ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                                                    (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                                              true });
                                         ([@expl:ufUnion(uf,startv,endv)] UNIONFIND.ufUnion s (! uf) (! startv) (! endv));
                                         (assert { not (Rgn.mem (! l) s.pool) });
                                         (assert { not (Rgn.mem (! l) (img_rep s s.pool)) });
                                         (let p = ref null in
                                          (((assert { hasNodeType s (! p) });
                                            (p := ([@expl:p := new Node] mk_Node s));
                                            (let hd = ref null in
                                             (((assert { hasNodeType s (! hd) });
                                               (assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                                               (assert {
                                                  ((Rgn.mem (! l) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                     ((not (Rgn.mem (! l) (s.alloct.M.domain at INIT))) \/ ((! l) = null))) /\
                                                    true });
                                               (hd := ([@expl:hd := l.head] s.heap.head[! l]));
                                               (assert {
                                                  ((Rgn.mem (! p) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                     ((not (Rgn.mem (! p) (s.alloct.M.domain at INIT))) \/ ((! p) = null))) /\
                                                    true });
                                               ([@expl:Node(p,i,hd)] init_Node s (! p) (! i) (! hd));
                                               (assert { (s.heap.nxt[! p]) = (! hd) });
                                               (assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                                               (s.heap.head <- ([@expl:l.head := p] M.add (! l) (! p) s.heap.head));
                                               (let ghost lr = ref emptyRgn in
                                                (((assert { isValidRgn s (! lr) });
                                                  (assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                                                  (assert {
                                                     ((Rgn.mem (! l) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                                                        ((not (Rgn.mem (! l) (s.alloct.M.domain at INIT))) \/ ((! l) = null))) /\
                                                       true });
                                                  (lr := ([@expl:lr := l.lrep] s.heap.lrep[! l]));
                                                  (assert { not (Rgn.mem (! l) (Rgn.union s.pool (img_rep s s.pool))) });
                                                  (s.heap.lrep <-
                                                     ([@expl:l.lrep := lr union {p}]
                                                      M.add (! l) (Rgn.union (! lr) (singleton (! p))) s.heap.lrep)))))))))))))
                                  else ());
                                 (i := ([@expl:i := i + 1] (! i) + 1))))))))))
                       done);
                      (result := ([@expl:result := l] ! l));
                      (! result)))))))))))))))))
end

module Main_Link
  
  use prelude.Prelude
  use State
  use Main
  use UFREL
  
  lemma ufPub_holds_in_main : forall l_s: state, r_s: state, pi: PreRefperm.t.
                                (okRefperm l_s r_s pi) ->
                                  (forall l_g: graph, r_g: graph.
                                     (((Main.numVertices l_g) > 0) -> ((l_s.pool = emptyRgn) -> (Main.UNIONFIND.ufPub l_s))) /\
                                       (((Main.numVertices r_g) > 0) -> ((r_s.pool = emptyRgn) -> (Main.UNIONFIND.ufPub r_s))))
  
  lemma left_ufPriv_holds_in_main : forall l_s: state, r_s: state, pi: 
                                      PreRefperm.t.
                                      (okRefperm l_s r_s pi) ->
                                        (forall l_g: graph, r_g: graph.
                                           ((Main.numVertices l_g) > 0) -> ((l_s.pool = emptyRgn) -> (UFREL.QuickFind.ufPriv l_s)))
  
  lemma right_ufPriv_holds_in_main : forall l_s: state, r_s: state, pi: 
                                       PreRefperm.t.
                                       (okRefperm l_s r_s pi) ->
                                         (forall l_g: graph, r_g: graph.
                                            ((Main.numVertices r_g) > 0) -> ((r_s.pool = emptyRgn) -> (UFREL.QuickUnion.ufPriv r_s)))
  
  lemma ufCoupling_holds_in_main : forall l_s: state, r_s: state, pi: 
                                     PreRefperm.t.
                                     (okRefperm l_s r_s pi) ->
                                       (forall l_g: graph, r_g: graph.
                                          (((Main.numVertices l_g) > 0) /\ ((Main.numVertices r_g) > 0)) ->
                                            (((l_s.pool = emptyRgn) /\ (r_s.pool = emptyRgn)) ->
                                               ((l_g = r_g) ->
                                                  (((agree_length
                                                       l_s
                                                       r_s
                                                       pi
                                                       (Rgn.diff
                                                           (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                           (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                      (agree_length
                                                         r_s
                                                         l_s
                                                         (PreRefperm.invert pi)
                                                         (Rgn.diff
                                                             (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                             (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                     (((agree_value
                                                          l_s
                                                          r_s
                                                          pi
                                                          (Rgn.diff
                                                              (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                              (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                         (agree_value
                                                            r_s
                                                            l_s
                                                            (PreRefperm.invert pi)
                                                            (Rgn.diff
                                                                (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                        (((agree_lrep
                                                             l_s
                                                             r_s
                                                             pi
                                                             (Rgn.diff
                                                                 (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                            (agree_lrep
                                                               r_s
                                                               l_s
                                                               (PreRefperm.invert pi)
                                                               (Rgn.diff
                                                                   (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                   (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                           (((agree_rep
                                                                l_s
                                                                r_s
                                                                pi
                                                                (Rgn.diff
                                                                    (
                                                                    Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (
                                                                    Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                               (agree_rep
                                                                  r_s
                                                                  l_s
                                                                  (PreRefperm.invert pi)
                                                                  (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                              (((agree_id
                                                                   l_s
                                                                   r_s
                                                                   pi
                                                                   (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                  (agree_id
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                 (((agree_head
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_head
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (
                                                                    ((agree_nxt
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_nxt
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_slots
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_slots
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (((agree_part
                                                                    l_s
                                                                    r_s
                                                                    pi
                                                                    (Rgn.diff
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool))
                                                                    (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                                                    (agree_part
                                                                    r_s
                                                                    l_s
                                                                    (PreRefperm.invert pi)
                                                                    (Rgn.diff
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))
                                                                    (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) ->
                                                                    (ufCoupling l_s r_s pi)))))))))))))
  
  val main (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_g: graph) (r_g: graph) : 
    (reference, reference)
    requires { okRefperm l_s r_s pi }
    requires { (agree_part
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_part
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_slots
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_slots
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_nxt l_s r_s pi (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_nxt
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_head
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_head
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_id l_s r_s pi (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_id
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_rep l_s r_s pi (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_rep
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_lrep
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_lrep
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_value
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_value
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_length
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union l_s.pool (img_rep l_s l_s.pool)) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_length
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union r_s.pool (img_rep r_s r_s.pool)) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { l_g = r_g }
    requires { (l_s.pool = emptyRgn) /\ (r_s.pool = emptyRgn) }
    requires { ((Main.numVertices l_g) > 0) /\ ((Main.numVertices r_g) > 0) }
    writes { l_s.heap.part }
    writes { l_s.heap.slots }
    writes { l_s.heap.nxt }
    writes { l_s.heap.head }
    writes { l_s.heap.id }
    writes { l_s.heap.rep }
    writes { l_s.heap.lrep }
    writes { l_s.heap.value }
    writes { l_s.heap.length }
    writes { l_s.pool }
    writes { l_s.alloct }
    writes { r_s.heap.part }
    writes { r_s.heap.slots }
    writes { r_s.heap.nxt }
    writes { r_s.heap.head }
    writes { r_s.heap.id }
    writes { r_s.heap.rep }
    writes { r_s.heap.lrep }
    writes { r_s.heap.value }
    writes { r_s.heap.length }
    writes { r_s.pool }
    writes { r_s.alloct }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr (pool union pool`rep)`part] wrs_to_part_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`nxt] wrs_to_nxt_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`head] wrs_to_head_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`id] wrs_to_id_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`rep] wrs_to_rep_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`lrep] wrs_to_lrep_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`value] wrs_to_value_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { [@expl:wr (pool union pool`rep)`part] wrs_to_part_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`nxt] wrs_to_nxt_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`head] wrs_to_head_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`id] wrs_to_id_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`rep] wrs_to_rep_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`lrep] wrs_to_lrep_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`value] wrs_to_value_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { let l_s_alloc0 = old l_s.alloct.M.domain in
              let r_s_alloc0 = old r_s.alloct.M.domain in
              let l_snap_r9 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
              let r_snap_r9 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
              ((agree_length l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_length r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                (((agree_value l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                    (agree_value r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                   (((agree_lrep l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                       (agree_lrep r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                      (((agree_rep l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                          (agree_rep r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                         (((agree_id l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                             (agree_id r_s l_s (PreRefperm.invert pi) (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                            (((agree_head l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                (agree_head
                                   r_s
                                   l_s
                                   (PreRefperm.invert pi)
                                   (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                               (((agree_nxt l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                   (agree_nxt
                                      r_s
                                      l_s
                                      (PreRefperm.invert pi)
                                      (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                  (((agree_slots l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                      (agree_slots
                                         r_s
                                         l_s
                                         (PreRefperm.invert pi)
                                         (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                     (((agree_part l_s r_s pi (Rgn.diff l_snap_r9 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                                         (agree_part
                                            r_s
                                            l_s
                                            (PreRefperm.invert pi)
                                            (Rgn.diff r_snap_r9 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                                        ((agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc0)) /\
                                           (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc0))))))))))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val init_List (l_s: state) (r_s: state) (pi2: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (unit, unit)
    requires { hasListType l_s l_self }
    requires { l_self <> null }
    requires { hasListType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi2 }
    requires { PreRefperm.idRef pi2 l_self r_self }
    requires { (agree_head l_s r_s pi2 (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_head r_s l_s (PreRefperm.invert pi2) (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_lrep l_s r_s pi2 (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_lrep r_s l_s (PreRefperm.invert pi2) (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (not (Rgn.mem l_self (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (not (Rgn.mem r_self (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    writes { l_s.heap.head }
    writes { l_s.heap.lrep }
    writes { r_s.heap.head }
    writes { r_s.heap.lrep }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { okRefperm l_s r_s pi2 }
    ensures { (Main.lrep_closed l_s l_self) /\ (Main.lrep_closed r_s r_self) }
    ensures { ((l_s.heap.lrep[l_self]) = (singleton null)) /\ ((r_s.heap.lrep[r_self]) = (singleton null)) }
    ensures { ((l_s.heap.head[l_self]) = null) /\ ((r_s.heap.head[r_self]) = null) }
    ensures { let l_s_alloc10 = old l_s.alloct.M.domain in
              let r_s_alloc10 = old r_s.alloct.M.domain in
              let l_self12 = old (singleton l_self) in
              let r_self12 = old (singleton r_self) in
              ((agree_lrep l_s r_s pi2 (Rgn.diff l_self12 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_lrep r_s l_s (PreRefperm.invert pi2) (Rgn.diff r_self12 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                (((agree_head l_s r_s pi2 (Rgn.diff l_self12 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                    (agree_head r_s l_s (PreRefperm.invert pi2) (Rgn.diff r_self12 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                   ((agree_allfields l_s r_s pi2 (Rgn.diff l_s.alloct.M.domain l_s_alloc10)) /\
                      (agree_allfields r_s l_s (PreRefperm.invert pi2) (Rgn.diff r_s.alloct.M.domain r_s_alloc10)))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
  
  val init_Node (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_v: int) (l_n: reference) (r_self: reference) (r_v: int) (r_n: reference) : 
    (unit,
     unit)
    requires { hasNodeType l_s l_self }
    requires { l_self <> null }
    requires { hasNodeType l_s l_n }
    requires { hasNodeType r_s r_self }
    requires { r_self <> null }
    requires { hasNodeType r_s r_n }
    requires { okRefperm l_s r_s pi }
    requires { l_v = r_v }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { PreRefperm.idRef pi l_n r_n }
    requires { (agree_value l_s r_s pi (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_value r_s l_s (PreRefperm.invert pi) (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (agree_nxt l_s r_s pi (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_nxt r_s l_s (PreRefperm.invert pi) (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { ((l_s.heap.nxt[l_self]) = null) /\ ((r_s.heap.nxt[r_self]) = null) }
    requires { (not (Rgn.mem l_self (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (not (Rgn.mem r_self (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    writes { l_s.heap.value }
    writes { l_s.heap.nxt }
    writes { r_s.heap.value }
    writes { r_s.heap.nxt }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old r_s) r_s (singleton r_self) }
    ensures { okRefperm l_s r_s pi }
    ensures { ((l_s.heap.value[l_self]) = l_v) /\ ((r_s.heap.value[r_self]) = r_v) }
    ensures { ((l_s.heap.nxt[l_self]) = l_n) /\ ((r_s.heap.nxt[r_self]) = r_n) }
    ensures { let l_s_alloc13 = old l_s.alloct.M.domain in
              let r_s_alloc13 = old r_s.alloct.M.domain in
              let l_self15 = old (singleton l_self) in
              let r_self15 = old (singleton r_self) in
              ((agree_nxt l_s r_s pi (Rgn.diff l_self15 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_nxt r_s l_s (PreRefperm.invert pi) (Rgn.diff r_self15 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                (((agree_value l_s r_s pi (Rgn.diff l_self15 (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                    (agree_value r_s l_s (PreRefperm.invert pi) (Rgn.diff r_self15 (Rgn.union r_s.pool (img_rep r_s r_s.pool))))) /\
                   ((agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc13)) /\
                      (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc13)))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
end

module UFREL_biinterface
  
  use prelude.Prelude
  use State
  use QuickFind
  use QuickUnion
  use export partition.Partition
  
  predicate samePartition (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (r_p: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             ((QuickFind.UNIONFIND.pSize l_prt) = (QuickUnion.UNIONFIND.pSize r_prt)) /\ (pEq l_prt r_prt))))
  
  predicate eqReps (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (r_p: reference) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             forall l_i: int, r_i: int.
               (((0 <= l_i) /\ (l_i < (QuickFind.UNIONFIND.pSize l_prt))) /\ ((0 <= r_i) /\ (r_i < (QuickUnion.UNIONFIND.pSize r_prt)))) ->
                 ((l_i = r_i) ->
                    (let l_id = l_s.heap.id[l_p] in
                     let r_id = r_s.heap.id[r_p] in
                     ((A.get (l_s.heap.slots[l_id]) l_i) = l_i) <-> ((A.get (r_s.heap.slots[r_id]) r_i) = r_i))))))
  
  predicate eqRepsExcept (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_p: reference) (l_x: int) (r_p: reference) (r_x: int) =
    (okRefperm l_s r_s pi) ->
      ((hasUfindType l_s l_p) ->
         ((hasUfindType r_s r_p) ->
            (let l_prt = l_s.heap.part[l_p] in
             let r_prt = r_s.heap.part[r_p] in
             forall l_i: int, r_i: int.
               (((0 <= l_i) /\ (l_i < (QuickFind.UNIONFIND.pSize l_prt))) /\ ((0 <= r_i) /\ (r_i < (QuickUnion.UNIONFIND.pSize r_prt)))) ->
                 (((l_i <> l_x) /\ (r_i <> r_x)) ->
                    ((l_i = r_i) ->
                       (let l_id = l_s.heap.id[l_p] in
                        let r_id = r_s.heap.id[r_p] in
                        ((A.get (l_s.heap.slots[l_id]) l_i) = l_i) <-> ((A.get (r_s.heap.slots[r_id]) r_i) = r_i)))))))
  
  predicate ufCoupling_aux (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (okRefperm l_s r_s pi) ->
      ((PreRefperm.idRgn pi l_s.pool r_s.pool) /\
         (forall l_p: reference, r_p: reference.
            (isAllocated l_s l_p) ->
              ((hasUfindType l_s l_p) ->
                 ((Rgn.mem l_p l_s.pool) ->
                    ((isAllocated r_s r_p) ->
                       ((hasUfindType r_s r_p) ->
                          ((Rgn.mem r_p r_s.pool) ->
                             ((PreRefperm.idRef pi l_p r_p) -> ((samePartition l_s r_s pi l_p r_p) /\ (eqReps l_s r_s pi l_p r_p))))))))))
  
  val find (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (int, int)
    requires { hasUfindType l_s l_self }
    requires { l_self <> null }
    requires { hasUfindType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { PreRefperm.idRgn pi l_s.pool r_s.pool }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { ((0 <= l_k) /\ (let prt = l_s.heap.part[l_self] in
                               l_k < (QuickFind.UNIONFIND.pSize prt))) /\
                 ((0 <= r_k) /\ (let prt = r_s.heap.part[r_self] in
                                 r_k < (QuickUnion.UNIONFIND.pSize prt))) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields l_s r_s pi (Rgn.diff l_s.alloct.M.domain l_s_alloc)) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi) (Rgn.diff r_s.alloct.M.domain r_s_alloc)) }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let id3 = l_s.heap.id[l_self] in
                      (A.get (l_s.heap.slots[id3]) l_result) = l_result) /\
                       (let id4 = r_s.heap.id[r_self] in
                        (A.get (r_s.heap.slots[id4]) r_result) = r_result))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (((0 <= l_result) /\ (let p = l_s.heap.part[l_self] in
                                          l_result < (QuickFind.UNIONFIND.pSize p))) /\
                       ((0 <= r_result) /\ (let p = r_s.heap.part[r_self] in
                                            r_result < (QuickUnion.UNIONFIND.pSize p))))
              end }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let p = l_s.heap.part[l_self] in
                      QuickFind.UNIONFIND.mem l_result (QuickFind.UNIONFIND.pFind l_k p)) /\
                       (let p = r_s.heap.part[r_self] in
                        QuickUnion.UNIONFIND.mem r_result (QuickUnion.UNIONFIND.pFind r_k p)))
              end }
    ensures { (let bsnap_r19 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r19 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r19 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r19 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
  
  val ufUnion (l_s: state) (r_s: state) (pi5: PreRefperm.t) (l_self: reference) (l_x: int) (l_y: int) (r_self: reference) (r_x: int) (r_y: int) : 
    (unit,
     unit)
    requires { hasUfindType l_s l_self }
    requires { l_self <> null }
    requires { hasUfindType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi5 }
    requires { true /\ true }
    requires { (l_x = r_x) /\ (l_y = r_y) }
    requires { PreRefperm.idRef pi5 l_self r_self }
    requires { (agree_allfields l_s r_s pi5 (singleton l_self)) /\ (agree_allfields r_s l_s (PreRefperm.invert pi5) (singleton r_self)) }
    requires { PreRefperm.idRgn pi5 l_s.pool r_s.pool }
    requires { ((0 <= l_y) /\ (let p = l_s.heap.part[l_self] in
                               l_y < (QuickFind.UNIONFIND.pSize p))) /\
                 ((0 <= r_y) /\ (let p = r_s.heap.part[r_self] in
                                 r_y < (QuickUnion.UNIONFIND.pSize p))) }
    requires { ((0 <= l_x) /\ (let p = l_s.heap.part[l_self] in
                               l_x < (QuickFind.UNIONFIND.pSize p))) /\
                 ((0 <= r_x) /\ (let p = r_s.heap.part[r_self] in
                                 r_x < (QuickUnion.UNIONFIND.pSize p))) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.part }
    writes { l_s.heap.slots }
    writes { l_s.heap.nxt }
    writes { l_s.heap.head }
    writes { l_s.heap.id }
    writes { l_s.heap.rep }
    writes { l_s.heap.lrep }
    writes { l_s.heap.value }
    writes { l_s.heap.length }
    writes { r_s.heap.part }
    writes { r_s.heap.slots }
    writes { r_s.heap.nxt }
    writes { r_s.heap.head }
    writes { r_s.heap.id }
    writes { r_s.heap.rep }
    writes { r_s.heap.lrep }
    writes { r_s.heap.value }
    writes { r_s.heap.length }
    ensures { [@expl:wr {self}`part] wrs_to_part_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr ({self} union {self}`id)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (singleton (l_s.heap.id[l_self]))) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`id] wrs_to_id_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`part] wrs_to_part_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr ({self} union {self}`id)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (singleton (r_s.heap.id[r_self]))) }
    ensures { [@expl:wr {self}`nxt] wrs_to_nxt_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`id] wrs_to_id_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`lrep] wrs_to_lrep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`value] wrs_to_value_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old r_s) r_s (singleton r_self) }
    ensures { okRefperm l_s r_s pi5 }
    ensures { true /\ true }
    ensures { (let op = old (l_s.heap.part[l_self]) in
               let p = l_s.heap.part[l_self] in
               (QuickFind.UNIONFIND.pSize op) = (QuickFind.UNIONFIND.pSize p)) /\
                (let op = old (r_s.heap.part[r_self]) in
                 let p = r_s.heap.part[r_self] in
                 (QuickUnion.UNIONFIND.pSize op) = (QuickUnion.UNIONFIND.pSize p)) }
    ensures { (let p = l_s.heap.part[l_self] in
               QuickFind.UNIONFIND.mem l_x (QuickFind.UNIONFIND.pFind l_y p)) /\
                (let p = r_s.heap.part[r_self] in
                 QuickUnion.UNIONFIND.mem r_x (QuickUnion.UNIONFIND.pFind r_y p)) }
    ensures { (let oid = old (l_s.heap.id[l_self]) in
               (l_s.heap.id[l_self]) = oid) /\
                (let oid = old (r_s.heap.id[r_self]) in
                 (r_s.heap.id[r_self]) = oid) }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_id = old (singleton (l_s.heap.id[l_self])) in
              let r_id = old (singleton (r_s.heap.id[r_self])) in
              let l_o_self = old (singleton l_self) in
              let r_o_self = old (singleton r_self) in
              (agree_allfields l_s r_s pi5 (Rgn.diff l_s.alloct.M.domain (Rgn.union l_s_alloc l_o_self))) /\
                (agree_allfields r_s l_s (PreRefperm.invert pi5) (Rgn.diff r_s.alloct.M.domain (Rgn.union r_s_alloc r_o_self))) }
    ensures { (let bsnap_r19 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r19 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r19 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r19 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
end

