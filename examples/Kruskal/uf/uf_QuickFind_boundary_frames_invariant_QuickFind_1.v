(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

(* Why3 assumption *)
Definition infix_eqeq {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m1:fmap k v) (m2:fmap k v) : Prop :=
  set.Fset.infix_eqeq (domain m1) (domain m2) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))).

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v), infix_eqeq m1 m2 -> (m1 = m2).

(* Why3 assumption *)
Definition mem {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} (k1:k)
    (m:fmap k v) : Prop :=
  set.Fset.mem k1 (domain m).

(* Why3 assumption *)
Definition mapsto {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} 
    (k1:k) (v1:v) (m:fmap k v) : Prop :=
  mem k1 m /\ ((contents1 m k1) = v1).

Axiom mem_mapsto :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> mapsto k1 (contents1 m k1) m.

(* Why3 assumption *)
Definition is_empty {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Prop :=
  set.Fset.is_empty (domain m).

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  is_empty (empty : fmap k v).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

(* Why3 assumption *)
Definition size {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Numbers.BinNums.Z :=
  set.Fset.cardinal (domain m).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a),
  (0%Z <= (length self))%Z /\
  ((size (to_fmap (elts self))) = (length self)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length self))%Z ->
   mem i (to_fmap (elts self))).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set a1 i v) i) = v) /\
  (forall (j:Numbers.BinNums.Z), (0%Z <= j)%Z /\ (j < (length a1))%Z ->
   ~ (j = i) -> ((get (set a1 i v) j) = (get a1 j))) /\
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
   ((get (make n v) i) = v)) /\
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) <-> (r1 = r2).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) <-> ~ (r1 = r2).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) <-> (b1 = b2).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) <-> (u1 = u2).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Parameter infix_bscl:
  forall {a:Type} {a_WT:WhyType a}, reference -> t1 a -> Init.Datatypes.bool.

Axiom infix_bscl'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.true)) /\
  (~ mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.false)).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom add_map_others_unchanged :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) -> forall (q:reference),
  ((infix_bscl q m) = Init.Datatypes.true) -> ~ (q = p) ->
  ((mixfix_lbrb m' q) = (mixfix_lbrb m q)).

Axiom add_map_lookup :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) ->
  ((infix_bscl p m') = Init.Datatypes.true) /\ ((mixfix_lbrb m' p) = v).

(* Why3 assumption *)
Definition rgn := set.Fset.fset reference.

Parameter eqRgn:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom eqRgn'spec :
  forall (s1:set.Fset.fset reference) (s2:set.Fset.fset reference),
  ((eqRgn s1 s2) = Init.Datatypes.true) <-> set.Fset.infix_eqeq s1 s2.

Parameter singleton: reference -> set.Fset.fset reference.

Axiom singleton'spec :
  forall (x:reference),
  ((singleton x) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))) /\
  ((set.Fset.cardinal (singleton x)) = 1%Z).

Axiom rgn_extensionality :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (r1 = r2) <-> set.Fset.infix_eqeq r1 r2.

Axiom rgn_union_emptyRgn_id_right :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.empty : set.Fset.fset reference)) = r).

Axiom rgn_union_emptyRgn_id_left :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union (set.Fset.empty : set.Fset.fset reference) r) = r).

Axiom rgn_union_same :
  forall (r:set.Fset.fset reference), ((set.Fset.union r r) = r).

Axiom rgn_union_assoc :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union (set.Fset.union r r') r'')).

Axiom rgn_union_swap1 :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union r' (set.Fset.union r r''))).

Axiom rgn_union_comm :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference),
  ((set.Fset.union r r') = (set.Fset.union r' r)).

Axiom rgn_inter_remove_sngl :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference) (p:reference),
  (r1 = (set.Fset.union r2 (singleton p))) -> ~ set.Fset.mem p r3 ->
  ((set.Fset.inter r1 r3) = (set.Fset.inter r2 r3)).

Axiom rgn_remove_not_in :
  forall (r:set.Fset.fset reference) (x:reference), ~ set.Fset.mem x r ->
  ((set.Fset.remove x r) = r).

Parameter infix_bssh:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom infix_bssh'def :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.true)) /\
  (~ set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.false)).

Axiom rgn_disjoint_union :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.union r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh r1 r3) = Init.Datatypes.true) /\
  ((infix_bssh r2 r3) = Init.Datatypes.true).

Axiom rgn_disjoint_inter :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.inter r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) =
   Init.Datatypes.true).

Axiom rgn_disjoint_singleton :
  forall (x:reference) (r:set.Fset.fset reference), ~ (x = nullConst) ->
  ((infix_bssh (singleton x) r) = Init.Datatypes.true) <-> ~ set.Fset.mem x r.

Parameter rgnSubK:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset reference -> t1 a -> a ->
  set.Fset.fset reference.

Axiom rgnSubK'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (r:reference),
  set.Fset.mem r (rgnSubK s m v) <->
  ~ (r = nullConst) /\ set.Fset.mem r s /\ ((mixfix_lbrb m r) = v).

Axiom rgnSubK_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (x:reference),
  set.Fset.mem x (rgnSubK s m v) <->
  set.Fset.mem x s /\ ((mixfix_lbrb m x) = v).

Axiom rgnSubK_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  set.Fset.subset (rgnSubK s m v) s.

Axiom rgnSubK_idempotent :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  ((rgnSubK (rgnSubK s m v) m v) = (rgnSubK s m v)).

Axiom rgnSubK_monotonic :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (s':set.Fset.fset reference) (m:t1 a)
    (v:a),
  set.Fset.subset s s' -> set.Fset.subset (rgnSubK s m v) (rgnSubK s' m v).

Axiom rgnSubK_twice_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((rgnSubK (rgnSubK s m v) m v') =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom rgnSubK_inter_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((set.Fset.inter (rgnSubK s m v) (rgnSubK s m v')) =
   (set.Fset.empty : set.Fset.fset reference)).

(* Why3 assumption *)
Definition partialBijection (mTo:t1 reference) (mOf:t1 reference) : Prop :=
  ((size (to_fmap1 mTo)) = (size (to_fmap1 mOf))) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mTo x) mOf) = Init.Datatypes.true)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mOf y) mTo) = Init.Datatypes.true)) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((mixfix_lbrb mOf (mixfix_lbrb mTo x)) = x)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((mixfix_lbrb mTo (mixfix_lbrb mOf y)) = y)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant :
  forall (self:t2),
  partialBijection (lor self) (rol self) /\
  ~ ((infix_bscl nullConst (lor self)) = Init.Datatypes.true) /\
  ~ ((infix_bscl nullConst (rol self)) = Init.Datatypes.true).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

(* Why3 assumption *)
Definition idRef (pi:t2) (x:reference) (y:reference) : Prop :=
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) -> idRef pi x y -> idRef pi x' y ->
  (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef pi x y' -> (y = y').

(* Why3 assumption *)
Definition idRgn (pi:t2) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h).

Axiom idRgn_left :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (x:reference), ~ (x = nullConst) ->
  set.Fset.mem x g -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) h.

Axiom idRgn_right :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (y:reference), ~ (y = nullConst) ->
  set.Fset.mem y h -> ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) g.

Axiom idRgn_empty :
  forall (pi:t2),
  idRgn pi (set.Fset.empty : set.Fset.fset reference)
  (set.Fset.empty : set.Fset.fset reference).

(* Why3 assumption *)
Definition idRgn_sub {a:Type} {a_WT:WhyType a} (pi:t2) (m:t1 a) (m':t1 a)
    (v:a) (g:set.Fset.fset reference) (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
   set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
   set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g).

Axiom idRgn_sub_rgnSubK :
  forall {a:Type} {a_WT:WhyType a},
  forall (pi:t2) (m:t1 a) (m':t1 a) (v:a) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl x m) = Init.Datatypes.true)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl y m') = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb m p) = (mixfix_lbrb m' q))) ->
  idRgn_sub pi m m' v g h <-> idRgn pi (rgnSubK g m v) (rgnSubK h m' v).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  (((infix_bscl x (lor (updateRefperm0 pi x y))) = Init.Datatypes.true) /\
   ((infix_bscl y (rol (updateRefperm0 pi x y))) = Init.Datatypes.true)) /\
  (((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y) /\
   ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x)) /\
  (forall (x1:reference), ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl x1 (lor (updateRefperm0 pi x y))) = Init.Datatypes.true)) /\
  (forall (y1:reference), ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl y1 (rol (updateRefperm0 pi x y))) = Init.Datatypes.true)) /\
  (forall (x1:reference), ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) x1) =
    (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1))) /\
  (forall (y1:reference), ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (rol pi) y1) =
    (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1))) /\
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))) /\
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

(* Why3 assumption *)
Definition extends (pi0:t2) (pi1:t2) : Prop :=
  forall (x:reference), ((infix_bscl x (lor pi0)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi1)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x)).

Axiom extends_refl : forall (pi0:t2), extends pi0 pi0.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2), extends pi0 pi1 -> extends pi1 pi2 ->
  extends pi0 pi2.

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) -> ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  extends pi (updateRefperm0 pi x y).

Axiom extends_idRgn :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (rho:t2), extends pi rho -> idRgn rho g h.

Axiom extends_idRef :
  forall (pi:t2) (x:reference) (y:reference), idRef pi x y ->
  forall (rho:t2), extends pi rho -> idRef rho x y.

Axiom extends_exists : forall (pi:t2), exists pi0:t2, extends pi0 pi.

Parameter invert: t2 -> t2.

Axiom invert'spec :
  forall (pi:t2),
  ((lor (invert pi)) = (rol pi)) /\ ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> idRef (invert pi) y x.

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef (invert pi) y z -> (x = z).

(* Why3 assumption *)
Definition identity (pi:t2) (g1:set.Fset.fset reference)
    (g2:set.Fset.fset reference) : Prop :=
  forall (o:reference),
  (set.Fset.mem o g1 /\ set.Fset.mem o g2 <->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true)) /\
  (((infix_bscl o (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) o) = o)).

Axiom identity_in_refperm :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> set.Fset.mem x (set.Fset.inter g1 g2) ->
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = x).

Axiom identity_in_inter :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem x (set.Fset.inter g1 g2).

Axiom identity_ref_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  (x = (mixfix_lbrb (lor pi) x)).

Axiom identity_rgn_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (h1:set.Fset.fset reference) (h2:set.Fset.fset reference),
  identity pi g1 g2 -> idRgn pi h1 h2 -> (h1 = h2).

Axiom identity_null_notin :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> ~ set.Fset.mem nullConst (set.Fset.inter g1 g2).

Axiom identity_sym :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> identity pi g2 g1.

Axiom set1 : forall (a:Type), Type.
Parameter set1_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (set1 a).
Existing Instance set1_WhyType.

Parameter mem1: forall {a:Type} {a_WT:WhyType a}, a -> set1 a -> Prop.

Parameter empty1: forall {a:Type} {a_WT:WhyType a}, set1 a.

(* Why3 assumption *)
Definition isempty {a:Type} {a_WT:WhyType a} (s:set1 a) : Prop :=
  forall (x:a), ~ mem1 x s.

Axiom empty_isempty :
  forall {a:Type} {a_WT:WhyType a}, isempty (empty1 : set1 a).

Axiom mem_empty :
  forall {a:Type} {a_WT:WhyType a}, forall (x:a), ~ mem1 x (empty1 : set1 a).

(* Why3 assumption *)
Definition infix_eqeq1 {a:Type} {a_WT:WhyType a} (s1:set1 a) (s2:set1 a) :
    Prop :=
  forall (x:a), mem1 x s1 <-> mem1 x s2.

Axiom extensionality1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), infix_eqeq1 s1 s2 -> (s1 = s2).

Axiom eq_reflexivity :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set1 a), infix_eqeq1 s s.

Axiom eq_symmetry :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), infix_eqeq1 s1 s2 -> infix_eqeq1 s2 s1.

Axiom eq_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (s3:set1 a), infix_eqeq1 s1 s2 ->
  infix_eqeq1 s2 s3 -> infix_eqeq1 s1 s3.

(* Why3 assumption *)
Definition subset {a:Type} {a_WT:WhyType a} (s1:set1 a) (s2:set1 a) : Prop :=
  forall (x:a), mem1 x s1 -> mem1 x s2.

Axiom subset_reflexivity :
  forall {a:Type} {a_WT:WhyType a}, forall (s:set1 a), subset s s.

Axiom subset_antisymmetry :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a), subset s1 s2 -> subset s2 s1 ->
  infix_eqeq1 s1 s2.

Axiom subset_transitivity :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (s3:set1 a), subset s1 s2 -> subset s2 s3 ->
  subset s1 s3.

Parameter union:
  forall {a:Type} {a_WT:WhyType a}, set1 a -> set1 a -> set1 a.

Axiom union_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (x:a),
  mem1 x (union s1 s2) <-> mem1 x s1 \/ mem1 x s2.

Axiom union_prop :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a),
  subset s1 (union s1 s2) /\ subset s2 (union s1 s2).

Parameter union_onset:
  forall {a:Type} {a_WT:WhyType a}, set1 (set1 a) -> set1 a.

Axiom union_onset_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:set1 (set1 a)) (x:a),
  mem1 x (union_onset c) <-> (exists s:set1 a, mem1 s c /\ mem1 x s).

Axiom union_onset_prop :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:set1 (set1 a)) (s:set1 a), mem1 s c -> subset s (union_onset c).

Axiom empty_collection :
  forall {a:Type} {a_WT:WhyType a},
  forall (c:set1 (set1 a)), isempty c -> isempty (union_onset c).

Parameter inter:
  forall {a:Type} {a_WT:WhyType a}, set1 a -> set1 a -> set1 a.

Axiom inter_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (x:a),
  mem1 x (inter s1 s2) <-> mem1 x s1 /\ mem1 x s2.

Axiom inter_prop :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a),
  subset (inter s1 s2) s1 /\ subset (inter s1 s2) s2.

Parameter diff: forall {a:Type} {a_WT:WhyType a}, set1 a -> set1 a -> set1 a.

Axiom diff_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a) (x:a),
  mem1 x (diff s1 s2) <-> mem1 x s1 /\ ~ mem1 x s2.

Axiom diff_prop :
  forall {a:Type} {a_WT:WhyType a},
  forall (s1:set1 a) (s2:set1 a),
  subset (diff s1 s2) s1 /\
  infix_eqeq1 (inter (diff s1 s2) s2) (empty1 : set1 a).

Parameter singleton1: forall {a:Type} {a_WT:WhyType a}, a -> set1 a.

Axiom singleton_def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:a),
  mem1 m (singleton1 m) /\
  (forall (n:a), ~ (m = n) -> ~ mem1 n (singleton1 m)).

Axiom singleton_mem_invert :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:a) (n:a), mem1 m (singleton1 n) <-> (m = n).

Axiom singUnion :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:a) (n:a),
  mem1 m (union (singleton1 m) (singleton1 n)) /\
  mem1 n (union (singleton1 m) (singleton1 n)).

Parameter interval:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> set1 Numbers.BinNums.Z.

Axiom interval_def1 :
  forall (m:Numbers.BinNums.Z) (n:Numbers.BinNums.Z), (m < n)%Z ->
  forall (i:Numbers.BinNums.Z),
  mem1 i (interval m n) <-> (m <= i)%Z /\ (i < n)%Z.

Axiom interval_def2 :
  forall (m:Numbers.BinNums.Z) (n:Numbers.BinNums.Z), (n <= m)%Z ->
  infix_eqeq1 (interval m n) (empty1 : set1 Numbers.BinNums.Z).

Axiom diff_interval :
  forall (m:Numbers.BinNums.Z) (n:Numbers.BinNums.Z),
  (0%Z < m)%Z /\ (m < n)%Z ->
  infix_eqeq1 (interval 0%Z n) (union (interval 0%Z m) (interval m n)).

(* Why3 assumption *)
Definition disjoint_family {a:Type} {a_WT:WhyType a} (p:set1 (set1 a)) : Prop :=
  forall (s:set1 a) (t3:set1 a), mem1 s p -> mem1 t3 p ->
  ~ infix_eqeq1 s t3 -> infix_eqeq1 (inter s t3) (empty1 : set1 a).

(* Why3 assumption *)
Definition covers_interval (p:set1 (set1 Numbers.BinNums.Z))
    (m:Numbers.BinNums.Z) : Prop :=
  infix_eqeq1 (union_onset p) (interval 0%Z m).

(* Why3 assumption *)
Definition nonempty_subsets {a:Type} {a_WT:WhyType a} (p:set1 (set1 a)) :
    Prop :=
  ~ mem1 (empty1 : set1 a) p.

(* Why3 assumption *)
Inductive partition :=
  | partition'mk : Numbers.BinNums.Z -> set1 (set1 Numbers.BinNums.Z) ->
      partition.
Axiom partition_WhyType : WhyType partition.
Existing Instance partition_WhyType.

(* Why3 assumption *)
Definition parts (v:partition) : set1 (set1 Numbers.BinNums.Z) :=
  match v with
  | partition'mk x x1 => x1
  end.

(* Why3 assumption *)
Definition max (v:partition) : Numbers.BinNums.Z :=
  match v with
  | partition'mk x x1 => x
  end.

(* Why3 assumption *)
Definition isPartition (p:partition) : Prop :=
  ((max p) = 0%Z) /\
  infix_eqeq1 (parts p) (empty1 : set1 (set1 Numbers.BinNums.Z)) \/
  (0%Z < (max p))%Z /\
  disjoint_family (parts p) /\
  covers_interval (parts p) (max p) /\ nonempty_subsets (parts p).

Parameter makePartition: Numbers.BinNums.Z -> partition.

Axiom makePartition_def :
  forall (m:Numbers.BinNums.Z),
  match makePartition m with
  | partition'mk max1 p =>
      ((m <= 0%Z)%Z ->
       (max1 = 0%Z) /\ infix_eqeq1 p (empty1 : set1 (set1 Numbers.BinNums.Z))) /\
      ((0%Z < m)%Z ->
       (max1 = m) /\
       (forall (s:set1 Numbers.BinNums.Z),
        mem1 s p <->
        (exists n:Numbers.BinNums.Z,
         ((0%Z <= n)%Z /\ (n < m)%Z) /\ infix_eqeq1 s (singleton1 n))))
  end.

Axiom makePartition_isPartition :
  forall (m:Numbers.BinNums.Z), isPartition (makePartition m).

Parameter pfind: Numbers.BinNums.Z -> partition -> set1 Numbers.BinNums.Z.

Axiom pfind_def1 :
  forall (p:partition) (i:Numbers.BinNums.Z), isPartition p ->
  (0%Z <= i)%Z /\ (i < (max p))%Z ->
  mem1 (pfind i p) (parts p) /\ mem1 i (pfind i p).

Axiom pfind_def2 :
  forall (p:partition) (i:Numbers.BinNums.Z), isPartition p -> (i < 0%Z)%Z ->
  infix_eqeq1 (pfind i p) (empty1 : set1 Numbers.BinNums.Z).

Axiom pfind_def3 :
  forall (p:partition) (i:Numbers.BinNums.Z), isPartition p ->
  ((max p) <= i)%Z ->
  infix_eqeq1 (pfind i p) (empty1 : set1 Numbers.BinNums.Z).

Axiom pfind_makePartition :
  forall (i:Numbers.BinNums.Z) (m:Numbers.BinNums.Z), (0%Z < m)%Z ->
  (0%Z <= i)%Z /\ (i < m)%Z ->
  infix_eqeq1 (pfind i (makePartition m)) (singleton1 i).

Axiom pfind_mem_parts :
  forall (p:partition) (i:Numbers.BinNums.Z), isPartition p ->
  (0%Z <= i)%Z /\ (i < (max p))%Z -> mem1 (pfind i p) (parts p).

Axiom pfind_ge_max :
  forall (p:partition) (i:Numbers.BinNums.Z), isPartition p ->
  ((max p) <= i)%Z ->
  infix_eqeq1 (pfind i p) (empty1 : set1 Numbers.BinNums.Z).

Axiom pfind_mem :
  forall (p:partition) (x:Numbers.BinNums.Z), isPartition p ->
  (0%Z <= x)%Z /\ (x < (max p))%Z -> mem1 x (pfind x p).

Axiom pfind_eq :
  forall (p:partition) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  isPartition p -> (0%Z <= x)%Z /\ (x < (max p))%Z ->
  (0%Z <= y)%Z /\ (y < (max p))%Z ->
  mem1 y (pfind x p) <-> infix_eqeq1 (pfind x p) (pfind y p).

Parameter punion:
  partition -> set1 Numbers.BinNums.Z -> set1 Numbers.BinNums.Z -> partition.

Axiom punion'def :
  forall (p:partition) (l:set1 Numbers.BinNums.Z) (l':set1 Numbers.BinNums.Z),
  (mem1 l (parts p) /\ mem1 l' (parts p) ->
   ((punion p l l') =
    (let ul := union l l' in
     let nparts :=
     union (diff (diff (parts p) (singleton1 l)) (singleton1 l'))
     (singleton1 ul) in partition'mk (max p) nparts))) /\
  (~ (mem1 l (parts p) /\ mem1 l' (parts p)) -> ((punion p l l') = p)).

Axiom union_not_mem :
  forall (p:partition) (l:set1 Numbers.BinNums.Z) (l':set1 Numbers.BinNums.Z),
  isPartition p -> mem1 l (parts p) -> mem1 l' (parts p) ->
  ~ infix_eqeq1 l l' ->
  let np := punion p l l' in ~ mem1 l (parts np) /\ ~ mem1 l' (parts np).

Axiom union_isPartition :
  forall (p:partition) (l:set1 Numbers.BinNums.Z) (l':set1 Numbers.BinNums.Z),
  isPartition p -> mem1 l (parts p) -> mem1 l' (parts p) ->
  isPartition (punion p l l').

Axiom find_union :
  forall (p:partition) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  isPartition p -> (0%Z <= x)%Z /\ (x < (max p))%Z ->
  (0%Z <= y)%Z /\ (y < (max p))%Z ->
  let np := punion p (pfind x p) (pfind y p) in
  infix_eqeq1 (pfind x np) (pfind y np).

Axiom find_union_other :
  forall (p:partition) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  isPartition p -> (0%Z <= x)%Z /\ (x < (max p))%Z ->
  (0%Z <= y)%Z /\ (y < (max p))%Z -> forall (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (max p))%Z -> ~ mem1 i (pfind x p) ->
  ~ mem1 i (pfind y p) ->
  infix_eqeq1 (pfind i p) (pfind i (punion p (pfind x p) (pfind y p))).

Axiom find_union_other_alt :
  forall (p:partition) (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  isPartition p -> (0%Z <= x)%Z /\ (x < (max p))%Z ->
  (0%Z <= y)%Z /\ (y < (max p))%Z ->
  let np := punion p (pfind x p) (pfind y p) in
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (max p))%Z ->
  ~ mem1 i (pfind x np) -> infix_eqeq1 (pfind i p) (pfind i np).

(* Why3 assumption *)
Definition eq_partition (p1:partition) (p2:partition) : Prop :=
  ((max p1) = (max p2)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (max p1))%Z ->
   infix_eqeq1 (pfind i p1) (pfind i p2)).

Axiom twopart :
  forall (p1:partition) (p2:partition) (x:Numbers.BinNums.Z)
    (y:Numbers.BinNums.Z),
  isPartition p1 -> isPartition p2 -> eq_partition p1 p2 ->
  (0%Z <= x)%Z /\ (x < (max p1))%Z -> (0%Z <= y)%Z /\ (y < (max p1))%Z ->
  eq_partition (punion p1 (pfind x p1) (pfind y p1))
  (punion p2 (pfind x p2) (pfind y p2)).

(* Why3 assumption *)
Definition intset := set1 Numbers.BinNums.Z.

Parameter emptyIntset: set1 Numbers.BinNums.Z.

Axiom emptyIntset_ax : (emptyIntset = (empty1 : set1 Numbers.BinNums.Z)).

Parameter emptyPartition: partition.

Axiom emptyPartition_ax :
  (emptyPartition =
   (partition'mk 0%Z (empty1 : set1 (set1 Numbers.BinNums.Z)))).

(* Why3 assumption *)
Inductive reftype :=
  | IntArray : reftype
  | Ufind : reftype.
Axiom reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

(* Why3 assumption *)
Inductive heap :=
  | heap'mk : t1 reference -> t1 Numbers.BinNums.Z -> t1 partition ->
      t1 (set.Fset.fset reference) -> t1 Numbers.BinNums.Z ->
      t1 (array Numbers.BinNums.Z) -> heap.
Axiom heap_WhyType : WhyType heap.
Existing Instance heap_WhyType.

(* Why3 assumption *)
Definition slots (v:heap) : t1 (array Numbers.BinNums.Z) :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x5
  end.

(* Why3 assumption *)
Definition length1 (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x4
  end.

(* Why3 assumption *)
Definition rep (v:heap) : t1 (set.Fset.fset reference) :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x3
  end.

(* Why3 assumption *)
Definition part (v:heap) : t1 partition :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x2
  end.

(* Why3 assumption *)
Definition count (v:heap) : t1 Numbers.BinNums.Z :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x1
  end.

(* Why3 assumption *)
Definition id (v:heap) : t1 reference :=
  match v with
  | heap'mk x x1 x2 x3 x4 x5 => x
  end.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter heap1: state -> heap.

Parameter alloct: state -> t1 reftype.

Parameter pool: state -> set.Fset.fset reference.

Axiom state'invariant :
  forall (self:state),
  ~ ((infix_bscl nullConst (alloct self)) = Init.Datatypes.true) /\
  (forall (p:reference),
   ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (alloct self) p) = IntArray) ->
   (((infix_bscl p (length1 (heap1 self))) = Init.Datatypes.true) /\
    ((infix_bscl p (slots (heap1 self))) = Init.Datatypes.true)) /\
   (0%Z <= (mixfix_lbrb (length1 (heap1 self)) p))%Z /\
   ((mixfix_lbrb (length1 (heap1 self)) p) =
    (length (mixfix_lbrb (slots (heap1 self)) p)))) /\
  (forall (p:reference),
   ((infix_bscl p (alloct self)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (alloct self) p) = Ufind) ->
   (((infix_bscl p (id (heap1 self))) = Init.Datatypes.true) /\
    ((infix_bscl p (count (heap1 self))) = Init.Datatypes.true) /\
    ((infix_bscl p (part (heap1 self))) = Init.Datatypes.true) /\
    ((infix_bscl p (rep (heap1 self))) = Init.Datatypes.true)) /\
   (((mixfix_lbrb (id (heap1 self)) p) = nullConst) \/
    ((infix_bscl (mixfix_lbrb (id (heap1 self)) p) (alloct self)) =
     Init.Datatypes.true) /\
    ((mixfix_lbrb (alloct self) (mixfix_lbrb (id (heap1 self)) p)) =
     IntArray)) /\
   (forall (q:reference),
    set.Fset.mem q (mixfix_lbrb (rep (heap1 self)) p) ->
    (q = nullConst) \/ ((infix_bscl q (alloct self)) = Init.Datatypes.true))) /\
  (forall (q:reference), set.Fset.mem q (pool self) ->
   (q = nullConst) \/ ((infix_bscl q (alloct self)) = Init.Datatypes.true)).

(* Why3 assumption *)
Definition isAllocated (s:state) (p:reference) : Prop :=
  ((infix_bscl p (alloct s)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition isValidRgn (s:state) (r:set.Fset.fset reference) : Prop :=
  forall (q:reference), set.Fset.mem q r ->
  (q = nullConst) \/ ((infix_bscl q (alloct s)) = Init.Datatypes.true).

(* Why3 assumption *)
Definition typeofRgn (s:state) (r:set.Fset.fset reference)
    (types:Init.Datatypes.list reftype) : Prop :=
  forall (p:reference), set.Fset.mem p r ->
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  list.Mem.mem (mixfix_lbrb (alloct s) p) types.

(* Why3 assumption *)
Definition hasIntArrayType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = IntArray).

(* Why3 assumption *)
Definition hasUfindType (s:state) (p:reference) : Prop :=
  (p = nullConst) \/
  ((infix_bscl p (alloct s)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct s) p) = Ufind).

(* Why3 assumption *)
Definition okRefperm (sl:state) (sr:state) (pi:t2) : Prop :=
  (forall (p:reference), ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl p (alloct sl)) = Init.Datatypes.true)) /\
  (forall (q:reference), ((infix_bscl q (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl q (alloct sr)) = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct sl) p) = (mixfix_lbrb (alloct sr) q))).

Parameter img_slots:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_slots_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_slots s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_rep:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_rep_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_rep s r) <->
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Ufind) /\
   set.Fset.mem q r /\ set.Fset.mem p (mixfix_lbrb (rep (heap1 s)) q)).

Parameter img_part:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_part_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_part s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_length:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_length_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_length s r) = (set.Fset.empty : set.Fset.fset reference)).

Parameter img_id:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_id_ax :
  forall (s:state) (r:set.Fset.fset reference) (p:reference),
  set.Fset.mem p (img_id s r) <->
  (exists q:reference,
   ((infix_bscl q (alloct s)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (alloct s) q) = Ufind) /\
   set.Fset.mem q r /\ (p = (mixfix_lbrb (id (heap1 s)) q))).

Parameter img_count:
  state -> set.Fset.fset reference -> set.Fset.fset reference.

Axiom img_count_ax :
  forall (s:state) (r:set.Fset.fset reference),
  ((img_count s r) = (set.Fset.empty : set.Fset.fset reference)).

(* Why3 assumption *)
Definition alloc_does_not_shrink (pre:state) (post:state) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((infix_bscl p (alloct post)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (alloct pre) p) = (mixfix_lbrb (alloct post) p)).

(* Why3 assumption *)
Definition wrs_to_length_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = IntArray) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (length1 (heap1 pre)) p) =
   (mixfix_lbrb (length1 (heap1 post)) p)).

(* Why3 assumption *)
Definition wrs_to_slots_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = IntArray) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (slots (heap1 pre)) p) =
   (mixfix_lbrb (slots (heap1 post)) p)).

(* Why3 assumption *)
Definition wrs_to_id_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = Ufind) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (id (heap1 pre)) p) = (mixfix_lbrb (id (heap1 post)) p)).

(* Why3 assumption *)
Definition wrs_to_count_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = Ufind) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (count (heap1 pre)) p) =
   (mixfix_lbrb (count (heap1 post)) p)).

(* Why3 assumption *)
Definition wrs_to_part_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = Ufind) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (part (heap1 pre)) p) = (mixfix_lbrb (part (heap1 post)) p)).

(* Why3 assumption *)
Definition wrs_to_rep_framed_by (pre:state) (post:state)
    (r:set.Fset.fset reference) : Prop :=
  forall (p:reference),
  ((infix_bscl p (alloct pre)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (alloct post) p) = Ufind) -> ~ set.Fset.mem p r ->
  ((mixfix_lbrb (rep (heap1 pre)) p) = (mixfix_lbrb (rep (heap1 post)) p)).

(* Why3 assumption *)
Definition agree_slots (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasIntArrayType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (slots (heap1 sl)) o) =
    (mixfix_lbrb (slots (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_rep (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasUfindType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRgn pi (mixfix_lbrb (rep (heap1 sl)) o)
   (mixfix_lbrb (rep (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_part (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasUfindType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (part (heap1 sl)) o) =
    (mixfix_lbrb (part (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_length (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasIntArrayType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (length1 (heap1 sl)) o) =
    (mixfix_lbrb (length1 (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_id (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasUfindType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   idRef pi (mixfix_lbrb (id (heap1 sl)) o)
   (mixfix_lbrb (id (heap1 sr)) (mixfix_lbrb (lor pi) o))).

(* Why3 assumption *)
Definition agree_count (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  okRefperm sl sr pi /\
  (forall (o:reference), isAllocated sl o -> hasUfindType sl o ->
   set.Fset.mem o w ->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true) /\
   ((mixfix_lbrb (count (heap1 sl)) o) =
    (mixfix_lbrb (count (heap1 sr)) (mixfix_lbrb (lor pi) o)))).

(* Why3 assumption *)
Definition agree_allfields (sl:state) (sr:state) (pi:t2)
    (w:set.Fset.fset reference) : Prop :=
  agree_length sl sr pi w /\
  agree_slots sl sr pi w /\
  agree_id sl sr pi w /\
  agree_count sl sr pi w /\ agree_part sl sr pi w /\ agree_rep sl sr pi w.

(* Why3 assumption *)
Definition okUfind (s:state) (uf:reference) : Prop :=
  hasUfindType s uf -> isPartition (mixfix_lbrb (part (heap1 s)) uf).

(* Why3 assumption *)
Definition ufPub (s:state) : Prop :=
  forall (p:reference) (q:reference), isAllocated s p -> hasUfindType s p ->
  set.Fset.mem p (pool s) -> isAllocated s q -> hasUfindType s q ->
  set.Fset.mem q (pool s) -> ~ (p = q) ->
  ((infix_bssh (mixfix_lbrb (rep (heap1 s)) p)
    (mixfix_lbrb (rep (heap1 s)) q))
   = Init.Datatypes.true).

(* Why3 assumption *)
Definition ufInv (s:state) (p:reference) : Prop :=
  hasUfindType s p ->
  let id1 := mixfix_lbrb (id (heap1 s)) p in
  ~ (id1 = nullConst) /\
  (let len := mixfix_lbrb (length1 (heap1 s)) id1 in
   let prt := mixfix_lbrb (part (heap1 s)) p in
   ((mixfix_lbrb (count (heap1 s)) p) <= len)%Z /\
   (len = (max prt)) /\
   ((mixfix_lbrb (rep (heap1 s)) p) = (singleton id1)) /\
   (forall (x:Numbers.BinNums.Z), (0%Z <= x)%Z /\ (x < len)%Z ->
    (let idx := get (mixfix_lbrb (slots (heap1 s)) id1) x in
     (0%Z <= idx)%Z /\ (idx < len)%Z)) /\
   (forall (x:Numbers.BinNums.Z), (0%Z <= x)%Z /\ (x < len)%Z ->
    (let idx := get (mixfix_lbrb (slots (heap1 s)) id1) x in
     ((get (mixfix_lbrb (slots (heap1 s)) id1) idx) = idx))) /\
   (forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
    (0%Z <= x)%Z /\ (x < len)%Z -> (0%Z <= y)%Z /\ (y < len)%Z ->
    mem1 y (pfind x prt) <->
    ((get (mixfix_lbrb (slots (heap1 s)) id1) x) =
     (get (mixfix_lbrb (slots (heap1 s)) id1) y)))).

(* Why3 assumption *)
Definition ufPriv (s:state) : Prop :=
  forall (p:reference), isAllocated s p -> hasUfindType s p ->
  set.Fset.mem p (pool s) -> ufInv s p.

Axiom qfind1 :
  forall (s:state), forall (p:reference) (x:Numbers.BinNums.Z),
  isAllocated s p -> hasUfindType s p -> set.Fset.mem p (pool s) ->
  ufPriv s ->
  let prt := mixfix_lbrb (part (heap1 s)) p in
  (0%Z <= x)%Z /\ (x < (max prt))%Z ->
  mem1 (get (mixfix_lbrb (slots (heap1 s)) (mixfix_lbrb (id (heap1 s)) p)) x)
  (pfind x prt).

Axiom qfind2 :
  forall (s:state),
  forall (p:reference) (x:Numbers.BinNums.Z) (i:Numbers.BinNums.Z),
  isAllocated s p -> hasUfindType s p -> set.Fset.mem p (pool s) ->
  ufPriv s ->
  let prt := mixfix_lbrb (part (heap1 s)) p in
  let id1 := mixfix_lbrb (id (heap1 s)) p in
  (0%Z <= x)%Z /\ (x < (max prt))%Z -> (0%Z <= i)%Z /\ (i < (max prt))%Z ->
  mem1 i (pfind x prt) ->
  ((get (mixfix_lbrb (slots (heap1 s)) id1) i) = i) ->
  ((get (mixfix_lbrb (slots (heap1 s)) id1) x) = i).

(* Why3 goal *)
Theorem boundary_frames_invariant_QuickFind :
  forall (s:state) (t3:state) (pi:t2), okRefperm s t3 pi ->
  identity pi (domain (to_fmap1 (alloct s))) (domain (to_fmap1 (alloct t3))) ->
  idRgn pi (pool s) (pool t3) ->
  agree_allfields s t3 pi (set.Fset.union (pool s) (img_rep s (pool s))) ->
  ufPriv s -> ufPriv t3.
Proof.
intros s t3 pi h1 h2 h3 h4 h5.

Qed.

