module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = {  }
  
  type state = private { mutable ghost alloct : M.t reftype }
    invariant { not (M.mem null alloct) }
    by { alloct = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference. ((Rgn.mem p r) -> ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference. ((M.mem p pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference. ((M.mem p pre.alloct) -> ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn)
end

module I
  use prelude.Prelude
  use State
end

module Impl
  use prelude.Prelude
  use State
  use I
end

module MAIN
  use prelude.Prelude
  use State
end

module REL
  use prelude.Prelude
  use State
  use Impl
  
  let m (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_x : int) (l_n : int) (r_x : int) (r_n : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_x = r_x) }
    requires { ((l_x >= 0) /\ (r_x >= 0)) }
    requires { ((l_n > 0) /\ (r_n > 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref l_x in
      let l_n = ref l_n in
      let r_x = ref r_x in
      let r_n = ref r_n in
      let l_y = ref 0 in
      let r_y = ref 0 in
      let l_z = ref 0 in
      let r_z = ref 0 in
      let l_w = ref 0 in
      let r_w = ref 0 in
      (l_y := ([@expl:y := x] (! l_x)));
      (r_y := ([@expl:y := x] (! r_x)));
      (l_z := ([@expl:z := 0] 0));
      (r_z := ([@expl:z := 0] 0));
      (l_w := ([@expl:w := 0] 0));
      (r_w := ([@expl:w := 0] 0));
      while ((! l_y) > 0)  || ((! r_y) > 0) do
        invariant { okRefperm l_s r_s pi }
        invariant { ((! l_y) = (! r_y)) }
        invariant { (((0 <= (! l_y)) /\ ((! l_y) <= (! l_x))) /\ ((0 <= (! r_y)) /\ ((! r_y) <= (! r_x)))) }
        invariant { (((0 <= (! l_w)) /\ ((! l_w) < (! l_n))) /\ ((0 <= (! r_w)) /\ ((! r_w) < (! r_n)))) }
        invariant { ((! l_z) = (! r_z)) }
        invariant {
          [@expl:alignment condition]
          ((((! l_y) > 0) /\ ((! l_w) <> 0)) \/
             ((((! r_y) > 0) /\ ((! r_w) <> 0)) \/ ((((! l_y) > 0) /\ ((! r_y) > 0)) \/ ((not ((! l_y) > 0)) /\ (not ((! r_y) > 0)))))) }
        if ([@expl:Left step] (((! l_y) > 0)  && (not ((! l_w) = 0)))) then
          ((if ((! l_w) = 0) then ((l_z := ([@expl:havoc z] (any int))); (l_y := ([@expl:y := y - 1] ((! l_y) - 1))))
            else ());
           (l_w := ([@expl:w := (w + 1) mod n] (mod ((! l_w) + 1) (! l_n)))))
        else
          (if ([@expl:Right step] (((! r_y) > 0)  && (not ((! r_w) = 0)))) then
             (let vsnap = mod ((! r_n) - (! r_w)) (! r_n) in
              (if ((! r_w) = 0) then ((r_z := ([@expl:havoc z] (any int))); (r_y := ([@expl:y := y - 1] ((! r_y) - 1))))
               else ());
              (r_w := ([@expl:w := (w + 1) mod n] (mod ((! r_w) + 1) (! r_n))));
              assert { (((mod ((! r_n) - (! r_w)) (! r_n)) >= 0) /\ ((mod ((! r_n) - (! r_w)) (! r_n)) < vsnap)) })
           else
             (([@expl:guard agreement] assert { (((! l_w) = 0) = ((! r_w) = 0)) });
              (if ((! l_w) = 0) then
                 ((l_z := ([@expl:havoc z] (any int)));
                  assert { exists r_z : int. ((! l_z) = r_z) };
                  (r_z := ([@expl:havoc z] (any int)));
                  assume { ((! l_z) = (! r_z)) };
                  (l_y := ([@expl:y := y - 1] ((! l_y) - 1)));
                  (r_y := ([@expl:y := y - 1] ((! r_y) - 1))))
               else ());
              (l_w := ([@expl:w := (w + 1) mod n] (mod ((! l_w) + 1) (! l_n))));
              (r_w := ([@expl:w := (w + 1) mod n] (mod ((! r_w) + 1) (! r_n))))))
      done;
      (l_result := ([@expl:result := z] (! l_z)));
      (r_result := ([@expl:result := z] (! r_z)));
      ((! l_result), (! r_result))
end

module REL_biinterface
  use prelude.Prelude
  use State
  use Impl
end

