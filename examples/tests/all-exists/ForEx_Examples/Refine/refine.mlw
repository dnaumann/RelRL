module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
      | Cell
  
  type state = private {
              mutable ghost alloct : M.t reftype;
              mutable c : M.t int;
              mutable x : M.t int
              }
    invariant { not (M.mem null alloct) }
    invariant {
      forall p : reference.
        ((M.mem p alloct) ->
           (((alloct[p]) = Cell) -> ((M.mem p c) /\ (M.mem p x)))) }
    invariant { not (M.mem null c) }
    invariant { not (M.mem null x) }
    by { alloct = (().M.create) ; c = (().M.create) ; x = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate hasCellType (s: state) (p: reference) =
    ((p = null) \/ ((M.mem p s.alloct) /\ ((s.alloct[p]) = Cell)))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct, s.c, s.x }
    ensures { not (M.mem result (old s.alloct)) }
    
    ensures { (s.alloct = (M.add result Cell (old s.alloct))) }
    
    ensures { forall p : reference.
                ((M.mem p (old s.alloct)) ->
                   ((M.mem p s.alloct) /\
                      (((old s.alloct)[p]) = (s.alloct[p])))) }
    
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { (s.c = (M.add result 0 (old s.c))) }
    
    ensures { (s.x = (M.add result 0 (old s.x))) }
  
  val set_c (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.c }
    ensures { (s.c = (M.add o v (old s.c))) }
  
  val set_x (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.x }
    ensures { (s.x = (M.add o v (old s.x))) }
  
  function img_x : state -> (rgn -> rgn)
  
  axiom img_x_ax: forall s : state, r : rgn. ((img_x s r) = emptyRgn)
  
  function img_c : state -> (rgn -> rgn)
  
  axiom img_c_ax: forall s : state, r : rgn. ((img_c s r) = emptyRgn)
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate wr_frame_c (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.c[p]) = (post.c[p])))))
  
  predicate wr_frame_x (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.x[p]) = (post.x[p])))))
  
  predicate agree_x (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.x[o]) = (sr.x[pi.lor[o]])))))))))
  
  predicate agree_c (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.c[o]) = (sr.c[pi.lor[o]])))))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_c sl sr pi w) /\ (agree_x sl sr pi w)
end

module REFINE
  use prelude.Prelude
  use State
  
  val refine (s: state) (time: int) : reference
    writes { s.alloct }
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { alloc_does_not_shrink (old s) s }
end

module A
  use prelude.Prelude
  use State
  use REFINE
  
  val refine (s: state) (time: int) : reference
    writes { s.alloct }
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { alloc_does_not_shrink (old s) s }
end

module Birefine
  use prelude.Prelude
  use State
  use A
  
  let refine (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_time : int) (r_time : int) : 
    (reference, reference)
    requires { okRefperm l_s r_s pi }
    requires { (l_time = r_time) }
    writes { l_s.alloct, l_s.c, l_s.x, r_s.alloct, r_s.c, r_s.x }
    ensures { match result with
              | (l_result, _) -> hasCellType l_s l_result
              end }
    
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { alloc_does_not_shrink (old l_s) l_s }
    
    ensures { [@expl:wr {}`c] (wr_frame_c (old l_s) l_s emptyRgn) }
    
    ensures { [@expl:wr {}`x] (wr_frame_x (old l_s) l_s emptyRgn) }
    
    ensures { alloc_does_not_shrink (old r_s) r_s }
    
    ensures { [@expl:wr {}`c] (wr_frame_c (old r_s) r_s emptyRgn) }
    
    ensures { [@expl:wr {}`x] (wr_frame_x (old r_s) r_s emptyRgn) }
    
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((l_s.c[l_result]) = 0)
                    ->
                    ((r_s.c[r_result]) = 1)
                    /\
                    (let l_x = l_s.x[l_result] in
                     let r_x = r_s.x[r_result] in
                     (l_x = r_x))
              end }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((not (l_result = null)) /\ (not (r_result = null)))
              end }
    diverges
  = label INIT in
      let r_result = ref null in
      let l_result = ref null in
      let l_time = ref l_time in
      let r_time = ref r_time in
      let l_k = ref 0 in
      let r_k = ref 0 in
      let l_s0 = ref 0 in
      let r_s0 = ref 0 in
      let l_b = ref false in
      let r_b = ref false in
      let l_temp1 = ref 0 in
      let r_temp1 = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let l_c = ref 0 in
      let r_c = ref 0 in
      (l_k := ([@expl:k := time] (! l_time)));
      (r_k := ([@expl:k := time] (! r_time)));
      (l_b := ([@expl:havoc b] (any bool)));
      (if (! l_b) then
         ((l_x := ([@expl:x := 0] 0));
          (l_c := ([@expl:c := 0] 0));
          while ((! l_k) > 0) do
            invariant {
              [@expl:locals type invariant] (hasCellType l_s (! l_result)) }
            invariant { alloc_does_not_shrink (old l_s) l_s }
            invariant { ((! l_x) + (! l_k)) = (! l_time) }
            invariant { ((! l_time) <= 0) -> ((! l_x) = 0) }
            invariant { ((! l_time) > 0) -> ((! l_k) >= 0) }
            (l_k := ([@expl:k := k - 1] ((! l_k) - 1)));
            (l_x := ([@expl:x := x + 1] ((! l_x) + 1)))
          done)
       else
         ((l_x := ([@expl:x := 0] 0));
          (l_c := ([@expl:c := 1] 1));
          while ((! l_k) > 0) do
            invariant {
              [@expl:locals type invariant] (hasCellType l_s (! l_result)) }
            invariant { alloc_does_not_shrink (old l_s) l_s }
            invariant { ((! l_time) <= 0) -> ((! l_x) = 0) }
            invariant { (! l_time) >= (! l_k) }
            (l_k := ([@expl:k := k - 1] ((! l_k) - 1)));
            (l_s0 := ([@expl:havoc s0] (any int)));
            (l_x := ([@expl:x := x + s0] ((! l_x) + (! l_s0))))
          done));
      assert { exists r_b : bool. ((! l_b) = r_b) };
      (r_b := ([@expl:havoc b] (any bool)));
      assume { ((! l_b) = (! r_b)) };
      (if (false  && (! r_b)) then
         ((r_x := ([@expl:x := 0] 0));
          (r_c := ([@expl:c := 0] 0));
          while ((! r_k) > 0) do
            invariant {
              [@expl:locals type invariant left] (hasCellType l_s (! l_result)) }
            invariant {
              [@expl:locals type invariant right]
              (hasCellType r_s (! r_result)) }
            invariant { okRefperm l_s r_s pi }
            let r_q__vnt7 = ref 0 in
            let r_q__b8 = ref false in
            (r_q__vnt7 := ([@expl:havoc q__vnt7] (any int)));
            assume { (! r_q__vnt7) = (! r_k) };
            (r_q__b8 := ([@expl:havoc q__b8] (any bool)));
            assume {
              (! r_q__b8)
                <->
                (not (false /\ (false /\ false)))
                /\
                ((! r_k) > 0)
                /\
                (true /\ true) };
            (r_k := ([@expl:k := k - 1] ((! r_k) - 1)));
            (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
            assert { (! r_q__b8) -> (0 <= (! r_q__vnt7)) };
            assert { (! r_q__b8) -> ((! r_k) < (! r_q__vnt7)) }
          done)
       else
         (if (false  && (not (! r_b))) then
            ((r_x := ([@expl:x := 0] 0));
             (r_c := ([@expl:c := 1] 1));
             while ((! r_k) > 0) do
               invariant {
                 [@expl:locals type invariant left]
                 (hasCellType l_s (! l_result)) }
               invariant {
                 [@expl:locals type invariant right]
                 (hasCellType r_s (! r_result)) }
               invariant { okRefperm l_s r_s pi }
               invariant { ((! r_x) + (! r_k)) = (! r_time) }
               invariant { ((! r_time) <= 0) -> ((! r_x) = 0) }
               invariant { ((! r_time) > 0) -> ((! r_k) >= 0) }
               let r_q__vnt5 = ref 0 in
               let r_q__b6 = ref false in
               (r_q__vnt5 := ([@expl:havoc q__vnt5] (any int)));
               assume { (! r_q__vnt5) = (! r_k) };
               (r_q__b6 := ([@expl:havoc q__b6] (any bool)));
               assume {
                 (! r_q__b6)
                   <->
                   (not (false /\ (false /\ false)))
                   /\
                   ((! r_k) > 0)
                   /\
                   (true /\ true) };
               (r_k := ([@expl:k := k - 1] ((! r_k) - 1)));
               assert { exists r_s0 : int. r_s0 = 1 };
               (r_s0 := ([@expl:havoc s0] (any int)));
               assume { (! r_s0) = 1 };
               (r_x := ([@expl:x := x + s0] ((! r_x) + (! r_s0))));
               assert { (! r_q__b6) -> (0 <= (! r_q__vnt5)) };
               assert { (! r_q__b6) -> ((! r_k) < (! r_q__vnt5)) }
             done)
          else
            (if ((not false)  && (! r_b)) then
               ((r_x := ([@expl:x := 0] 0));
                (r_c := ([@expl:c := 0] 0));
                while ((! r_k) > 0) do
                  invariant {
                    [@expl:locals type invariant left]
                    (hasCellType l_s (! l_result)) }
                  invariant {
                    [@expl:locals type invariant right]
                    (hasCellType r_s (! r_result)) }
                  invariant { okRefperm l_s r_s pi }
                  let r_q__vnt3 = ref 0 in
                  let r_q__b4 = ref false in
                  (r_q__vnt3 := ([@expl:havoc q__vnt3] (any int)));
                  assume { (! r_q__vnt3) = (! r_k) };
                  (r_q__b4 := ([@expl:havoc q__b4] (any bool)));
                  assume {
                    (! r_q__b4)
                      <->
                      (not (false /\ (false /\ false)))
                      /\
                      ((! r_k) > 0)
                      /\
                      (true /\ true) };
                  (r_k := ([@expl:k := k - 1] ((! r_k) - 1)));
                  (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
                  assert { (! r_q__b4) -> (0 <= (! r_q__vnt3)) };
                  assert { (! r_q__b4) -> ((! r_k) < (! r_q__vnt3)) }
                done)
             else
               ((r_x := ([@expl:x := 0] 0));
                (r_c := ([@expl:c := 1] 1));
                while ((! r_k) > 0) do
                  invariant {
                    [@expl:locals type invariant left]
                    (hasCellType l_s (! l_result)) }
                  invariant {
                    [@expl:locals type invariant right]
                    (hasCellType r_s (! r_result)) }
                  invariant { okRefperm l_s r_s pi }
                  invariant { ((! r_x) + (! r_k)) = (! r_time) }
                  invariant { ((! r_time) <= 0) -> ((! r_x) = 0) }
                  invariant { ((! r_time) > 0) -> ((! r_k) >= 0) }
                  let r_q__vnt1 = ref 0 in
                  let r_q__b2 = ref false in
                  (r_q__vnt1 := ([@expl:havoc q__vnt1] (any int)));
                  assume { (! r_q__vnt1) = (! r_k) };
                  (r_q__b2 := ([@expl:havoc q__b2] (any bool)));
                  assume {
                    (! r_q__b2)
                      <->
                      (not (false /\ (false /\ false)))
                      /\
                      ((! r_k) > 0)
                      /\
                      (true /\ true) };
                  (r_k := ([@expl:k := k - 1] ((! r_k) - 1)));
                  assert { exists r_s0 : int. r_s0 = 1 };
                  (r_s0 := ([@expl:havoc s0] (any int)));
                  assume { (! r_s0) = 1 };
                  (r_x := ([@expl:x := x + s0] ((! r_x) + (! r_s0))));
                  assert { (! r_q__b2) -> (0 <= (! r_q__vnt1)) };
                  assert { (! r_q__b2) -> ((! r_k) < (! r_q__vnt1)) }
                done))));
      (l_result := ([@expl:result := new Cell] (l_s.mk_Cell)));
      (r_result := ([@expl:result := new Cell] (r_s.mk_Cell)));
      ([@expl:result.x := x] (set_x l_s (! l_result) (! l_x)));
      ([@expl:result.x := x] (set_x r_s (! r_result) (! r_x)));
      ([@expl:result.c := c] (set_c l_s (! l_result) (! l_c)));
      ([@expl:result.c := c] (set_c r_s (! r_result) (! r_c)));
      ((! l_result), (! r_result))
end

module Birefine_biinterface
  use prelude.Prelude
  use State
  use A
  
  val refine (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_time: int) (r_time: int) : 
    (reference, reference)
    requires { okRefperm l_s r_s pi }
    requires { (l_time = r_time) }
    writes { l_s.alloct, r_s.alloct }
    ensures { match result with
              | (l_result, _) -> hasCellType l_s l_result
              end }
    
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { alloc_does_not_shrink (old l_s) l_s }
    
    ensures { alloc_does_not_shrink (old r_s) r_s }
    
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((l_s.c[l_result]) = 0)
                    ->
                    ((r_s.c[r_result]) = 1)
                    /\
                    (let l_x = l_s.x[l_result] in
                     let r_x = r_s.x[r_result] in
                     (l_x = r_x))
              end }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((not (l_result = null)) /\ (not (r_result = null)))
              end }
end

module MAIN
  use prelude.Prelude
  use State
end

