module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = {  }
  
  type state = private { mutable ghost alloct : M.t reftype }
    invariant { not (M.mem null alloct) }
    by { alloct = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn)
end

module EMPTY
  use prelude.Prelude
  use State
end

module MAIN
  use prelude.Prelude
  use State
end

module U
  use prelude.Prelude
  use State
  use EMPTY
  
  let noninterference (s : state) (high : int) (low : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let high = ref high in
      let low = ref low in
      let x = ref 0 in
      let b = ref 0 in
      (if (not ((! high) = 0)) then
         ((x := ([@expl:havoc x] (any int)));
          (if ((! x) >= (! low)) then ()
           else
             while true do
               invariant { alloc_does_not_shrink (old s) s }
               ()
             done))
       else
         ((x := ([@expl:x := low] (! low)));
          (b := ([@expl:havoc b] (any int)));
          while not ((! b) = 0) do
            invariant { alloc_does_not_shrink (old s) s }
            (x := ([@expl:x := x + 1] ((! x) + 1)));
            (b := ([@expl:havoc b] (any int)))
          done));
      (result := ([@expl:result := x] (! x)));
      (! result)
end

module UREL
  use prelude.Prelude
  use State
  use U
  
  let noninterference (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_high : int) (l_low : int) (r_high : int) (r_low : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_low = r_low) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_high = ref l_high in
      let l_low = ref l_low in
      let r_high = ref r_high in
      let r_low = ref r_low in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let l_b = ref 0 in
      let r_b = ref 0 in
      (if ((not ((! l_high) = 0))  && (not ((! r_high) = 0))) then
         ((l_x := ([@expl:havoc x] (any int)));
          assert { exists r_x : int. ((! l_x) = r_x) };
          (r_x := ([@expl:havoc x] (any int)));
          assume { ((! l_x) = (! r_x)) };
          ([@expl:guard agreement]
           assert { (((! l_x) >= (! l_low)) = ((! r_x) >= (! r_low))) });
          (if ((! l_x) >= (! l_low)) then ()
           else
             (while true do
                invariant { alloc_does_not_shrink (old l_s) l_s }
                ()
              done;
              assert { (false /\ false) };
              while true do
                invariant { alloc_does_not_shrink (old r_s) r_s }
                let q__vnt4 = ref 0 in
                (q__vnt4 := ([@expl:q__vnt4 := 0] 0));
                assert { 0 <= (! q__vnt4) };
                assert { 0 < (! q__vnt4) }
              done)))
       else
         (if ((not ((! l_high) = 0))  && (not (not ((! r_high) = 0)))) then
            ((l_x := ([@expl:havoc x] (any int)));
             (if ((! l_x) >= (! l_low)) then ()
              else
                while true do
                  invariant { alloc_does_not_shrink (old l_s) l_s }
                  ()
                done);
             assert { (! l_x) >= (! l_low) };
             (r_x := ([@expl:x := low] (! r_low)));
             assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
             (r_b := ([@expl:havoc b] (any int)));
             assume { (! r_b) = (! l_x) - (! r_x) };
             while not ((! r_b) = 0) do
               invariant { okRefperm l_s r_s pi }
               invariant { (! r_b) >= 0 }
               invariant { (! l_x) >= (! r_x) }
               invariant { (! r_b) = (! l_x) - (! r_x) }
               let r_q__vnt2 = ref 0 in
               let r_q__b3 = ref false in
               (r_q__vnt2 := ([@expl:havoc q__vnt2] (any int)));
               assume { (! r_q__vnt2) = (! r_b) };
               (r_q__b3 := ([@expl:havoc q__b3] (any bool)));
               assume {
                 (! r_q__b3)
                   <->
                   (not (false /\ (false /\ false)))
                   /\
                   ((! r_b) <> 0)
                   /\
                   (true /\ true) };
               (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
               assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
               (r_b := ([@expl:havoc b] (any int)));
               assume { (! r_b) = (! l_x) - (! r_x) };
               assert { (! r_q__b3) -> (0 <= (! r_q__vnt2)) };
               assert { (! r_q__b3) -> ((! r_b) < (! r_q__vnt2)) }
             done)
          else
            (if ((not (not ((! l_high) = 0)))  && (not ((! r_high) = 0))) then
               ((l_x := ([@expl:x := low] (! l_low)));
                (l_b := ([@expl:havoc b] (any int)));
                while not ((! l_b) = 0) do
                  invariant { okRefperm l_s r_s pi }
                  invariant { (! l_x) >= (! l_low) }
                  (l_x := ([@expl:x := x + 1] ((! l_x) + 1)));
                  (l_b := ([@expl:havoc b] (any int)))
                done;
                assert { exists r_x : int. ((! l_x) = r_x) };
                (r_x := ([@expl:havoc x] (any int)));
                assume { ((! l_x) = (! r_x)) };
                (if ((! r_x) >= (! r_low)) then ()
                 else
                   (assert { false };
                    while true do
                      invariant { alloc_does_not_shrink (old r_s) r_s }
                      let q__vnt1 = ref 0 in
                      (q__vnt1 := ([@expl:q__vnt1 := 0] 0));
                      assert { 0 <= (! q__vnt1) };
                      assert { 0 < (! q__vnt1) }
                    done)))
             else
               ((l_x := ([@expl:x := low] (! l_low)));
                (r_x := ([@expl:x := low] (! r_low)));
                (l_b := ([@expl:havoc b] (any int)));
                assert { exists r_b : int. ((! l_b) = r_b) };
                (r_b := ([@expl:havoc b] (any int)));
                assume { ((! l_b) = (! r_b)) };
                while not ((! l_b) = 0) do
                  invariant { okRefperm l_s r_s pi }
                  invariant { ((! l_b) = (! r_b)) /\ ((! l_x) = (! r_x)) }
                  invariant {
                    [@expl:lockstep] (((! l_b) <> 0) = ((! r_b) <> 0)) }
                  (l_x := ([@expl:x := x + 1] ((! l_x) + 1)));
                  (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
                  (l_b := ([@expl:havoc b] (any int)));
                  assert { exists r_b : int. ((! l_b) = r_b) };
                  (r_b := ([@expl:havoc b] (any int)));
                  assume { ((! l_b) = (! r_b)) }
                done))));
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
end

module UREL_biinterface
  use prelude.Prelude
  use State
  use U
end

