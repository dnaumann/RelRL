module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
      | Cell
  
  type state = private {
              mutable ghost alloct : M.t reftype;
              mutable ghost rep : M.t rgn;
              mutable value : M.t int;
              mutable y : int;
              mutable x : int
              }
    invariant { not (M.mem null alloct) }
    invariant {
      forall p : reference.
        ((M.mem p alloct) ->
           (((alloct[p]) = Cell) ->
              (((M.mem p rep) /\ (M.mem p value)) /\
                 (forall q : reference.
                    ((Rgn.mem q (rep[p])) -> ((q = null) \/ (M.mem q alloct))))))) }
    invariant { not (M.mem null rep) }
    invariant { not (M.mem null value) }
    by
      { alloct = (().M.create) ;
        rep = (().M.create) ;
        value = (().M.create) ;
        y = (any int) ;
        x = (any int) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate hasCellType (s: state) (p: reference) =
    ((p = null) \/ ((M.mem p s.alloct) /\ ((s.alloct[p]) = Cell)))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct, s.rep, s.value }
    ensures { not (M.mem result (old s.alloct)) }
    
    ensures { (s.alloct = (M.add result Cell (old s.alloct))) }
    
    ensures { forall p : reference.
                ((M.mem p (old s.alloct)) ->
                   ((M.mem p s.alloct) /\
                      (((old s.alloct)[p]) = (s.alloct[p])))) }
    
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { (s.rep = (M.add result emptyRgn (old s.rep))) }
    
    ensures { (s.value = (M.add result 0 (old s.value))) }
  
  val set_y (s: state) (v: int) : unit
    writes { s.y }
    ensures { (s.y = v) }
  
  val set_x (s: state) (v: int) : unit
    writes { s.x }
    ensures { (s.x = v) }
  
  val set_rep (s: state) (o: reference) (ghost v: rgn) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    requires { isValidRgn s v }
    writes { s.rep }
    ensures { (s.rep = (M.add o v (old s.rep))) }
  
  val set_value (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.value }
    ensures { (s.value = (M.add o v (old s.value))) }
  
  function img_value : state -> (rgn -> rgn)
  
  axiom img_value_ax: forall s : state, r : rgn. ((img_value s r) = emptyRgn)
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax:
    forall s : state, r : rgn, p : reference.
      ((Rgn.mem p (img_rep s r)) <->
         (exists q : reference.
            ((M.mem q s.alloct) /\
               (((s.alloct[q]) = Cell) /\
                  ((Rgn.mem q r) /\ (Rgn.mem p (s.rep[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate wr_frame_rep (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.rep[p]) = (post.rep[p])))))
  
  predicate wr_frame_value (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.value[p]) = (post.value[p])))))
  
  predicate agree_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.value[o]) = (sr.value[pi.lor[o]])))))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       (PreRefperm.idRgn pi (sl.rep[o]) (sr.rep[pi.lor[o]])))))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_rep sl sr pi w) /\ (agree_value sl sr pi w)
end

module I
  use prelude.Prelude
  use State
end

module A
  use prelude.Prelude
  use State
  use I
  
  let test2 (s : state) (n : int) : int
  = label INIT in
      let result = ref 0 in
      let n = ref n in
      let x1 = ref 0 in
      (x1 := ([@expl:x1 := n] (! n)));
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module B
  use prelude.Prelude
  use State
  use I
  
  let test2 (s : state) (n : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let n = ref n in
      let x1 = ref 0 in
      let b = ref 0 in
      (x1 := ([@expl:x1 := 0] 0));
      (b := ([@expl:havoc b] (any int)));
      while not ((! b) = 0) do
        invariant { alloc_does_not_shrink (old s) s }
        (x1 := ([@expl:x1 := x1 + 1] ((! x1) + 1)));
        (b := ([@expl:havoc b] (any int)))
      done;
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module AB
  use prelude.Prelude
  use State
  use A
  use B
  
  let test2 (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_n : int) (r_n : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { ((l_n >= 0) /\ (r_n >= 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_n = ref l_n in
      let r_n = ref r_n in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let r_b = ref 0 in
      (l_x := ([@expl:x := n] (! l_n)));
      (r_x := ([@expl:x := 0] 0));
      assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
      (r_b := ([@expl:havoc b] (any int)));
      assume { (! r_b) = (! l_x) - (! r_x) };
      while not ((! r_b) = 0) do
        invariant { okRefperm l_s r_s pi }
        invariant { (! l_x) >= (! r_x) }
        invariant { (! r_b) = (! l_x) - (! r_x) }
        let r_q__vnt1 = ref 0 in
        let r_q__b2 = ref false in
        (r_q__vnt1 := ([@expl:havoc q__vnt1] (any int)));
        assume { (! r_q__vnt1) = (! r_b) };
        (r_q__b2 := ([@expl:havoc q__b2] (any bool)));
        assume {
          (! r_q__b2)
            <->
            (not (false /\ (false /\ false)))
            /\
            ((! r_b) <> 0)
            /\
            (true /\ true) };
        (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
        assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
        (r_b := ([@expl:havoc b] (any int)));
        assume { (! r_b) = (! l_x) - (! r_x) };
        assert { (! r_q__b2) -> (0 <= (! r_q__vnt1)) };
        assert { (! r_q__b2) -> ((! r_b) < (! r_q__vnt1)) }
      done;
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
end

module AB_biinterface
  use prelude.Prelude
  use State
  use A
  use B
end

module Impl
  use prelude.Prelude
  use State
  use I
  
  let test1 (s : state) : int
  = label INIT in
      let result = ref 0 in
      let x1 = ref 0 in
      (x1 := ([@expl:havoc x1] (any int)));
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module ConditionalLoopAlignmentExample
  use prelude.Prelude
  use State
  use Impl
  
  let m (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_x : int) (l_n : int) (r_x : int) (r_n : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_x = r_x) }
    requires { ((l_x >= 0) /\ (r_x >= 0)) }
    requires { ((l_n > 0) /\ (r_n > 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref l_x in
      let l_n = ref l_n in
      let r_x = ref r_x in
      let r_n = ref r_n in
      let l_y = ref 0 in
      let r_y = ref 0 in
      let l_z = ref 0 in
      let r_z = ref 0 in
      let l_w = ref 0 in
      let r_w = ref 0 in
      (l_y := ([@expl:y := x] (! l_x)));
      (r_y := ([@expl:y := x] (! r_x)));
      (l_z := ([@expl:z := 0] 0));
      (r_z := ([@expl:z := 0] 0));
      (l_w := ([@expl:w := 0] 0));
      (r_w := ([@expl:w := 0] 0));
      while ((! l_y) > 0)  || ((! r_y) > 0) do
        invariant { okRefperm l_s r_s pi }
        invariant { ((! l_y) = (! r_y)) }
        invariant {
          (((0 <= (! l_y)) /\ ((! l_y) <= (! l_x))) /\
             ((0 <= (! r_y)) /\ ((! r_y) <= (! r_x)))) }
        invariant {
          (((0 <= (! l_w)) /\ ((! l_w) < (! l_n))) /\
             ((0 <= (! r_w)) /\ ((! r_w) < (! r_n)))) }
        invariant { ((! l_z) = (! r_z)) }
        invariant {
          [@expl:alignment condition]
          ((((! l_y) > 0) /\ ((! l_w) <> 0)) \/
             ((((! r_y) > 0) /\ ((! r_w) <> 0)) \/
                ((((! l_y) > 0) /\ ((! r_y) > 0)) \/
                   ((not ((! l_y) > 0)) /\ (not ((! r_y) > 0)))))) }
        if ([@expl:Left step] (((! l_y) > 0)  && (not ((! l_w) = 0)))) then
          ((if ((! l_w) = 0) then
              ((l_z := ([@expl:havoc z] (any int)));
               (l_y := ([@expl:y := y - 1] ((! l_y) - 1))))
            else ());
           (l_w := ([@expl:w := (w + 1) mod n] (mod ((! l_w) + 1) (! l_n)))))
        else
          (if ([@expl:Right step] (((! r_y) > 0)  && (not ((! r_w) = 0)))) then
             (let q__vnt3 = ref 0 in
              let q__b4 = ref false in
              (q__vnt3 := ([@expl:havoc q__vnt3] (any int)));
              (q__b4 := ([@expl:havoc q__b4] (any bool)));
              (if ((! r_w) = 0) then
                 ((r_z := ([@expl:havoc z] (any int)));
                  (r_y := ([@expl:y := y - 1] ((! r_y) - 1))))
               else ());
              (r_w := ([@expl:w := (w + 1) mod n] (mod ((! r_w) + 1) (! r_n)))))
           else
             (let r_q__vnt3 = ref 0 in
              let r_q__b4 = ref false in
              (r_q__vnt3 := ([@expl:havoc q__vnt3] (any int)));
              assume { (! r_q__vnt3) = (mod ((! r_n) - (! r_w)) (! r_n)) };
              (r_q__b4 := ([@expl:havoc q__b4] (any bool)));
              assume {
                (! r_q__b4)
                  <->
                  (not (((! l_y) > 0) /\ ((! l_w) <> 0)))
                  /\
                  ((! r_y) > 0)
                  /\
                  ((! r_w) <> 0) };
              ([@expl:guard agreement]
               assert { (((! l_w) = 0) = ((! r_w) = 0)) });
              (if ((! l_w) = 0) then
                 ((l_z := ([@expl:havoc z] (any int)));
                  assert { exists r_z : int. ((! l_z) = r_z) };
                  (r_z := ([@expl:havoc z] (any int)));
                  assume { ((! l_z) = (! r_z)) };
                  (l_y := ([@expl:y := y - 1] ((! l_y) - 1)));
                  (r_y := ([@expl:y := y - 1] ((! r_y) - 1))))
               else ());
              (l_w := ([@expl:w := (w + 1) mod n] (mod ((! l_w) + 1) (! l_n))));
              (r_w := ([@expl:w := (w + 1) mod n] (mod ((! r_w) + 1) (! r_n))));
              assert { (! r_q__b4) -> (0 <= (! r_q__vnt3)) };
              assert {
                (! r_q__b4)
                  ->
                  ((mod ((! r_n) - (! r_w)) (! r_n)) < (! r_q__vnt3)) }))
      done;
      (l_result := ([@expl:result := z] (! l_z)));
      (r_result := ([@expl:result := z] (! r_z)));
      ((! l_result), (! r_result))
end

module ConditionalLoopAlignmentExample_biinterface
  use prelude.Prelude
  use State
  use Impl
end

module EMPTY
  use prelude.Prelude
  use State
end

module E
  use prelude.Prelude
  use State
  use EMPTY
  
  let noninterference2 (s : state) (h : int) (l : int) : int
  = label INIT in
      let result = ref 0 in
      let h = ref h in
      let l = ref l in
      let o = ref 0 in
      let x1 = ref 0 in
      (if ((! h) > (! l)) then
         ((x1 := ([@expl:havoc x1] (any int)));
          (o := ([@expl:o := l + x1] ((! l) + (! x1)))))
       else
         ((x1 := ([@expl:havoc x1] (any int)));
          (if ((! x1) > (! l)) then (o := ([@expl:o := x1] (! x1)))
           else (o := ([@expl:o := l] (! l))))));
      (result := ([@expl:result := o] (! o)));
      (! result)
end

module EREL
  use prelude.Prelude
  use State
  use E
  
  let noninterference2 (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_h : int) (l_l : int) (r_h : int) (r_l : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_l = r_l) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_h = ref l_h in
      let l_l = ref l_l in
      let r_h = ref r_h in
      let r_l = ref r_l in
      let l_o = ref 0 in
      let r_o = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (if (((! l_h) > (! l_l))  && ((! r_h) > (! r_l))) then
         ((l_x := ([@expl:havoc x] (any int)));
          assert { exists r_x : int. ((! l_x) = r_x) };
          (r_x := ([@expl:havoc x] (any int)));
          assume { ((! l_x) = (! r_x)) };
          (l_o := ([@expl:o := l + x] ((! l_l) + (! l_x))));
          (r_o := ([@expl:o := l + x] ((! r_l) + (! r_x)))))
       else
         (if (((! l_h) > (! l_l))  && (not ((! r_h) > (! r_l)))) then
            ((l_x := ([@expl:havoc x] (any int)));
             (l_o := ([@expl:o := l + x] ((! l_l) + (! l_x))));
             (r_x := ([@expl:havoc x] (any int)));
             (if ((! r_x) > (! r_l)) then (r_o := ([@expl:o := x] (! r_x)))
              else (r_o := ([@expl:o := l] (! r_l)))))
          else
            (if ((not ((! l_h) > (! l_l)))  && ((! r_h) > (! r_l))) then
               ((l_x := ([@expl:havoc x] (any int)));
                (if ((! l_x) > (! l_l)) then (l_o := ([@expl:o := x] (! l_x)))
                 else (l_o := ([@expl:o := l] (! l_l))));
                assert { exists r_x : int. ((! l_x) = r_x) };
                (r_x := ([@expl:havoc x] (any int)));
                assume { ((! l_x) = (! r_x)) };
                (r_o := ([@expl:o := l + x] ((! r_l) + (! r_x)))))
             else
               ((l_x := ([@expl:havoc x] (any int)));
                (if ((! l_x) > (! l_l)) then (l_o := ([@expl:o := x] (! l_x)))
                 else (l_o := ([@expl:o := l] (! l_l))));
                (r_x := ([@expl:havoc x] (any int)));
                (if ((! r_x) > (! r_l)) then (r_o := ([@expl:o := x] (! r_x)))
                 else (r_o := ([@expl:o := l] (! r_l))))))));
      (l_result := ([@expl:result := o] (! l_o)));
      (r_result := ([@expl:result := o] (! r_o)));
      ((! l_result), (! r_result))
end

module EREL_biinterface
  use prelude.Prelude
  use State
  use E
end

module ImplREL
  use prelude.Prelude
  use State
  use Impl
  
  let test1 (l_s : state) (r_s : state) (pi : PreRefperm.t) : (int, int)
    requires { okRefperm l_s r_s pi }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (l_x := ([@expl:havoc x] (any int)));
      assert { exists r_x : int. ((! l_x) = r_x) };
      (r_x := ([@expl:havoc x] (any int)));
      assume { ((! l_x) = (! r_x)) };
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
  
  predicate sameParity (l_s: state) (r_s: state) (pi1: PreRefperm.t) (l_n: int) (r_n: int) =
    (okRefperm l_s r_s pi1) -> ((mod l_n 2) = (mod r_n 2))
  
  let test1_again (l_s : state) (r_s : state) (pi2 : PreRefperm.t) : 
    (int, int)
    requires { okRefperm l_s r_s pi2 }
    ensures { okRefperm l_s r_s pi2 }
    
    ensures { match result with
              | (l_result, r_result) ->
                  sameParity l_s r_s pi2 l_result r_result
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (l_x := ([@expl:havoc x] (any int)));
      assert { exists r_x : int. sameParity l_s r_s pi2 (! l_x) r_x };
      (r_x := ([@expl:havoc x] (any int)));
      assume { sameParity l_s r_s pi2 (! l_x) (! r_x) };
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
  
  let test1_again2 (l_s : state) (r_s : state) (pi : PreRefperm.t) : 
    (unit, unit)
    requires { okRefperm l_s r_s pi }
    ensures { okRefperm l_s r_s pi }
    
    ensures { (l_s.x = r_s.x) /\ (l_s.y = r_s.y) }
    
    ensures { match result with
              | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ()))
              end }
  = label INIT in
      let r_result = ref () in
      let l_result = ref () in
      (set_x l_s ([@expl:havoc x] (any int)));
      (set_y l_s ([@expl:havoc y] (any int)));
      assert { exists r_y : int. (l_s.y = r_y) };
      (set_y r_s ([@expl:havoc y] (any int)));
      assume { (l_s.y = r_s.y) };
      assert { exists r_x : int. (l_s.x = r_x) /\ (l_s.y = r_s.y) };
      (set_x r_s ([@expl:havoc x] (any int)));
      assume { (l_s.x = r_s.x) /\ (l_s.y = r_s.y) };
      ((! l_result), (! r_result))
  
  let testing (l_s : state) (r_s : state) (pi3 : PreRefperm.t) (l_p : reference) (r_r : rgn) : 
    (unit, reference)
    requires { hasCellType l_s l_p }
    requires { (l_p <> null) }
    requires { okRefperm l_s r_s pi3 }
    requires { exists r_q : reference.
                 (isAllocated r_s r_q)
                   /\
                   (hasCellType r_s r_q)
                   /\
                   (Rgn.mem r_q r_r)
                   /\
                   (PreRefperm.idRef pi3 l_p r_q)
    }
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { okRefperm l_s r_s pi3 }
    
    ensures { match result with
              | (l_result, r_result) ->
                  (Rgn.mem r_result r_r) /\ (PreRefperm.idRef pi3 l_p r_result)
              end }
  = label INIT in
      let r_result = ref null in
      let l_result = ref () in
      let l_p = ref l_p in
      let r_r = ref r_r in
      let r_q = ref null in
      assert {
        exists r_q : reference.
          (hasCellType r_s r_q)
            /\
            (Rgn.mem r_q (! r_r))
            /\
            (PreRefperm.idRef pi3 (! l_p) r_q) };
      (r_q := ([@expl:havoc q] (any reference)));
      assume {
        (Rgn.mem (! r_q) (! r_r)) /\ (PreRefperm.idRef pi3 (! l_p) (! r_q)) };
      (r_result := ([@expl:result := q] (! r_q)));
      ((! l_result), (! r_result))
end

module ImplREL_biinterface
  use prelude.Prelude
  use State
  use Impl
  
  predicate sameParity (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_n: int) (r_n: int) =
    (okRefperm l_s r_s pi) -> ((mod l_n 2) = (mod r_n 2))
end

module MAIN
  use prelude.Prelude
  use State
end

module U
  use prelude.Prelude
  use State
  use EMPTY
  
  let noninterference (s : state) (high : int) (low : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let high = ref high in
      let low = ref low in
      let x1 = ref 0 in
      let b = ref 0 in
      (if (not ((! high) = 0)) then
         ((x1 := ([@expl:havoc x1] (any int)));
          (if ((! x1) >= (! low)) then ()
           else
             while true do
               invariant { alloc_does_not_shrink (old s) s }
               ()
             done))
       else
         ((x1 := ([@expl:x1 := low] (! low)));
          (b := ([@expl:havoc b] (any int)));
          while not ((! b) = 0) do
            invariant { alloc_does_not_shrink (old s) s }
            (x1 := ([@expl:x1 := x1 + 1] ((! x1) + 1)));
            (b := ([@expl:havoc b] (any int)))
          done));
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module UREL
  use prelude.Prelude
  use State
  use U
  
  let noninterference (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_high : int) (l_low : int) (r_high : int) (r_low : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_low = r_low) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_high = ref l_high in
      let l_low = ref l_low in
      let r_high = ref r_high in
      let r_low = ref r_low in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let l_b = ref 0 in
      let r_b = ref 0 in
      (if ((not ((! l_high) = 0))  && (not ((! r_high) = 0))) then
         ((l_x := ([@expl:havoc x] (any int)));
          assert { exists r_x : int. ((! l_x) = r_x) };
          (r_x := ([@expl:havoc x] (any int)));
          assume { ((! l_x) = (! r_x)) };
          ([@expl:guard agreement]
           assert { (((! l_x) >= (! l_low)) = ((! r_x) >= (! r_low))) });
          (if ((! l_x) >= (! l_low)) then ()
           else
             (while true do
                invariant { alloc_does_not_shrink (old l_s) l_s }
                ()
              done;
              assert { (false /\ false) };
              while true do
                invariant { alloc_does_not_shrink (old r_s) r_s }
                let q__vnt8 = ref 0 in
                (q__vnt8 := ([@expl:q__vnt8 := 0] 0));
                assert { 0 <= (! q__vnt8) };
                assert { 0 < (! q__vnt8) }
              done)))
       else
         (if ((not ((! l_high) = 0))  && (not (not ((! r_high) = 0)))) then
            ((l_x := ([@expl:havoc x] (any int)));
             (if ((! l_x) >= (! l_low)) then ()
              else
                while true do
                  invariant { alloc_does_not_shrink (old l_s) l_s }
                  ()
                done);
             assert { (! l_x) >= (! l_low) };
             (r_x := ([@expl:x := low] (! r_low)));
             assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
             (r_b := ([@expl:havoc b] (any int)));
             assume { (! r_b) = (! l_x) - (! r_x) };
             while not ((! r_b) = 0) do
               invariant { okRefperm l_s r_s pi }
               invariant { (! r_b) >= 0 }
               invariant { (! l_x) >= (! r_x) }
               invariant { (! r_b) = (! l_x) - (! r_x) }
               let r_q__vnt6 = ref 0 in
               let r_q__b7 = ref false in
               (r_q__vnt6 := ([@expl:havoc q__vnt6] (any int)));
               assume { (! r_q__vnt6) = (! r_b) };
               (r_q__b7 := ([@expl:havoc q__b7] (any bool)));
               assume {
                 (! r_q__b7)
                   <->
                   (not (false /\ (false /\ false)))
                   /\
                   ((! r_b) <> 0)
                   /\
                   (true /\ true) };
               (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
               assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
               (r_b := ([@expl:havoc b] (any int)));
               assume { (! r_b) = (! l_x) - (! r_x) };
               assert { (! r_q__b7) -> (0 <= (! r_q__vnt6)) };
               assert { (! r_q__b7) -> ((! r_b) < (! r_q__vnt6)) }
             done)
          else
            (if ((not (not ((! l_high) = 0)))  && (not ((! r_high) = 0))) then
               ((l_x := ([@expl:x := low] (! l_low)));
                (l_b := ([@expl:havoc b] (any int)));
                while not ((! l_b) = 0) do
                  invariant { okRefperm l_s r_s pi }
                  invariant { (! l_x) >= (! l_low) }
                  (l_x := ([@expl:x := x + 1] ((! l_x) + 1)));
                  (l_b := ([@expl:havoc b] (any int)))
                done;
                assert { exists r_x : int. ((! l_x) = r_x) };
                (r_x := ([@expl:havoc x] (any int)));
                assume { ((! l_x) = (! r_x)) };
                (if ((! r_x) >= (! r_low)) then ()
                 else
                   (assert { false };
                    while true do
                      invariant { alloc_does_not_shrink (old r_s) r_s }
                      let q__vnt5 = ref 0 in
                      (q__vnt5 := ([@expl:q__vnt5 := 0] 0));
                      assert { 0 <= (! q__vnt5) };
                      assert { 0 < (! q__vnt5) }
                    done)))
             else
               ((l_x := ([@expl:x := low] (! l_low)));
                (r_x := ([@expl:x := low] (! r_low)));
                (l_b := ([@expl:havoc b] (any int)));
                assert { exists r_b : int. ((! l_b) = r_b) };
                (r_b := ([@expl:havoc b] (any int)));
                assume { ((! l_b) = (! r_b)) };
                while not ((! l_b) = 0) do
                  invariant { okRefperm l_s r_s pi }
                  invariant { ((! l_b) = (! r_b)) /\ ((! l_x) = (! r_x)) }
                  invariant {
                    [@expl:lockstep] (((! l_b) <> 0) = ((! r_b) <> 0)) }
                  (l_x := ([@expl:x := x + 1] ((! l_x) + 1)));
                  (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
                  (l_b := ([@expl:havoc b] (any int)));
                  assert { exists r_b : int. ((! l_b) = r_b) };
                  (r_b := ([@expl:havoc b] (any int)));
                  assume { ((! l_b) = (! r_b)) }
                done))));
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
end

module UREL_biinterface
  use prelude.Prelude
  use State
  use U
end

