module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = {  }
  
  type state = private { mutable ghost alloct : M.t reftype }
    invariant { not (M.mem null alloct) }
    by { alloct = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn)
end

module EMPTY
  use prelude.Prelude
  use State
end

module E
  use prelude.Prelude
  use State
  use EMPTY
  
  let noninterference2 (s : state) (h : int) (l : int) : int
  = label INIT in
      let result = ref 0 in
      let h = ref h in
      let l = ref l in
      let o = ref 0 in
      let x = ref 0 in
      (if ((! h) > (! l)) then
         ((x := ([@expl:havoc x] (any int)));
          (o := ([@expl:o := l + x] ((! l) + (! x)))))
       else
         ((x := ([@expl:havoc x] (any int)));
          (if ((! x) > (! l)) then (o := ([@expl:o := x] (! x)))
           else (o := ([@expl:o := l] (! l))))));
      (result := ([@expl:result := o] (! o)));
      (! result)
end

module EREL
  use prelude.Prelude
  use State
  use E
  
  let noninterference2 (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_h : int) (l_l : int) (r_h : int) (r_l : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_l = r_l) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_h = ref l_h in
      let l_l = ref l_l in
      let r_h = ref r_h in
      let r_l = ref r_l in
      let l_o = ref 0 in
      let r_o = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (if (((! l_h) > (! l_l))  && ((! r_h) > (! r_l))) then
         ((l_x := ([@expl:havoc x] (any int)));
          assert { exists r_x : int. ((! l_x) = r_x) };
          (r_x := ([@expl:havoc x] (any int)));
          assume { ((! l_x) = (! r_x)) };
          (l_o := ([@expl:o := l + x] ((! l_l) + (! l_x))));
          (r_o := ([@expl:o := l + x] ((! r_l) + (! r_x)))))
       else
         (if (((! l_h) > (! l_l))  && (not ((! r_h) > (! r_l)))) then
            ((l_x := ([@expl:havoc x] (any int)));
             (l_o := ([@expl:o := l + x] ((! l_l) + (! l_x))));
             (r_x := ([@expl:havoc x] (any int)));
             (if ((! r_x) > (! r_l)) then (r_o := ([@expl:o := x] (! r_x)))
              else (r_o := ([@expl:o := l] (! r_l)))))
          else
            (if ((not ((! l_h) > (! l_l)))  && ((! r_h) > (! r_l))) then
               ((l_x := ([@expl:havoc x] (any int)));
                (if ((! l_x) > (! l_l)) then (l_o := ([@expl:o := x] (! l_x)))
                 else (l_o := ([@expl:o := l] (! l_l))));
                assert { exists r_x : int. ((! l_x) = r_x) };
                (r_x := ([@expl:havoc x] (any int)));
                assume { ((! l_x) = (! r_x)) };
                (r_o := ([@expl:o := l + x] ((! r_l) + (! r_x)))))
             else
               ((l_x := ([@expl:havoc x] (any int)));
                (if ((! l_x) > (! l_l)) then (l_o := ([@expl:o := x] (! l_x)))
                 else (l_o := ([@expl:o := l] (! l_l))));
                (r_x := ([@expl:havoc x] (any int)));
                (if ((! r_x) > (! r_l)) then (r_o := ([@expl:o := x] (! r_x)))
                 else (r_o := ([@expl:o := l] (! r_l))))))));
      (l_result := ([@expl:result := o] (! l_o)));
      (r_result := ([@expl:result := o] (! r_o)));
      ((! l_result), (! r_result))
end

module EREL_biinterface
  use prelude.Prelude
  use State
  use E
end

module MAIN
  use prelude.Prelude
  use State
end

