module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
      | Cell
  
  type state = private {
              mutable ghost alloct : M.t reftype;
              mutable sum : M.t int;
              mutable b : M.t int
              }
    invariant { not (M.mem null alloct) }
    invariant {
      forall p : reference.
        ((M.mem p alloct) ->
           (((alloct[p]) = Cell) -> ((M.mem p sum) /\ (M.mem p b)))) }
    invariant { not (M.mem null sum) }
    invariant { not (M.mem null b) }
    by { alloct = (().M.create) ; sum = (().M.create) ; b = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate hasCellType (s: state) (p: reference) =
    ((p = null) \/ ((M.mem p s.alloct) /\ ((s.alloct[p]) = Cell)))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct, s.sum, s.b }
    ensures { not (M.mem result (old s.alloct)) }
    
    ensures { (s.alloct = (M.add result Cell (old s.alloct))) }
    
    ensures { forall p : reference.
                ((M.mem p (old s.alloct)) ->
                   ((M.mem p s.alloct) /\
                      (((old s.alloct)[p]) = (s.alloct[p])))) }
    
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { (s.sum = (M.add result 0 (old s.sum))) }
    
    ensures { (s.b = (M.add result 0 (old s.b))) }
  
  val set_sum (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.sum }
    ensures { (s.sum = (M.add o v (old s.sum))) }
  
  val set_b (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.b }
    ensures { (s.b = (M.add o v (old s.b))) }
  
  function img_sum : state -> (rgn -> rgn)
  
  axiom img_sum_ax: forall s : state, r : rgn. ((img_sum s r) = emptyRgn)
  
  function img_b : state -> (rgn -> rgn)
  
  axiom img_b_ax: forall s : state, r : rgn. ((img_b s r) = emptyRgn)
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate wr_frame_sum (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.sum[p]) = (post.sum[p])))))
  
  predicate wr_frame_b (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.b[p]) = (post.b[p])))))
  
  predicate agree_sum (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.sum[o]) = (sr.sum[pi.lor[o]])))))))))
  
  predicate agree_b (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.b[o]) = (sr.b[pi.lor[o]])))))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_sum sl sr pi w) /\ (agree_b sl sr pi w)
end

module I
  use prelude.Prelude
  use State
  
  val itzhaky (s: state) (a: A.array int) (n: int) : reference
    writes { s.alloct }
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { alloc_does_not_shrink (old s) s }
end

module A
  use prelude.Prelude
  use State
  use I
  
  val itzhaky (s: state) (a: A.array int) (n: int) : reference
    writes { s.alloct }
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { alloc_does_not_shrink (old s) s }
end

module FREL
  use prelude.Prelude
  use State
  use A
  
  let itzhaky (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_a : 
    A.array
      int) (l_n : int) (r_a : A.array int) (r_n : int) : (reference, reference)
    requires { okRefperm l_s r_s pi }
    requires { (l_a = r_a) /\ (l_n = r_n) }
    writes { l_s.b, l_s.sum, r_s.b, r_s.sum }
    ensures { match result with
              | (l_result, _) -> hasCellType l_s l_result
              end }
    
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { [@expl:wr {}`sum] (wr_frame_sum (old l_s) l_s emptyRgn) }
    
    ensures { [@expl:wr {}`b] (wr_frame_b (old l_s) l_s emptyRgn) }
    
    ensures { [@expl:wr {}`sum] (wr_frame_sum (old r_s) r_s emptyRgn) }
    
    ensures { [@expl:wr {}`b] (wr_frame_b (old r_s) r_s emptyRgn) }
    
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) ->
                  (let x = r_s.b[r_result] in
                   x
                   <
                   0)
                    /\
                    (let l_sum = l_s.sum[l_result] in
                     let r_sum = r_s.sum[r_result] in
                     (l_sum = r_sum))
              end }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((not (l_result = null)) /\ (not (r_result = null)))
              end }
    diverges
  = label INIT in
      let r_result = ref null in
      let l_result = ref null in
      let l_a = ref l_a in
      let l_n = ref l_n in
      let r_a = ref r_a in
      let r_n = ref r_n in
      let l_i = ref 0 in
      let r_i = ref 0 in
      let l_y = ref 0 in
      let r_y = ref 0 in
      let l_b = ref 0 in
      let r_b = ref 0 in
      let l_sum = ref 0 in
      let r_sum = ref 0 in
      let l_temp = ref 0 in
      let r_temp = ref 0 in
      (l_sum := ([@expl:sum := 0] 0));
      (r_sum := ([@expl:sum := 0] 0));
      (l_b := ([@expl:havoc b] (any int)));
      assert { exists r_b : int. (! l_b) < 0 };
      (r_b := ([@expl:havoc b] (any int)));
      assume { (! l_b) < 0 };
      (if (((! l_b) > 0)  && ((! r_b) > 0)) then
         ((l_i := ([@expl:i := 0] 0));
          (r_i := ([@expl:i := 0] 0));
          while ((! l_i) < ((! l_n) - 1)) do
            invariant {
              [@expl:locals type invariant left] (hasCellType l_s (! l_result)) }
            invariant {
              [@expl:locals type invariant right]
              (hasCellType r_s (! r_result)) }
            invariant { okRefperm l_s r_s pi }
            (l_temp := ([@expl:temp := get(a,i)] (A.get (! l_a) (! l_i))));
            (l_sum := ([@expl:sum := sum + temp] ((! l_sum) + (! l_temp))));
            (l_i := ([@expl:i := i + 1] ((! l_i) + 1)))
          done;
          while ((! r_i) < ((! r_n) - 1)) do
            invariant {
              [@expl:locals type invariant left] (hasCellType l_s (! l_result)) }
            invariant {
              [@expl:locals type invariant right]
              (hasCellType r_s (! r_result)) }
            invariant { okRefperm l_s r_s pi }
            let r_q__vnt3 = ref 0 in
            let r_q__b4 = ref false in
            (r_q__vnt3 := ([@expl:havoc q__vnt3] (any int)));
            assume { (! r_q__vnt3) = (! r_i) };
            (r_q__b4 := ([@expl:havoc q__b4] (any bool)));
            assume {
              (! r_q__b4)
                <->
                (not (false /\ (false /\ false)))
                /\
                ((! r_i) < (! r_n) - 1)
                /\
                (true /\ true) };
            (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
            (r_sum := ([@expl:sum := sum + temp] ((! r_sum) + (! r_temp))));
            (r_i := ([@expl:i := i + 1] ((! r_i) + 1)));
            assert { (! r_q__b4) -> (0 <= (! r_q__vnt3)) };
            assert { (! r_q__b4) -> ((! r_i) < (! r_q__vnt3)) }
          done)
       else
         (if (((! l_b) > 0)  && (not ((! r_b) > 0))) then
            ((l_i := ([@expl:i := 0] 0));
             (r_i := ([@expl:i := 1] 1));
             while ((! l_i) < ((! l_n) - 1)) do
               invariant {
                 [@expl:locals type invariant left]
                 (hasCellType l_s (! l_result)) }
               invariant {
                 [@expl:locals type invariant right]
                 (hasCellType r_s (! r_result)) }
               invariant { okRefperm l_s r_s pi }
               invariant { ((! l_i) < (! l_n) - 1) <-> ((! r_i) < (! r_n)) }
               invariant { (((! l_i) + 1) = (! r_i)) }
               invariant { ((! l_sum) = (! r_sum)) }
               invariant {
                 [@expl:lockstep]
                 (((! l_i) < (! l_n) - 1) = ((! r_i) < (! r_n))) }
               (l_temp := ([@expl:temp := get(a,i)] (A.get (! l_a) (! l_i))));
               (l_sum := ([@expl:sum := sum + temp] ((! l_sum) + (! l_temp))));
               (l_i := ([@expl:i := i + 1] ((! l_i) + 1)));
               (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
               assert {
                 exists r_y : int.
                   r_y
                   =
                   ((0 - (! r_temp)) - (! r_sum))
                   +
                   (! l_sum) };
               (r_y := ([@expl:havoc y] (any int)));
               assume { (! r_y) = ((0 - (! r_temp)) - (! r_sum)) + (! l_sum) };
               (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
               (r_sum
                  := ([@expl:sum := sum + temp + y]
                      (((! r_sum) + (! r_temp)) + (! r_y))));
               (r_i := ([@expl:i := i + 1] ((! r_i) + 1)))
             done)
          else
            (if ((not ((! l_b) > 0))  && ((! r_b) > 0)) then
               ((l_i := ([@expl:i := 1] 1));
                (r_i := ([@expl:i := 0] 0));
                while ((! l_i) < (! l_n)) do
                  invariant {
                    [@expl:locals type invariant left]
                    (hasCellType l_s (! l_result)) }
                  invariant {
                    [@expl:locals type invariant right]
                    (hasCellType r_s (! r_result)) }
                  invariant { okRefperm l_s r_s pi }
                  (l_y := ([@expl:havoc y] (any int)));
                  (l_temp := ([@expl:temp := get(a,i)] (A.get (! l_a) (! l_i))));
                  (l_sum
                     := ([@expl:sum := sum + temp + y]
                         (((! l_sum) + (! l_temp)) + (! l_y))));
                  (l_i := ([@expl:i := i + 1] ((! l_i) + 1)))
                done;
                while ((! r_i) < ((! r_n) - 1)) do
                  invariant {
                    [@expl:locals type invariant left]
                    (hasCellType l_s (! l_result)) }
                  invariant {
                    [@expl:locals type invariant right]
                    (hasCellType r_s (! r_result)) }
                  invariant { okRefperm l_s r_s pi }
                  let r_q__vnt1 = ref 0 in
                  let r_q__b2 = ref false in
                  (r_q__vnt1 := ([@expl:havoc q__vnt1] (any int)));
                  assume { (! r_q__vnt1) = (! r_i) };
                  (r_q__b2 := ([@expl:havoc q__b2] (any bool)));
                  assume {
                    (! r_q__b2)
                      <->
                      (not (false /\ (false /\ false)))
                      /\
                      ((! r_i) < (! r_n) - 1)
                      /\
                      (true /\ true) };
                  (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
                  (r_sum
                     := ([@expl:sum := sum + temp] ((! r_sum) + (! r_temp))));
                  (r_i := ([@expl:i := i + 1] ((! r_i) + 1)));
                  assert { (! r_q__b2) -> (0 <= (! r_q__vnt1)) };
                  assert { (! r_q__b2) -> ((! r_i) < (! r_q__vnt1)) }
                done)
             else
               ((l_i := ([@expl:i := 1] 1));
                (r_i := ([@expl:i := 1] 1));
                while ((! l_i) < (! l_n)) do
                  invariant {
                    [@expl:locals type invariant left]
                    (hasCellType l_s (! l_result)) }
                  invariant {
                    [@expl:locals type invariant right]
                    (hasCellType r_s (! r_result)) }
                  invariant { okRefperm l_s r_s pi }
                  invariant { ((! l_i) < (! l_n)) <-> ((! r_i) < (! r_n)) }
                  invariant { ((! l_i) = (! r_i)) }
                  invariant { ((! l_sum) = (! r_sum)) }
                  invariant {
                    [@expl:lockstep]
                    (((! l_i) < (! l_n)) = ((! r_i) < (! r_n))) }
                  (l_y := ([@expl:havoc y] (any int)));
                  (l_temp := ([@expl:temp := get(a,i)] (A.get (! l_a) (! l_i))));
                  (l_sum
                     := ([@expl:sum := sum + temp + y]
                         (((! l_sum) + (! l_temp)) + (! l_y))));
                  (l_i := ([@expl:i := i + 1] ((! l_i) + 1)));
                  (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
                  assert {
                    exists r_y : int.
                      r_y
                      =
                      ((0 - (! r_temp)) - (! r_sum))
                      +
                      (! l_sum) };
                  (r_y := ([@expl:havoc y] (any int)));
                  assume {
                    (! r_y)
                    =
                    ((0 - (! r_temp)) - (! r_sum))
                    +
                    (! l_sum) };
                  (r_temp := ([@expl:temp := get(a,i)] (A.get (! r_a) (! r_i))));
                  (r_sum
                     := ([@expl:sum := sum + temp + y]
                         (((! r_sum) + (! r_temp)) + (! r_y))));
                  (r_i := ([@expl:i := i + 1] ((! r_i) + 1)))
                done))));
      (l_result := ([@expl:result := new Cell] (l_s.mk_Cell)));
      (r_result := ([@expl:result := new Cell] (r_s.mk_Cell)));
      ([@expl:result.sum := sum] (set_sum l_s (! l_result) (! l_sum)));
      ([@expl:result.sum := sum] (set_sum r_s (! r_result) (! r_sum)));
      ([@expl:result.b := b] (set_b l_s (! l_result) (! l_b)));
      ([@expl:result.b := b] (set_b r_s (! r_result) (! r_b)));
      ((! l_result), (! r_result))
end

module FREL_biinterface
  use prelude.Prelude
  use State
  use A
  
  val itzhaky (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_a: A.array int) (l_n: int) (r_a: 
    A.array
      int) (r_n: int) : (reference, reference)
    requires { okRefperm l_s r_s pi }
    requires { (l_a = r_a) /\ (l_n = r_n) }
    ensures { match result with
              | (l_result, _) -> hasCellType l_s l_result
              end }
    
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) ->
                  (let x = r_s.b[r_result] in
                   x
                   <
                   0)
                    /\
                    (let l_sum = l_s.sum[l_result] in
                     let r_sum = r_s.sum[r_result] in
                     (l_sum = r_sum))
              end }
    
    ensures { match result with
              | (l_result, r_result) ->
                  ((not (l_result = null)) /\ (not (r_result = null)))
              end }
end

module MAIN
  use prelude.Prelude
  use State
end

