module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  use stack_theory.Stack_theory
  
  type reftype = 
    | Cell
    | CellArray
    | Node
    | Stack
  
  type heap = {
    mutable head : M.t reference ;
    mutable ghost rep : M.t rgn ;
    mutable size : M.t int ;
    mutable ghost contents : M.t intList ;
    mutable top : M.t int ;
    mutable arr : M.t reference ;
    mutable car : M.t reference ;
    mutable cdr : M.t reference ;
    mutable slots : M.t (A.array reference) ;
    mutable length : M.t int ;
    mutable cell_value : M.t int ;
    mutable ghost cell_rep : M.t rgn
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable maxSize : int ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Cell) ->
           (((p \: heap.cell_value) /\ (p \: heap.cell_rep)) /\
              (forall q: reference. (Rgn.mem q (heap.cell_rep[p])) -> ((q = null) \/ (q \: alloct))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = CellArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\
              (((heap.length[p]) >= 0) /\
                 (((heap.length[p]) = (A.length (heap.slots[p]))) /\
                    (let arr1 = heap.slots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr1)) -> (let v = A.get arr1 i in
                                                    (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Cell))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.car) /\ (p \: heap.cdr)) /\
              ((((heap.car[p]) = null) \/ (((heap.car[p]) \: alloct) /\ ((alloct[heap.car[p]]) = Cell))) /\
                 (((heap.cdr[p]) = null) \/ (((heap.cdr[p]) \: alloct) /\ ((alloct[heap.cdr[p]]) = Node)))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Stack) ->
           (((p \: heap.head) /\
               ((p \: heap.rep) /\ ((p \: heap.size) /\ ((p \: heap.contents) /\ ((p \: heap.top) /\ (p \: heap.arr)))))) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 ((((heap.arr[p]) = null) \/ (((heap.arr[p]) \: alloct) /\ ((alloct[heap.arr[p]]) = CellArray))) /\
                    (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct))))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  maxSize = (any int) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasCellType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Cell))
  
  predicate hasCellArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = CellArray))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasStackType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Stack))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Cell (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { s.heap.cell_value = (M.add result 0 (old s.heap.cell_value)) }
    ensures { s.heap.cell_rep = (M.add result emptyRgn (old s.heap.cell_rep)) }
  
  val mk_CellArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result CellArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasCellArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 null) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.car }
    writes { s.heap.cdr }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.car = (M.add result null (old s.heap.car)) }
    ensures { s.heap.cdr = (M.add result null (old s.heap.cdr)) }
  
  val mk_Stack (s: state) : reference
    writes { s.alloct }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Stack (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasStackType s result }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.size = (M.add result 0 (old s.heap.size)) }
    ensures { s.heap.contents = (M.add result nil (old s.heap.contents)) }
    ensures { s.heap.top = (M.add result 0 (old s.heap.top)) }
    ensures { s.heap.arr = (M.add result null (old s.heap.arr)) }
  
  function img_top : state -> (rgn -> rgn)
  
  axiom img_top_ax : forall s: state, r: rgn. (img_top s r) = emptyRgn
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn, p: reference.
                         (Rgn.mem p (img_slots s r)) <->
                           (((p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Cell))) /\
                              (exists arr2: reference.
                                 (arr2 \: s.alloct) /\
                                   (((s.alloct[arr2]) = CellArray) /\
                                      ((Rgn.mem arr2 r) /\
                                         (exists i: int.
                                            (0 <= i) /\ ((i < (A.length (s.heap.slots[arr2]))) /\ ((A.get (s.heap.slots[arr2]) i) = p)))))))
  
  function img_size : state -> (rgn -> rgn)
  
  axiom img_size_ax : forall s: state, r: rgn. (img_size s r) = emptyRgn
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  function img_contents : state -> (rgn -> rgn)
  
  axiom img_contents_ax : forall s: state, r: rgn. (img_contents s r) = emptyRgn
  
  function img_cell_value : state -> (rgn -> rgn)
  
  axiom img_cell_value_ax : forall s: state, r: rgn. (img_cell_value s r) = emptyRgn
  
  function img_cell_rep : state -> (rgn -> rgn)
  
  axiom img_cell_rep_ax : forall s: state, r: rgn, p: reference.
                            (Rgn.mem p (img_cell_rep s r)) <->
                              (exists q: reference.
                                 (q \: s.alloct) /\ (((s.alloct[q]) = Cell) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.cell_rep[q])))))
  
  function img_cdr : state -> (rgn -> rgn)
  
  axiom img_cdr_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_cdr s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.cdr[q])))))
  
  function img_car : state -> (rgn -> rgn)
  
  axiom img_car_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_car s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.car[q])))))
  
  function img_arr : state -> (rgn -> rgn)
  
  axiom img_arr_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_arr s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (p = (s.heap.arr[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. (p \: pre.alloct) -> ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_cell_value_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = Cell) -> ((not (Rgn.mem p r)) -> ((pre.heap.cell_value[p]) = (post.heap.cell_value[p]))))
  
  predicate wrs_to_cell_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Cell) -> ((not (Rgn.mem p r)) -> ((pre.heap.cell_rep[p]) = (post.heap.cell_rep[p]))))
  
  predicate wrs_to_slots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = CellArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.slots[p]) = (post.heap.slots[p]))))
  
  predicate wrs_to_length_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = CellArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.length[p]) = (post.heap.length[p]))))
  
  predicate wrs_to_car_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.car[p]) = (post.heap.car[p]))))
  
  predicate wrs_to_cdr_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.cdr[p]) = (post.heap.cdr[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_size_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.size[p]) = (post.heap.size[p]))))
  
  predicate wrs_to_contents_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.contents[p]) = (post.heap.contents[p]))))
  
  predicate wrs_to_top_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.top[p]) = (post.heap.top[p]))))
  
  predicate wrs_to_arr_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.arr[p]) = (post.heap.arr[p]))))
  
  predicate agree_top (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.top[o]) = (sr.heap.top[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_size (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.size[o]) = (sr.heap.size[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_contents (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.contents[o]) = (sr.heap.contents[pi.lor[o]]))))))
  
  predicate agree_cell_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.cell_value[o]) = (sr.heap.cell_value[pi.lor[o]]))))))
  
  predicate agree_cell_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.cell_rep[o]) (sr.heap.cell_rep[pi.lor[o]]))))))
  
  predicate agree_cdr (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.cdr[o]) (sr.heap.cdr[pi.lor[o]]))))))
  
  predicate agree_car (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.car[o]) (sr.heap.car[pi.lor[o]]))))))
  
  predicate agree_arr (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.arr[o]) (sr.heap.arr[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_cell_value sl sr pi w) /\
      ((agree_cell_rep sl sr pi w) /\
         ((agree_slots sl sr pi w) /\
            ((agree_length sl sr pi w) /\
               ((agree_car sl sr pi w) /\
                  ((agree_cdr sl sr pi w) /\
                     ((agree_head sl sr pi w) /\
                        ((agree_rep sl sr pi w) /\
                           ((agree_size sl sr pi w) /\
                              ((agree_contents sl sr pi w) /\ ((agree_top sl sr pi w) /\ (agree_arr sl sr pi w)))))))))))
end

module CELL
  
  use prelude.Prelude
  use State
  
  val init_Cell (s: state) (self: reference) (k: int) : unit
    requires { hasCellType s self }
    requires { self <> null }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.slots }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    ensures { result = () }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { (s.heap.cell_value[self]) = k }
    ensures { (s.heap.cell_rep[self]) = (singleton self) }
end

module STACK
  
  use prelude.Prelude
  use State
  use CELL
  use export stack_theory.Stack_theory
  
  predicate stackPub (s: state) =
    (s.maxSize > 0) /\
      ((typeofRgn s s.pool (L.Cons Stack (L.Cons Cell L.Nil))) /\
         ((forall s1: reference.
             (isAllocated s s1) ->
               ((hasStackType s s1) ->
                  ((Rgn.mem s1 s.pool) ->
                     (let sz = s.heap.size[s1] in
                      let xs = s.heap.contents[s1] in
                      (sz = (listLength xs)) /\ ((0 <= sz) /\ (sz <= s.maxSize)))))) /\
            (forall s2: reference, t: reference.
               (isAllocated s s2) ->
                 ((hasStackType s s2) ->
                    ((Rgn.mem s2 s.pool) ->
                       ((isAllocated s t) ->
                          ((hasStackType s t) ->
                             ((Rgn.mem t s.pool) ->
                                (let srep = s.heap.rep[s2] in
                                 let trep = s.heap.rep[t] in
                                 (s2 <> t) -> (srep \# trep))))))))))
  
  val init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { stackPub s }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.slots }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r25 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r25 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { stackPub s }
  
  val isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { stackPub s }
    ensures { let bsnap_r25 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r25 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { stackPub s }
  
  val push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { stackPub s }
    writes { s.heap.contents }
    writes { s.heap.slots }
    writes { s.heap.head }
    writes { s.heap.cdr }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.rep }
    writes { s.heap.cell_rep }
    writes { s.heap.top }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.alloct }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r25 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r25 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (cons k xs) }
    ensures { stackPub s }
  
  val pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { stackPub s }
    writes { s.heap.contents }
    writes { s.heap.slots }
    writes { s.heap.head }
    writes { s.heap.cdr }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.rep }
    writes { s.heap.cell_rep }
    writes { s.heap.top }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.alloct }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r25 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r25 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (tl ostk) }
    ensures { stackPub s }
end

module ArrayStack
  
  use prelude.Prelude
  use State
  use STACK
  
  predicate arrayStackPriv (s: state) =
    (forall s1: reference.
       (isAllocated s s1) ->
         ((hasStackType s s1) ->
            ((Rgn.mem s1 s.pool) ->
               (let arr2 = s.heap.arr[s1] in
                let stk = s.heap.contents[s1] in
                let siz = s.heap.size[s1] in
                let top3 = s.heap.top[s1] in
                let rep4 = s.heap.rep[s1] in
                (typeofRgn s rep4 (L.Cons CellArray (L.Cons Cell L.Nil))) /\
                  ((arr2 <> null) /\
                     (((s.heap.length[arr2]) = s.maxSize) /\
                        ((Rgn.mem arr2 rep4) /\
                           ((forall i: int.
                               ((0 <= i) /\ (i <= top3)) -> (let c = A.get (s.heap.slots[arr2]) i in
                                                             (c <> null) /\ (Rgn.mem c rep4))) /\
                              ((siz = (STACK.listLength stk)) /\
                                 ((siz = (top3 + 1)) /\
                                    (forall i: int.
                                       ((0 <= i) /\ (i <= top3)) ->
                                         (let c = A.get (s.heap.slots[arr2]) i in
                                          let v = s.heap.cell_value[c] in
                                          v = (STACK.listNth (top3 - i) stk))))))))))))) /\
      (STACK.stackPub s)
  
  let init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.arr }
    writes { s.heap.contents }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr ({} union {self})`slots] wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (singleton self)) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr ({} union {self})`length] wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (singleton self)) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = STACK.nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let arr1 = ref null in
        (((assert { hasCellArrayType s (! arr1) });
          (let ghost rep2 = ref emptyRgn in
           (((assert { isValidRgn s (! rep2) });
             (s.heap.rep <- ([@expl:self.rep := {}] M.add (! self) emptyRgn s.heap.rep));
             (s.heap.contents <- ([@expl:self.contents := nil] M.add (! self) STACK.nil s.heap.contents));
             (s.heap.size <- ([@expl:self.size := 0] M.add (! self) 0 s.heap.size));
             (s.heap.top <- ([@expl:self.top := - 1] M.add (! self) (0 - 1) s.heap.top));
             (((arr1 := ([@expl:arr := new(CellArray){maxSize}] mk_CellArray s));
               (s.heap.length <- ([@expl:arr := new(CellArray){maxSize}] M.add (! arr1) s.maxSize s.heap.length));
               (s.heap.slots <- ([@expl:arr := new(CellArray){maxSize}] M.add (! arr1) (A.make s.maxSize null) s.heap.slots))));
             (s.heap.arr <- ([@expl:self.arr := arr] M.add (! self) (! arr1) s.heap.arr));
             (assert {
                ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                   ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                  true });
             (rep2 := ([@expl:rep := self.rep] s.heap.rep[! self]));
             (s.heap.rep <- ([@expl:self.rep := rep union {arr}] M.add (! self) (Rgn.union (! rep2) (singleton (! arr1))) s.heap.rep));
             (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
             (! result))))))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.alloct }
    writes { s.heap.arr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.cons k xs) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let a = ref null in
         (((assert { hasCellArrayType s (! a) });
           (let t = ref 0 in
            (let v = ref null in
             (((assert { hasCellType s (! v) });
               (let sz = ref 0 in
                (let ghost rep1 = ref emptyRgn in
                 (((assert { isValidRgn s (! rep1) });
                   (let ghost contents2 = ref (any intList) in
                    (((assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (a := ([@expl:a := self.arr] s.heap.arr[! self]));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (t := ([@expl:t := self.top] s.heap.top[! self]));
                      (s.heap.top <- ([@expl:self.top := t + 1] M.add (! self) ((! t) + 1) s.heap.top));
                      (v := ([@expl:v := new Cell] mk_Cell s));
                      (s.heap.cell_value <- ([@expl:v.cell_value := k] M.add (! v) (! k) s.heap.cell_value));
                      (s.heap.cell_rep <- ([@expl:v.cell_rep := {v}] M.add (! v) (singleton (! v)) s.heap.cell_rep));
                      (s.heap.slots <- ([@expl:a.{t + 1} := v] M.add (! a) (A.set (s.heap.slots[! a]) ((! t) + 1) (! v)) s.heap.slots));
                      (s.heap.arr <- ([@expl:self.arr := a] M.add (! self) (! a) s.heap.arr));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                      (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (rep1 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                      (s.heap.rep <-
                         ([@expl:self.rep := rep union {v}] M.add (! self) (Rgn.union (! rep1) (singleton (! v))) s.heap.rep));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (contents2 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                      (s.heap.contents <-
                         ([@expl:self.contents := cons(k,contents)] M.add (! self) (STACK.cons (! k) (! contents2)) s.heap.contents));
                      (assert {
                         let top3 = s.heap.top[! self] in
                         forall i: int.
                           ((0 <= i) /\ (i <= top3)) ->
                             (let stk = s.heap.contents[! self] in
                              let arr4 = s.heap.arr[! self] in
                              let box = A.get (s.heap.slots[arr4]) i in
                              (s.heap.cell_value[box]) = (STACK.listNth (top3 - i) stk)) });
                      (! result)))))))))))))))))
  
  let pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.heap.contents }
    writes { s.heap.size }
    writes { s.heap.top }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = STACK.hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.tl ostk) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let a = ref null in
        (((assert { hasCellArrayType s (! a) });
          (let t = ref 0 in
           (let sz = ref 0 in
            (let ghost contents1 = ref (any intList) in
             (((assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (a := ([@expl:a := self.arr] s.heap.arr[! self]));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (t := ([@expl:t := self.top] s.heap.top[! self]));
               (assert {
                  ((Rgn.mem (! a) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! a) (s.alloct.M.domain at INIT))) \/ ((! a) = null))) /\
                    true });
               (result := ([@expl:result := a.{t}] A.get (s.heap.slots[! a]) (! t)));
               (s.heap.top <- ([@expl:self.top := t - 1] M.add (! self) ((! t) - 1) s.heap.top));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (sz := ([@expl:sz := self.size] s.heap.size[! self]));
               (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (contents1 := ([@expl:contents := self.contents] s.heap.contents[! self]));
               (s.heap.contents <- ([@expl:self.contents := tl(contents)] M.add (! self) (STACK.tl (! contents1)) s.heap.contents));
               (! result))))))))))
  
  lemma boundary_frames_invariant_ArrayStack : forall s: state, t: state, pi: 
                                                 PreRefperm.t.
                                                 (okRefperm s t pi) ->
                                                   ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                      ((s.maxSize = t.maxSize) ->
                                                         ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                            ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                               ((arrayStackPriv s) -> (arrayStackPriv t))))))
end

module Cell
  
  use prelude.Prelude
  use State
  use CELL
  
  let init_Cell (s: state) (self: reference) (k: int) : unit
    requires { hasCellType s self }
    requires { self <> null }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    ensures { result = () }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { (s.heap.cell_value[self]) = k }
    ensures { (s.heap.cell_rep[self]) = (singleton self) } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (((s.heap.cell_value <- ([@expl:self.cell_value := k] M.add (! self) (! k) s.heap.cell_value));
          (s.heap.cell_rep <- ([@expl:self.cell_rep := {self}] M.add (! self) (singleton (! self)) s.heap.cell_rep));
          (! result)))))
end

module ListStack
  
  use prelude.Prelude
  use State
  use STACK
  
  predicate stackRep (s: state) (xs: intList) (n: reference) =
   match xs with Nil -> n = null
   | Cons h t -> hasNodeType s n /\ isAllocated s n /\
     isAllocated s s.heap.car[n] /\
     s.heap.cell_value[s.heap.car[n]] = h /\
     stackRep s t s.heap.cdr[n] end

lemma stackRep_mono : forall xs. forall n s s'.
  (forall p:reference. p \: s.alloct ->
     p \: s'.alloct /\ s'.alloct[p] = s.alloct[p]) ->
  (forall p:reference. hasNodeType s p -> isAllocated s p ->
     s.heap.car[p] = s'.heap.car[p] /\
     s.heap.cdr[p] = s'.heap.cdr[p]) ->
  (forall p:reference. hasCellType s p -> isAllocated s p ->
     s.heap.cell_value[p] = s'.heap.cell_value[p]) ->
  stackRep s xs n -> stackRep s' xs n

  
  predicate listStackPriv (s: state) =
    (STACK.stackPub s) /\
      (forall s1: reference.
         (isAllocated s s1) ->
           ((hasStackType s s1) ->
              ((Rgn.mem s1 s.pool) ->
                 (let rep2 = s.heap.rep[s1] in
                  let head3 = s.heap.head[s1] in
                  let stk = s.heap.contents[s1] in
                  (Rgn.mem null rep2) /\
                    ((Rgn.mem head3 rep2) /\
                       ((Rgn.subset (img_cdr s rep2) rep2) /\
                          ((forall n: reference.
                              (isAllocated s n) ->
                                ((hasNodeType s n) -> ((Rgn.mem n rep2) -> (let c = s.heap.car[n] in
                                                                    Rgn.mem c rep2)))) /\
                             (stackRep s stk head3))))))))

lemma stackRep_agree1: forall xs. forall s t pi n.
  okRefperm s t pi ->
  PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain ->
  PreRefperm.idRgn pi s.pool t.pool ->
  s.maxSize = t.maxSize ->
  agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool)) ->
  Rgn.mem n (img_rep s s.pool) ->
  (forall n: reference. isAllocated s n -> hasNodeType s n ->
    Rgn.mem n (img_rep s s.pool) ->
    Rgn.mem s.heap.cdr[n] (img_rep s s.pool)) ->
  (* Rgn.subset (img_cdr s (img_rep s s.pool)) (img_rep s s.pool) -> *)
  (forall n: reference. isAllocated s n -> hasNodeType s n ->
     Rgn.mem n (img_rep s s.pool) ->
     Rgn.mem s.heap.car[n] (img_rep s s.pool)) ->
  stackRep s xs n -> stackRep t xs n

(*
lemma stackRep_agree: forall xs. forall s t pi n.
  okRefperm s t pi ->
  PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain ->
  PreRefperm.idRgn pi s.pool t.pool ->
  s.maxSize = t.maxSize ->
  agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool)) ->
  Rgn.mem n (img_rep s s.pool) ->
  Rgn.subset (img_cdr s (img_rep s s.pool)) (img_rep s s.pool) ->
  Rgn.subset (img_car s (img_rep s s.pool)) (img_rep s s.pool) ->
  stackRep s xs n -> stackRep t xs n
*)

  let init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.pool }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = STACK.nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (((s.heap.rep <- ([@expl:self.rep := {null}] M.add (! self) (singleton null) s.heap.rep));
         (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head));
         (s.heap.contents <- ([@expl:self.contents := nil] M.add (! self) STACK.nil s.heap.contents));
         (s.heap.size <- ([@expl:self.size := 0] M.add (! self) 0 s.heap.size));
         (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
         (! result))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.alloct }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`car]
              wrs_to_car_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.cons k xs) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let v = ref null in
         (((assert { hasCellType s (! v) });
           (let n = ref null in
            (((assert { hasNodeType s (! n) });
              (let tmp = ref null in
               (((assert { hasNodeType s (! tmp) });
                 (let sz = ref 0 in
                  (let ghost rep1 = ref emptyRgn in
                   (((assert { isValidRgn s (! rep1) });
                     (let ghost contents2 = ref (any intList) in
                      (((v := ([@expl:v := new Cell] mk_Cell s));
                        (assert { not (Rgn.mem (! v) (Rgn.union s.pool (img_rep s s.pool))) });
                        (assert {
                           ((Rgn.mem (! v) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! v) (s.alloct.M.domain at INIT))) \/ ((! v) = null))) /\
                             true });
                        ([@expl:Cell(v,k)] STACK.CELL.init_Cell s (! v) (! k));
                        (n := ([@expl:n := new Node] mk_Node s));
                        (s.heap.car <- ([@expl:n.car := v] M.add (! n) (! v) s.heap.car));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                        (assert { let rep3 = s.heap.rep[! self] in
                                  Rgn.mem (! tmp) rep3 });
                        (s.heap.cdr <- ([@expl:n.cdr := tmp] M.add (! n) (! tmp) s.heap.cdr));
                        (assert {
                           let rep4 = s.heap.rep[! self] in
                           forall n5: reference.
                             (isAllocated s n5) ->
                               ((hasNodeType s n5) -> ((Rgn.mem n5 rep4) -> (let c = s.heap.car[n5] in
                                                                    Rgn.mem c rep4))) });
                        (s.heap.head <- ([@expl:self.head := n] M.add (! self) (! n) s.heap.head));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                        (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (rep1 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                        (s.heap.rep <-
                           ([@expl:self.rep := rep union {v} union {n}]
                            M.add (! self) (Rgn.union (Rgn.union (! rep1) (singleton (! v))) (singleton (! n))) s.heap.rep));
                        (assert {
                           let h = s.heap.head[! self] in
                           let n6 = s.heap.cdr[h] in
                           let rep7 = s.heap.rep[! self] in
                           Rgn.mem n6 rep7 });
                        (assert { let rep8 = s.heap.rep[! self] in
                                  Rgn.subset (img_cdr s rep8) rep8 });
                        (assert {
                           let h = s.heap.head[! self] in
                           let c = s.heap.cdr[h] in
                           let rep9 = s.heap.rep[! self] in
                           Rgn.mem c rep9 });
                        (assert {
                           let rep10 = s.heap.rep[! self] in
                           forall n11: reference.
                             (isAllocated s n11) ->
                               ((hasNodeType s n11) -> ((Rgn.mem n11 rep10) -> (let c = s.heap.car[n11] in
                                                                    Rgn.mem c rep10))) });
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (contents2 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                        (s.heap.contents <-
                           ([@expl:self.contents := cons(k,contents)] M.add (! self) (STACK.cons (! k) (! contents2)) s.heap.contents));
                        (assert { let h = s.heap.head[! self] in
                                  let stk = s.heap.contents[! self] in
                                  stackRep s stk h });
                        (! result)))))))))))))))))))
  
  let pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.size }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = STACK.hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.tl ostk) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let tmp = ref null in
        (((assert { hasNodeType s (! tmp) });
          (let nxt = ref null in
           (((assert { hasNodeType s (! nxt) });
             (let sz = ref 0 in
              (let ghost contents1 = ref (any intList) in
               (((assert { let stk = s.heap.contents[! self] in
                           exists h: int, t: intList. stk = (STACK.cons h t) });
                 (assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                 (assert { (! tmp) <> null });
                 (assert {
                    ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                      true });
                 (result := ([@expl:result := tmp.car] s.heap.car[! tmp]));
                 (assert {
                    ((Rgn.mem (! tmp) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                      true });
                 (nxt := ([@expl:nxt := tmp.cdr] s.heap.cdr[! tmp]));
                 (s.heap.head <- ([@expl:self.head := nxt] M.add (! self) (! nxt) s.heap.head));
                 (assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                 (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
                 (assert {
                    ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (contents1 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                 (s.heap.contents <- ([@expl:self.contents := tl(contents)] M.add (! self) (STACK.tl (! contents1)) s.heap.contents));
                 (! result))))))))))))
  
  lemma boundary_frames_invariant_ListStack : forall s: state, t: state, pi: 
                                                PreRefperm.t.
                                                (okRefperm s t pi) ->
                                                  ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                     ((s.maxSize = t.maxSize) ->
                                                        ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                           ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                              ((listStackPriv s) -> (listStackPriv t))))))
end

module MAIN
  
  use prelude.Prelude
  use State
end

