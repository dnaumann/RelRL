module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  use stack_theory.Stack_theory
  
  type reftype = 
    | Cell
    | CellArray
    | Node
    | Stack
  
  type heap = {
    mutable head : M.t reference ;
    mutable ghost rep : M.t rgn ;
    mutable size : M.t int ;
    mutable ghost contents : M.t intList ;
    mutable top : M.t int ;
    mutable arr : M.t reference ;
    mutable car : M.t reference ;
    mutable cdr : M.t reference ;
    mutable slots : M.t (A.array reference) ;
    mutable length : M.t int ;
    mutable cell_value : M.t int ;
    mutable ghost cell_rep : M.t rgn
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype ;
    mutable maxSize : int ;
    mutable ghost pool : rgn
  }invariant { not (null \: alloct) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Cell) ->
           (((p \: heap.cell_value) /\ (p \: heap.cell_rep)) /\
              (forall q: reference. (Rgn.mem q (heap.cell_rep[p])) -> ((q = null) \/ (q \: alloct))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = CellArray) ->
           (((p \: heap.slots) /\ (p \: heap.length)) /\
              (((heap.length[p]) >= 0) /\
                 (((heap.length[p]) = (A.length (heap.slots[p]))) /\
                    (let arr1 = heap.slots[p] in
                     forall i: int.
                       (0 <= i) ->
                         ((i < (A.length arr1)) -> (let v = A.get arr1 i in
                                                    (v = null) \/ ((v \: alloct) /\ ((alloct[v]) = Cell))))))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Node) ->
           (((p \: heap.car) /\ (p \: heap.cdr)) /\
              ((((heap.car[p]) = null) \/ (((heap.car[p]) \: alloct) /\ ((alloct[heap.car[p]]) = Cell))) /\
                 (((heap.cdr[p]) = null) \/ (((heap.cdr[p]) \: alloct) /\ ((alloct[heap.cdr[p]]) = Node)))))) }
  invariant {
    forall p: reference.
      (p \: alloct) ->
        (((alloct[p]) = Stack) ->
           (((p \: heap.head) /\
               ((p \: heap.rep) /\ ((p \: heap.size) /\ ((p \: heap.contents) /\ ((p \: heap.top) /\ (p \: heap.arr)))))) /\
              ((((heap.head[p]) = null) \/ (((heap.head[p]) \: alloct) /\ ((alloct[heap.head[p]]) = Node))) /\
                 ((((heap.arr[p]) = null) \/ (((heap.arr[p]) \: alloct) /\ ((alloct[heap.arr[p]]) = CellArray))) /\
                    (forall q: reference. (Rgn.mem q (heap.rep[p])) -> ((q = null) \/ (q \: alloct))))))) }
  invariant { forall q: reference. (Rgn.mem q pool) -> ((q = null) \/ (q \: alloct)) }
   by { heap = (any heap) ;
  alloct = (M.create ()) ;
  maxSize = (any int) ;
  pool = emptyRgn }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) = forall q: reference. (Rgn.mem q r) -> ((q = null) \/ (q \: s.alloct))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ (L.mem (s.alloct[p]) types)))
  
  predicate hasCellType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Cell))
  
  predicate hasCellArrayType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = CellArray))
  
  predicate hasNodeType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Node))
  
  predicate hasStackType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Stack))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Cell (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { s.heap.cell_value = (M.add result 0 (old s.heap.cell_value)) }
    ensures { s.heap.cell_rep = (M.add result emptyRgn (old s.heap.cell_rep)) }
  
  val mk_CellArray (s: state) : reference
    writes { s.alloct }
    writes { s.heap.slots }
    writes { s.heap.length }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result CellArray (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasCellArrayType s result }
    ensures { s.heap.slots = (M.add result (A.make 0 null) (old s.heap.slots)) }
    ensures { s.heap.length = (M.add result 0 (old s.heap.length)) }
  
  val mk_Node (s: state) : reference
    writes { s.alloct }
    writes { s.heap.car }
    writes { s.heap.cdr }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Node (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasNodeType s result }
    ensures { s.heap.car = (M.add result null (old s.heap.car)) }
    ensures { s.heap.cdr = (M.add result null (old s.heap.cdr)) }
  
  val mk_Stack (s: state) : reference
    writes { s.alloct }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result Stack (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasStackType s result }
    ensures { s.heap.head = (M.add result null (old s.heap.head)) }
    ensures { s.heap.rep = (M.add result emptyRgn (old s.heap.rep)) }
    ensures { s.heap.size = (M.add result 0 (old s.heap.size)) }
    ensures { s.heap.contents = (M.add result nil (old s.heap.contents)) }
    ensures { s.heap.top = (M.add result 0 (old s.heap.top)) }
    ensures { s.heap.arr = (M.add result null (old s.heap.arr)) }
  
  function img_top : state -> (rgn -> rgn)
  
  axiom img_top_ax : forall s: state, r: rgn. (img_top s r) = emptyRgn
  
  function img_slots : state -> (rgn -> rgn)
  
  axiom img_slots_ax : forall s: state, r: rgn, p: reference.
                         (Rgn.mem p (img_slots s r)) <->
                           (((p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = Cell))) /\
                              (exists arr2: reference.
                                 (arr2 \: s.alloct) /\
                                   (((s.alloct[arr2]) = CellArray) /\
                                      ((Rgn.mem arr2 r) /\
                                         (exists i: int.
                                            (0 <= i) /\ ((i < (A.length (s.heap.slots[arr2]))) /\ ((A.get (s.heap.slots[arr2]) i) = p)))))))
  
  function img_size : state -> (rgn -> rgn)
  
  axiom img_size_ax : forall s: state, r: rgn. (img_size s r) = emptyRgn
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_rep s r)) <->
                         (exists q: reference.
                            (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.rep[q])))))
  
  function img_length : state -> (rgn -> rgn)
  
  axiom img_length_ax : forall s: state, r: rgn. (img_length s r) = emptyRgn
  
  function img_head : state -> (rgn -> rgn)
  
  axiom img_head_ax : forall s: state, r: rgn, p: reference.
                        (Rgn.mem p (img_head s r)) <->
                          (exists q: reference.
                             (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (p = (s.heap.head[q])))))
  
  function img_contents : state -> (rgn -> rgn)
  
  axiom img_contents_ax : forall s: state, r: rgn. (img_contents s r) = emptyRgn
  
  function img_cell_value : state -> (rgn -> rgn)
  
  axiom img_cell_value_ax : forall s: state, r: rgn. (img_cell_value s r) = emptyRgn
  
  function img_cell_rep : state -> (rgn -> rgn)
  
  axiom img_cell_rep_ax : forall s: state, r: rgn, p: reference.
                            (Rgn.mem p (img_cell_rep s r)) <->
                              (exists q: reference.
                                 (q \: s.alloct) /\ (((s.alloct[q]) = Cell) /\ ((Rgn.mem q r) /\ (Rgn.mem p (s.heap.cell_rep[q])))))
  
  function img_cdr : state -> (rgn -> rgn)
  
  axiom img_cdr_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_cdr s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.cdr[q])))))
  
  function img_car : state -> (rgn -> rgn)
  
  axiom img_car_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_car s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Node) /\ ((Rgn.mem q r) /\ (p = (s.heap.car[q])))))
  
  function img_arr : state -> (rgn -> rgn)
  
  axiom img_arr_ax : forall s: state, r: rgn, p: reference.
                       (Rgn.mem p (img_arr s r)) <->
                         (exists q: reference. (q \: s.alloct) /\ (((s.alloct[q]) = Stack) /\ ((Rgn.mem q r) /\ (p = (s.heap.arr[q])))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p: reference. (p \: pre.alloct) -> ((p \: post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p])))
  
  predicate wrs_to_cell_value_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) ->
        (((post.alloct[p]) = Cell) -> ((not (Rgn.mem p r)) -> ((pre.heap.cell_value[p]) = (post.heap.cell_value[p]))))
  
  predicate wrs_to_cell_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Cell) -> ((not (Rgn.mem p r)) -> ((pre.heap.cell_rep[p]) = (post.heap.cell_rep[p]))))
  
  predicate wrs_to_slots_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = CellArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.slots[p]) = (post.heap.slots[p]))))
  
  predicate wrs_to_length_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = CellArray) -> ((not (Rgn.mem p r)) -> ((pre.heap.length[p]) = (post.heap.length[p]))))
  
  predicate wrs_to_car_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.car[p]) = (post.heap.car[p]))))
  
  predicate wrs_to_cdr_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Node) -> ((not (Rgn.mem p r)) -> ((pre.heap.cdr[p]) = (post.heap.cdr[p]))))
  
  predicate wrs_to_head_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.head[p]) = (post.heap.head[p]))))
  
  predicate wrs_to_rep_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.rep[p]) = (post.heap.rep[p]))))
  
  predicate wrs_to_size_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.size[p]) = (post.heap.size[p]))))
  
  predicate wrs_to_contents_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.contents[p]) = (post.heap.contents[p]))))
  
  predicate wrs_to_top_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.top[p]) = (post.heap.top[p]))))
  
  predicate wrs_to_arr_framed_by (pre: state) (post: state) (r: rgn) =
    forall p: reference.
      (p \: pre.alloct) -> (((post.alloct[p]) = Stack) -> ((not (Rgn.mem p r)) -> ((pre.heap.arr[p]) = (post.heap.arr[p]))))
  
  predicate agree_top (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.top[o]) = (sr.heap.top[pi.lor[o]]))))))
  
  predicate agree_slots (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.slots[o]) = (sr.heap.slots[pi.lor[o]]))))))
  
  predicate agree_size (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.size[o]) = (sr.heap.size[pi.lor[o]]))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.rep[o]) (sr.heap.rep[pi.lor[o]]))))))
  
  predicate agree_length (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellArrayType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.length[o]) = (sr.heap.length[pi.lor[o]]))))))
  
  predicate agree_head (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.head[o]) (sr.heap.head[pi.lor[o]]))))))
  
  predicate agree_contents (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.contents[o]) = (sr.heap.contents[pi.lor[o]]))))))
  
  predicate agree_cell_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.cell_value[o]) = (sr.heap.cell_value[pi.lor[o]]))))))
  
  predicate agree_cell_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasCellType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRgn pi (sl.heap.cell_rep[o]) (sr.heap.cell_rep[pi.lor[o]]))))))
  
  predicate agree_cdr (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.cdr[o]) (sr.heap.cdr[pi.lor[o]]))))))
  
  predicate agree_car (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasNodeType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.car[o]) (sr.heap.car[pi.lor[o]]))))))
  
  predicate agree_arr (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasStackType sl o) ->
              ((Rgn.mem o w) ->
                 ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] PreRefperm.idRef pi (sl.heap.arr[o]) (sr.heap.arr[pi.lor[o]]))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_cell_value sl sr pi w) /\
      ((agree_cell_rep sl sr pi w) /\
         ((agree_slots sl sr pi w) /\
            ((agree_length sl sr pi w) /\
               ((agree_car sl sr pi w) /\
                  ((agree_cdr sl sr pi w) /\
                     ((agree_head sl sr pi w) /\
                        ((agree_rep sl sr pi w) /\
                           ((agree_size sl sr pi w) /\
                              ((agree_contents sl sr pi w) /\ ((agree_top sl sr pi w) /\ (agree_arr sl sr pi w)))))))))))
end

module CELL
  
  use prelude.Prelude
  use State
  
  val init_Cell (s: state) (self: reference) (k: int) : unit
    requires { hasCellType s self }
    requires { self <> null }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.slots }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    ensures { result = () }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { (s.heap.cell_value[self]) = k }
    ensures { (s.heap.cell_rep[self]) = (singleton self) }
end

module STACK
  
  use prelude.Prelude
  use State
  use CELL
  use export stack_theory.Stack_theory
  
  predicate stackPub (s: state) =
    (s.maxSize > 0) /\
      ((typeofRgn s s.pool (L.Cons Stack (L.Cons Cell L.Nil))) /\
         ((forall s1: reference.
             (isAllocated s s1) ->
               ((hasStackType s s1) ->
                  ((Rgn.mem s1 s.pool) ->
                     (let sz = s.heap.size[s1] in
                      let xs = s.heap.contents[s1] in
                      (sz = (listLength xs)) /\ ((0 <= sz) /\ (sz <= s.maxSize)))))) /\
            (forall s2: reference, t: reference.
               (isAllocated s s2) ->
                 ((hasStackType s s2) ->
                    ((Rgn.mem s2 s.pool) ->
                       ((isAllocated s t) ->
                          ((hasStackType s t) ->
                             ((Rgn.mem t s.pool) ->
                                (let srep = s.heap.rep[s2] in
                                 let trep = s.heap.rep[t] in
                                 (s2 <> t) -> (srep \# trep))))))))))
  
  val init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { stackPub s }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.contents }
    writes { s.heap.top }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.slots }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.heap.cell_rep }
    writes { s.alloct }
    writes { s.pool }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff (s.heap.rep[self]) (singleton null)) (Rgn.diff s.alloct.M.domain oa) }
    ensures { stackPub s }
  
  val isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { stackPub s }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { stackPub s }
  
  val push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { stackPub s }
    writes { s.heap.contents }
    writes { s.heap.slots }
    writes { s.heap.head }
    writes { s.heap.cdr }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.rep }
    writes { s.heap.cell_rep }
    writes { s.heap.top }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    writes { s.alloct }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (cons k xs) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self]) }
    ensures { let oa = old s.alloct.M.domain in
              let orep = old (s.heap.rep[self]) in
              Rgn.subset (s.heap.rep[self]) (Rgn.union orep (Rgn.diff s.alloct.M.domain oa)) }
    ensures { stackPub s }
  
  val pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { stackPub s }
    writes { s.heap.contents }
    writes { s.heap.slots }
    writes { s.heap.head }
    writes { s.heap.cdr }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.rep }
    writes { s.heap.cell_rep }
    writes { s.heap.top }
    writes { s.heap.size }
    writes { s.heap.length }
    writes { s.heap.cell_value }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`head]
              wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`arr]
              wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`car]
              wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`top]
              wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`size]
              wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (tl ostk) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let rep2 = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = rep2 }
    ensures { stackPub s }
  
  val getMaxSize (s: state) : int
    requires { stackPub s }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result = s.maxSize }
    ensures { stackPub s }
  
  val getCellValue (s: state) (c: reference) : int
    requires { hasCellType s c }
    requires { c <> null }
    requires { stackPub s }
    ensures { let bsnap_r37 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r37 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.cell_value[c]) = result }
    ensures { stackPub s }
end

module ArrayStack
  
  use prelude.Prelude
  use State
  use STACK
  
  predicate arrayStackPriv (s: state) =
    (forall s1: reference.
       (isAllocated s s1) ->
         ((hasStackType s s1) ->
            ((Rgn.mem s1 s.pool) ->
               (let arr2 = s.heap.arr[s1] in
                let stk = s.heap.contents[s1] in
                let siz = s.heap.size[s1] in
                let top3 = s.heap.top[s1] in
                let rep4 = s.heap.rep[s1] in
                (typeofRgn s rep4 (L.Cons CellArray (L.Cons Cell L.Nil))) /\
                  ((arr2 <> null) /\
                     (((s.heap.length[arr2]) = s.maxSize) /\
                        ((Rgn.mem arr2 rep4) /\
                           ((forall i: int.
                               ((0 <= i) /\ (i <= top3)) -> (let c = A.get (s.heap.slots[arr2]) i in
                                                             (c <> null) /\ (Rgn.mem c rep4))) /\
                              ((siz = (STACK.listLength stk)) /\
                                 ((siz = (top3 + 1)) /\
                                    (forall i: int.
                                       ((0 <= i) /\ (i <= top3)) ->
                                         (let c = A.get (s.heap.slots[arr2]) i in
                                          let v = s.heap.cell_value[c] in
                                          v = (STACK.listNth (top3 - i) stk))))))))))))) /\
      (STACK.stackPub s)
  
  let init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.arr }
    writes { s.heap.contents }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr ({} union {self})`slots] wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (singleton self)) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr ({} union {self})`length] wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (singleton self)) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = STACK.nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff (s.heap.rep[self]) (singleton null)) (Rgn.diff s.alloct.M.domain oa) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let arr1 = ref null in
        (((assert { hasCellArrayType s (! arr1) });
          (let ghost rep2 = ref emptyRgn in
           (((assert { isValidRgn s (! rep2) });
             (s.heap.rep <- ([@expl:self.rep := {}] M.add (! self) emptyRgn s.heap.rep));
             (s.heap.contents <- ([@expl:self.contents := nil] M.add (! self) STACK.nil s.heap.contents));
             (s.heap.size <- ([@expl:self.size := 0] M.add (! self) 0 s.heap.size));
             (s.heap.top <- ([@expl:self.top := - 1] M.add (! self) (0 - 1) s.heap.top));
             (((arr1 := ([@expl:arr := new(CellArray){maxSize}] mk_CellArray s));
               (s.heap.length <- ([@expl:arr := new(CellArray){maxSize}] M.add (! arr1) s.maxSize s.heap.length));
               (s.heap.slots <- ([@expl:arr := new(CellArray){maxSize}] M.add (! arr1) (A.make s.maxSize null) s.heap.slots))));
             (s.heap.arr <- ([@expl:self.arr := arr] M.add (! self) (! arr1) s.heap.arr));
             (assert {
                ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                   ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                  true });
             (rep2 := ([@expl:rep := self.rep] s.heap.rep[! self]));
             (s.heap.rep <- ([@expl:self.rep := rep union {arr}] M.add (! self) (Rgn.union (! rep2) (singleton (! arr1))) s.heap.rep));
             (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
             (! result))))))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.alloct }
    writes { s.heap.arr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.cons k xs) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self]) }
    ensures { let oa = old s.alloct.M.domain in
              let orep = old (s.heap.rep[self]) in
              Rgn.subset (s.heap.rep[self]) (Rgn.union orep (Rgn.diff s.alloct.M.domain oa)) }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let a = ref null in
         (((assert { hasCellArrayType s (! a) });
           (let t = ref 0 in
            (let v = ref null in
             (((assert { hasCellType s (! v) });
               (let sz = ref 0 in
                (let ghost rep1 = ref emptyRgn in
                 (((assert { isValidRgn s (! rep1) });
                   (let ghost contents2 = ref (any intList) in
                    (((assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (a := ([@expl:a := self.arr] s.heap.arr[! self]));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (t := ([@expl:t := self.top] s.heap.top[! self]));
                      (s.heap.top <- ([@expl:self.top := t + 1] M.add (! self) ((! t) + 1) s.heap.top));
                      (v := ([@expl:v := new Cell] mk_Cell s));
                      (s.heap.cell_value <- ([@expl:v.cell_value := k] M.add (! v) (! k) s.heap.cell_value));
                      (s.heap.cell_rep <- ([@expl:v.cell_rep := {v}] M.add (! v) (singleton (! v)) s.heap.cell_rep));
                      (s.heap.slots <- ([@expl:a.{t + 1} := v] M.add (! a) (A.set (s.heap.slots[! a]) ((! t) + 1) (! v)) s.heap.slots));
                      (s.heap.arr <- ([@expl:self.arr := a] M.add (! self) (! a) s.heap.arr));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                      (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (rep1 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                      (s.heap.rep <-
                         ([@expl:self.rep := rep union {v}] M.add (! self) (Rgn.union (! rep1) (singleton (! v))) s.heap.rep));
                      (assert {
                         ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                            ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                           true });
                      (contents2 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                      (s.heap.contents <-
                         ([@expl:self.contents := cons(k,contents)] M.add (! self) (STACK.cons (! k) (! contents2)) s.heap.contents));
                      (assert {
                         let top3 = s.heap.top[! self] in
                         forall i: int.
                           ((0 <= i) /\ (i <= top3)) ->
                             (let stk = s.heap.contents[! self] in
                              let arr4 = s.heap.arr[! self] in
                              let box = A.get (s.heap.slots[arr4]) i in
                              (s.heap.cell_value[box]) = (STACK.listNth (top3 - i) stk)) });
                      (! result)))))))))))))))))
  
  let pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    writes { s.heap.contents }
    writes { s.heap.size }
    writes { s.heap.top }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`size]
              wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`top]
              wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`car]
              wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`arr]
              wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`head]
              wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = STACK.hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.tl ostk) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let rep2 = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = rep2 }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let a = ref null in
        (((assert { hasCellArrayType s (! a) });
          (let t = ref 0 in
           (let sz = ref 0 in
            (let ghost contents3 = ref (any intList) in
             (((assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (a := ([@expl:a := self.arr] s.heap.arr[! self]));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (t := ([@expl:t := self.top] s.heap.top[! self]));
               (assert {
                  ((Rgn.mem (! a) ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                     ((not (Rgn.mem (! a) (s.alloct.M.domain at INIT))) \/ ((! a) = null))) /\
                    true });
               (result := ([@expl:result := a.{t}] A.get (s.heap.slots[! a]) (! t)));
               (s.heap.top <- ([@expl:self.top := t - 1] M.add (! self) ((! t) - 1) s.heap.top));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (sz := ([@expl:sz := self.size] s.heap.size[! self]));
               (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
               (assert {
                  ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                     ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                    true });
               (contents3 := ([@expl:contents := self.contents] s.heap.contents[! self]));
               (s.heap.contents <- ([@expl:self.contents := tl(contents)] M.add (! self) (STACK.tl (! contents3)) s.heap.contents));
               (! result))))))))))
  
  let getMaxSize (s: state) : int
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result = s.maxSize }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in let result = ref 0 in
                  (((result := ([@expl:result := maxSize] s.maxSize));
                    (! result)))
  
  let getCellValue (s: state) (c: reference) : int
    requires { hasCellType s c }
    requires { c <> null }
    requires { STACK.stackPub s }
    requires { arrayStackPriv s }
    ensures { let bsnap_r1 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r1 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.cell_value[c]) = result }
    ensures { STACK.stackPub s }
    ensures { arrayStackPriv s } =
    label INIT in
      let result = ref 0 in
      (let c = ref c in
       (((assert {
            ((Rgn.mem (! c) ((singleton (! c)) at INIT)) \/ ((not (Rgn.mem (! c) (s.alloct.M.domain at INIT))) \/ ((! c) = null))) /\
              true });
         (result := ([@expl:result := c.cell_value] s.heap.cell_value[! c]));
         (! result))))
  
  lemma boundary_frames_invariant_ArrayStack : forall s: state, t: state, pi: 
                                                 PreRefperm.t.
                                                 (okRefperm s t pi) ->
                                                   ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                      ((s.maxSize = t.maxSize) ->
                                                         ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                            ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                               ((arrayStackPriv s) -> (arrayStackPriv t))))))
end

module CLIENT
  
  use prelude.Prelude
  use State
end

module Client1
  use prelude.Prelude
  use State
  use CLIENT
  use ArrayStack
  
  let prog (s: state) (n: int) : int
    requires { (s.maxSize > n) /\ (n >= 0) }
    requires { s.pool = emptyRgn }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.arr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({} union pool union pool`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`head]
              wrs_to_head_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`cdr] wrs_to_cdr_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`arr]
              wrs_to_arr_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`car] wrs_to_car_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`top]
              wrs_to_top_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`size]
              wrs_to_size_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) } diverges =
    label INIT in
      let result = ref 0 in
      (let n = ref n in
       (let stk = ref null in
        (((assert { hasStackType s (! stk) });
          (let i = ref 0 in
           (let c1 = ref null in
            (((assert { hasCellType s (! c1) });
              (stk := ([@expl:stk := new Stack] mk_Stack s));
              (assert {
                 ((Rgn.mem (! stk) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                    ((not (Rgn.mem (! stk) (s.alloct.M.domain at INIT))) \/ ((! stk) = null))) /\
                   true });
              ([@expl:Stack(stk)] ArrayStack.init_Stack s (! stk));
              (assert { Rgn.mem (! stk) s.pool });
              (while (! i) < (! n) do
                 invariant { [@expl:locals type invariant] (hasCellType s (! c1)) /\ (hasStackType s (! stk)) }
                 invariant { alloc_does_not_shrink (old s) s }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`contents]
                   wrs_to_contents_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`slots]
                   wrs_to_slots_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`head]
                   wrs_to_head_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cdr]
                   wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`arr]
                   wrs_to_arr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`car]
                   wrs_to_car_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`rep]
                   wrs_to_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                   wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`top]
                   wrs_to_top_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`size]
                   wrs_to_size_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`length]
                   wrs_to_length_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_value]
                   wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant { (0 <= (! i)) /\ ((! i) <= (! n)) }
                 invariant { (Rgn.mem (! stk) s.pool) /\ ((0 <= (! n)) /\ ((! n) < s.maxSize)) }
                 invariant { let sz = s.heap.size[! stk] in
                             sz = (! i) }
                 invariant { (ArrayStack.STACK.stackPub s) /\ (ArrayStack.arrayStackPriv s) }
                 invariant {
                   let oa = old s.alloct.M.domain in
                   Rgn.subset
                      (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                      (Rgn.diff s.alloct.M.domain oa) }
                 ((assert {
                     (Rgn.subset
                         (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                         (Rgn.union
                             ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                             (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                       true });
                  ([@expl:push(stk,i)] ArrayStack.push s (! stk) (! i));
                  (i := ([@expl:i := i + 1] (! i) + 1)))
               done);
              (i := ([@expl:i := 0] 0));
              (while (! i) < (! n) do
                 invariant { [@expl:locals type invariant] (hasCellType s (! c1)) /\ (hasStackType s (! stk)) }
                 invariant { alloc_does_not_shrink (old s) s }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`contents]
                   wrs_to_contents_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`slots]
                   wrs_to_slots_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`head]
                   wrs_to_head_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cdr]
                   wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`arr]
                   wrs_to_arr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`car]
                   wrs_to_car_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`rep]
                   wrs_to_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                   wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`top]
                   wrs_to_top_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`size]
                   wrs_to_size_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`length]
                   wrs_to_length_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_value]
                   wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant { (0 <= (! i)) /\ ((! i) <= (! n)) }
                 invariant { (Rgn.mem (! stk) s.pool) /\ ((0 <= (! n)) /\ ((! n) < s.maxSize)) }
                 invariant { let sz = s.heap.size[! stk] in
                             sz = ((! n) - (! i)) }
                 invariant { (ArrayStack.STACK.stackPub s) /\ (ArrayStack.arrayStackPriv s) }
                 invariant { ((! c1) = null) \/ (let rep2 = s.heap.rep[! stk] in
                                                 Rgn.mem (! c1) rep2) }
                 invariant {
                   let oa = s.alloct.M.domain at INIT in
                   Rgn.subset
                      (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                      (Rgn.diff s.alloct.M.domain oa) }
                 ((assert {
                     (Rgn.subset
                         (Rgn.diff (Rgn.union (singleton (! stk)) (Rgn.union (s.heap.rep[! stk]) (singleton (! c1)))) (singleton null))
                         (Rgn.union
                             ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                             (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                       true });
                  (c1 := ([@expl:c := pop(stk)] ArrayStack.pop s (! stk)));
                  (let v = ref 0 in
                   (((assert {
                        ((Rgn.mem (! c1) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                           ((not (Rgn.mem (! c1) (s.alloct.M.domain at INIT))) \/ ((! c1) = null))) /\
                          true });
                     (v := ([@expl:v := getCellValue(c)] ArrayStack.getCellValue s (! c1)));
                     (result := ([@expl:result := result + v] (! result) + (! v)));
                     (i := ([@expl:i := i + 1] (! i) + 1))))))
               done);
              (! result)))))))))
end

module ListStack
  
  use prelude.Prelude
  use State
  use STACK
  
  predicate stackRep (s: state) (xs: intList) (n: reference) =
   match xs with Nil -> n = null
   | Cons h t -> hasNodeType s n /\ isAllocated s n /\
     isAllocated s s.heap.car[n] /\
     s.heap.cell_value[s.heap.car[n]] = h /\
     stackRep s t s.heap.cdr[n] end

lemma stackRep_mono : forall xs. forall n s s'.
  (forall p:reference. p \: s.alloct ->
     p \: s'.alloct /\ s'.alloct[p] = s.alloct[p]) ->
  (forall p:reference. hasNodeType s p -> isAllocated s p ->
     s.heap.car[p] = s'.heap.car[p] /\
     s.heap.cdr[p] = s'.heap.cdr[p]) ->
  (forall p:reference. hasCellType s p -> isAllocated s p ->
     s.heap.cell_value[p] = s'.heap.cell_value[p]) ->
  stackRep s xs n -> stackRep s' xs n

lemma stackRep_agree : forall xs. forall s t pi n.
  okRefperm s t pi ->
  PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain ->
  PreRefperm.idRgn pi s.pool t.pool ->
  s.maxSize = t.maxSize ->
  agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool)) ->
  Rgn.mem n (img_rep s s.pool) ->
  Rgn.subset (img_cdr s (img_rep s s.pool)) (img_rep s s.pool) ->
  Rgn.subset (img_car s (img_rep s s.pool)) (img_rep s s.pool) ->
  stackRep s xs n -> stackRep t xs n


  
  predicate listStackPriv (s: state) =
    (STACK.stackPub s) /\
      (forall s1: reference.
         (isAllocated s s1) ->
           ((hasStackType s s1) ->
              ((Rgn.mem s1 s.pool) ->
                 (let rep2 = s.heap.rep[s1] in
                  let head3 = s.heap.head[s1] in
                  let stk = s.heap.contents[s1] in
                  (Rgn.mem null rep2) /\
                    ((Rgn.mem head3 rep2) /\
                       ((Rgn.subset (img_cdr s rep2) rep2) /\
                          ((forall n: reference.
                              (isAllocated s n) ->
                                ((hasNodeType s n) -> ((Rgn.mem n rep2) -> (let c = s.heap.car[n] in
                                                                    Rgn.mem c rep2)))) /\
                             (stackRep s stk head3))))))))
  
  let init_Stack (s: state) (self: reference) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { not (Rgn.mem self s.pool) }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.pool }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.rep }
    writes { s.heap.size }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.size[self]) = 0 }
    ensures { (s.heap.contents[self]) = STACK.nil }
    ensures { let opool = old s.pool in
              s.pool = (Rgn.union opool (singleton self)) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff (s.heap.rep[self]) (singleton null)) (Rgn.diff s.alloct.M.domain oa) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (((s.heap.rep <- ([@expl:self.rep := {null}] M.add (! self) (singleton null) s.heap.rep));
         (s.heap.head <- ([@expl:self.head := null] M.add (! self) null s.heap.head));
         (s.heap.contents <- ([@expl:self.contents := nil] M.add (! self) STACK.nil s.heap.contents));
         (s.heap.size <- ([@expl:self.size := 0] M.add (! self) 0 s.heap.size));
         (s.pool <- ([@expl:pool := pool union {self}] Rgn.union s.pool (singleton (! self))));
         (! result))))
  
  let isEmpty (s: state) (self: reference) : bool
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result <-> ((s.heap.size[self]) = 0) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref false in
      (let self = ref self in
       (let sz = ref 0 in
        (((assert {
             ((Rgn.mem (! self) ((singleton (! self)) at INIT)) \/
                ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
               true });
          (sz := ([@expl:sz := self.size] s.heap.size[! self]));
          (result := ([@expl:result := sz = 0] (! sz) = 0));
          (! result)))))
  
  let push (s: state) (self: reference) (k: int) : unit
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz < s.maxSize }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.alloct }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { result = () }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head] wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr] wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`car]
              wrs_to_car_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep] wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { [@expl:wr ({self} union {self}`rep)`top] wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size] wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (s.heap.rep[self])) }
    ensures { [@expl:wr ({} union {self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union (singleton self) (s.heap.rep[self]))) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz + 1) }
    ensures { let xs = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.cons k xs) }
    ensures { let oa = old s.alloct.M.domain in
              Rgn.subset (Rgn.diff s.alloct.M.domain oa) (s.heap.rep[self]) }
    ensures { let oa = old s.alloct.M.domain in
              let orep = old (s.heap.rep[self]) in
              Rgn.subset (s.heap.rep[self]) (Rgn.union orep (Rgn.diff s.alloct.M.domain oa)) }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (let v = ref null in
         (((assert { hasCellType s (! v) });
           (let n = ref null in
            (((assert { hasNodeType s (! n) });
              (let tmp = ref null in
               (((assert { hasNodeType s (! tmp) });
                 (let sz = ref 0 in
                  (let ghost rep1 = ref emptyRgn in
                   (((assert { isValidRgn s (! rep1) });
                     (let ghost contents2 = ref (any intList) in
                      (((v := ([@expl:v := new Cell] mk_Cell s));
                        (assert { not (Rgn.mem (! v) (Rgn.union s.pool (img_rep s s.pool))) });
                        (assert {
                           ((Rgn.mem (! v) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! v) (s.alloct.M.domain at INIT))) \/ ((! v) = null))) /\
                             true });
                        ([@expl:Cell(v,k)] STACK.CELL.init_Cell s (! v) (! k));
                        (n := ([@expl:n := new Node] mk_Node s));
                        (s.heap.car <- ([@expl:n.car := v] M.add (! n) (! v) s.heap.car));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                        (assert { let rep3 = s.heap.rep[! self] in
                                  Rgn.mem (! tmp) rep3 });
                        (s.heap.cdr <- ([@expl:n.cdr := tmp] M.add (! n) (! tmp) s.heap.cdr));
                        (assert {
                           let rep4 = s.heap.rep[! self] in
                           forall n5: reference.
                             (isAllocated s n5) ->
                               ((hasNodeType s n5) -> ((Rgn.mem n5 rep4) -> (let c = s.heap.car[n5] in
                                                                    Rgn.mem c rep4))) });
                        (s.heap.head <- ([@expl:self.head := n] M.add (! self) (! n) s.heap.head));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                        (s.heap.size <- ([@expl:self.size := sz + 1] M.add (! self) ((! sz) + 1) s.heap.size));
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (rep1 := ([@expl:rep := self.rep] s.heap.rep[! self]));
                        (s.heap.rep <-
                           ([@expl:self.rep := rep union {v} union {n}]
                            M.add (! self) (Rgn.union (Rgn.union (! rep1) (singleton (! v))) (singleton (! n))) s.heap.rep));
                        (assert {
                           let h = s.heap.head[! self] in
                           let n6 = s.heap.cdr[h] in
                           let rep7 = s.heap.rep[! self] in
                           Rgn.mem n6 rep7 });
                        (assert { let rep8 = s.heap.rep[! self] in
                                  Rgn.subset (img_cdr s rep8) rep8 });
                        (assert {
                           let h = s.heap.head[! self] in
                           let c = s.heap.cdr[h] in
                           let rep9 = s.heap.rep[! self] in
                           Rgn.mem c rep9 });
                        (assert {
                           let rep10 = s.heap.rep[! self] in
                           forall n11: reference.
                             (isAllocated s n11) ->
                               ((hasNodeType s n11) -> ((Rgn.mem n11 rep10) -> (let c = s.heap.car[n11] in
                                                                    Rgn.mem c rep10))) });
                        (assert {
                           ((Rgn.mem (! self) ((Rgn.union (singleton (! self)) (s.heap.rep[! self])) at INIT)) \/
                              ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                             true });
                        (contents2 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                        (s.heap.contents <-
                           ([@expl:self.contents := cons(k,contents)] M.add (! self) (STACK.cons (! k) (! contents2)) s.heap.contents));
                        (assert { let h = s.heap.head[! self] in
                                  let stk = s.heap.contents[! self] in
                                  stackRep s stk h });
                        (! result)))))))))))))))))))
  
  let pop (s: state) (self: reference) : reference
    requires { hasStackType s self }
    requires { self <> null }
    requires { Rgn.mem self s.pool }
    requires { let sz = s.heap.size[self] in
               sz > 0 }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.size }
    ensures { result <> null }
    ensures { hasCellType s result }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`length]
              wrs_to_length_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`size]
              wrs_to_size_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`top]
              wrs_to_top_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`car]
              wrs_to_car_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`arr]
              wrs_to_arr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`head]
              wrs_to_head_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`slots]
              wrs_to_slots_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { [@expl:wr ({self} union {self}`rep union {result})`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union (singleton self) (Rgn.union (s.heap.rep[self]) (singleton result))) }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { let osz = old (s.heap.size[self]) in
              (s.heap.size[self]) = (osz - 1) }
    ensures { let oxs = old (s.heap.contents[self]) in
              let t = STACK.hd oxs in
              (s.heap.cell_value[result]) = t }
    ensures { let ostk = old (s.heap.contents[self]) in
              (s.heap.contents[self]) = (STACK.tl ostk) }
    ensures { let rep1 = s.heap.rep[self] in
              Rgn.mem result rep1 }
    ensures { let rep2 = old (s.heap.rep[self]) in
              (s.heap.rep[self]) = rep2 }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref null in
      (let self = ref self in
       (let tmp = ref null in
        (((assert { hasNodeType s (! tmp) });
          (let nxt = ref null in
           (((assert { hasNodeType s (! nxt) });
             (let sz = ref 0 in
              (let ghost contents3 = ref (any intList) in
               (((assert { let stk = s.heap.contents[! self] in
                           exists h: int, t: intList. stk = (STACK.cons h t) });
                 (assert {
                    ((Rgn.mem
                         (! self)
                         ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (tmp := ([@expl:tmp := self.head] s.heap.head[! self]));
                 (assert { (! tmp) <> null });
                 (assert {
                    ((Rgn.mem
                         (! tmp)
                         ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                       ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                      true });
                 (result := ([@expl:result := tmp.car] s.heap.car[! tmp]));
                 (assert {
                    ((Rgn.mem
                         (! tmp)
                         ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                       ((not (Rgn.mem (! tmp) (s.alloct.M.domain at INIT))) \/ ((! tmp) = null))) /\
                      true });
                 (nxt := ([@expl:nxt := tmp.cdr] s.heap.cdr[! tmp]));
                 (s.heap.head <- ([@expl:self.head := nxt] M.add (! self) (! nxt) s.heap.head));
                 (assert {
                    ((Rgn.mem
                         (! self)
                         ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (sz := ([@expl:sz := self.size] s.heap.size[! self]));
                 (s.heap.size <- ([@expl:self.size := sz - 1] M.add (! self) ((! sz) - 1) s.heap.size));
                 (assert {
                    ((Rgn.mem
                         (! self)
                         ((Rgn.union (singleton (! self)) (Rgn.union (s.heap.rep[! self]) (singleton (! result)))) at INIT)) \/
                       ((not (Rgn.mem (! self) (s.alloct.M.domain at INIT))) \/ ((! self) = null))) /\
                      true });
                 (contents3 := ([@expl:contents := self.contents] s.heap.contents[! self]));
                 (s.heap.contents <- ([@expl:self.contents := tl(contents)] M.add (! self) (STACK.tl (! contents3)) s.heap.contents));
                 (! result))))))))))))
  
  let getMaxSize (s: state) : int
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { result = s.maxSize }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in let result = ref 0 in
                  (((result := ([@expl:result := maxSize] s.maxSize));
                    (! result)))
  
  let getCellValue (s: state) (c: reference) : int
    requires { hasCellType s c }
    requires { c <> null }
    requires { STACK.stackPub s }
    requires { listStackPriv s }
    ensures { let bsnap_r13 = old (Rgn.union s.pool (img_rep s s.pool)) in
              Rgn.subset bsnap_r13 (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { (s.heap.cell_value[c]) = result }
    ensures { STACK.stackPub s }
    ensures { listStackPriv s } =
    label INIT in
      let result = ref 0 in
      (let c = ref c in
       (((assert {
            ((Rgn.mem (! c) ((singleton (! c)) at INIT)) \/ ((not (Rgn.mem (! c) (s.alloct.M.domain at INIT))) \/ ((! c) = null))) /\
              true });
         (result := ([@expl:result := c.cell_value] s.heap.cell_value[! c]));
         (! result))))
  
  lemma boundary_frames_invariant_ListStack : forall s: state, t: state, pi: 
                                                PreRefperm.t.
                                                (okRefperm s t pi) ->
                                                  ((PreRefperm.identity pi s.alloct.M.domain t.alloct.M.domain) ->
                                                     ((s.maxSize = t.maxSize) ->
                                                        ((PreRefperm.idRgn pi s.pool t.pool) ->
                                                           ((agree_allfields s t pi (Rgn.union s.pool (img_rep s s.pool))) ->
                                                              ((listStackPriv s) -> (listStackPriv t))))))
end

module Client2
  
  use prelude.Prelude
  use State
  use CLIENT
  use ListStack
  
  let prog (s: state) (n: int) : int
    requires { (s.maxSize > n) /\ (n >= 0) }
    requires { s.pool = emptyRgn }
    writes { s.alloct }
    writes { s.pool }
    writes { s.heap.arr }
    writes { s.heap.car }
    writes { s.heap.cdr }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    writes { s.heap.contents }
    writes { s.heap.head }
    writes { s.heap.length }
    writes { s.heap.rep }
    writes { s.heap.size }
    writes { s.heap.slots }
    writes { s.heap.top }
    ensures { alloc_does_not_shrink (old s) s }
    ensures { [@expl:wr ({} union pool union pool`rep)`contents]
              wrs_to_contents_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`head]
              wrs_to_head_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`cdr]
              wrs_to_cdr_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`arr]
              wrs_to_arr_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`car]
              wrs_to_car_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`rep]
              wrs_to_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`top]
              wrs_to_top_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr ({} union pool union pool`rep)`size]
              wrs_to_size_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old s) s (Rgn.union s.pool (img_rep s s.pool)) }
    ensures { [@expl:wr ({} union pool union pool`rep)`cell_value]
              wrs_to_cell_value_framed_by (old s) s (Rgn.union emptyRgn (Rgn.union s.pool (img_rep s s.pool))) } diverges =
    label INIT in
      let result = ref 0 in
      (let n = ref n in
       (let stk = ref null in
        (((assert { hasStackType s (! stk) });
          (let i = ref 0 in
           (let c1 = ref null in
            (((assert { hasCellType s (! c1) });
              (stk := ([@expl:stk := new Stack] mk_Stack s));
              (assert {
                 ((Rgn.mem (! stk) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                    ((not (Rgn.mem (! stk) (s.alloct.M.domain at INIT))) \/ ((! stk) = null))) /\
                   true });
              ([@expl:Stack(stk)] ListStack.init_Stack s (! stk));
              (while (! i) < (! n) do
                 invariant { [@expl:locals type invariant] (hasCellType s (! c1)) /\ (hasStackType s (! stk)) }
                 invariant { alloc_does_not_shrink (old s) s }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`contents]
                   wrs_to_contents_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`slots]
                   wrs_to_slots_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`head]
                   wrs_to_head_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cdr]
                   wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`arr]
                   wrs_to_arr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`car]
                   wrs_to_car_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`rep]
                   wrs_to_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                   wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`top]
                   wrs_to_top_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`size]
                   wrs_to_size_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`length]
                   wrs_to_length_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_value]
                   wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant { (0 <= (! i)) /\ ((! i) <= (! n)) }
                 invariant { (Rgn.mem (! stk) s.pool) /\ ((0 <= (! n)) /\ ((! n) < s.maxSize)) }
                 invariant { let sz = s.heap.size[! stk] in
                             sz = (! i) }
                 invariant { (ListStack.STACK.stackPub s) /\ (ListStack.listStackPriv s) }
                 invariant {
                   let oa = old s.alloct.M.domain in
                   Rgn.subset
                      (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                      (Rgn.diff s.alloct.M.domain oa) }
                 ((assert {
                     (Rgn.subset
                         (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                         (Rgn.union
                             ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                             (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                       true });
                  ([@expl:push(stk,i)] ListStack.push s (! stk) (! i));
                  (i := ([@expl:i := i + 1] (! i) + 1)))
               done);
              (i := ([@expl:i := 0] 0));
              (while (! i) < (! n) do
                 invariant { [@expl:locals type invariant] (hasCellType s (! c1)) /\ (hasStackType s (! stk)) }
                 invariant { alloc_does_not_shrink (old s) s }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`contents]
                   wrs_to_contents_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`slots]
                   wrs_to_slots_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`head]
                   wrs_to_head_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cdr]
                   wrs_to_cdr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`arr]
                   wrs_to_arr_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`car]
                   wrs_to_car_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`rep]
                   wrs_to_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                   wrs_to_cell_rep_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`top]
                   wrs_to_top_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`size]
                   wrs_to_size_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`length]
                   wrs_to_length_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant {
                   [@expl:wr ({stk} union {stk}`rep)`cell_value]
                   wrs_to_cell_value_framed_by (old s) s (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) }
                 invariant { (0 <= (! i)) /\ ((! i) <= (! n)) }
                 invariant { (Rgn.mem (! stk) s.pool) /\ ((0 <= (! n)) /\ ((! n) < s.maxSize)) }
                 invariant { let sz = s.heap.size[! stk] in
                             sz = ((! n) - (! i)) }
                 invariant { (ListStack.STACK.stackPub s) /\ (ListStack.listStackPriv s) }
                 invariant { ((! c1) = null) \/ (let rep2 = s.heap.rep[! stk] in
                                                 Rgn.mem (! c1) rep2) }
                 invariant {
                   let oa = s.alloct.M.domain at INIT in
                   Rgn.subset
                      (Rgn.diff (Rgn.union (singleton (! stk)) (s.heap.rep[! stk])) (singleton null))
                      (Rgn.diff s.alloct.M.domain oa) }
                 ((assert {
                     (Rgn.subset
                         (Rgn.diff (Rgn.union (singleton (! stk)) (Rgn.union (s.heap.rep[! stk]) (singleton (! c1)))) (singleton null))
                         (Rgn.union
                             ((Rgn.union s.pool (img_rep s s.pool)) at INIT)
                             (Rgn.diff s.alloct.M.domain (s.alloct.M.domain at INIT)))) /\
                       true });
                  (c1 := ([@expl:c := pop(stk)] ListStack.pop s (! stk)));
                  (let v = ref 0 in
                   (((assert {
                        ((Rgn.mem (! c1) ((Rgn.union s.pool (img_rep s s.pool)) at INIT)) \/
                           ((not (Rgn.mem (! c1) (s.alloct.M.domain at INIT))) \/ ((! c1) = null))) /\
                          true });
                     (v := ([@expl:v := getCellValue(c)] ListStack.getCellValue s (! c1)));
                     (result := ([@expl:result := result + v] (! result) + (! v)));
                     (i := ([@expl:i := i + 1] (! i) + 1))))))
               done);
              (! result)))))))))
end

module REL_STACK_biinterface
  
  use prelude.Prelude
  use State
  use ArrayStack
  use ListStack
  use export stack_theory.Stack_theory
  
  val init_Stack (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (unit, unit)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { (agree_allfields l_s r_s pi (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (not (Rgn.mem l_self l_s.pool)) /\ (not (Rgn.mem r_self r_s.pool)) }
    writes { l_s.heap.head }
    writes { l_s.heap.rep }
    writes { l_s.heap.size }
    writes { l_s.heap.contents }
    writes { l_s.heap.top }
    writes { l_s.heap.arr }
    writes { l_s.heap.car }
    writes { l_s.heap.cdr }
    writes { l_s.heap.slots }
    writes { l_s.heap.length }
    writes { l_s.heap.cell_value }
    writes { l_s.heap.cell_rep }
    writes { l_s.alloct }
    writes { l_s.pool }
    writes { r_s.heap.head }
    writes { r_s.heap.rep }
    writes { r_s.heap.size }
    writes { r_s.heap.contents }
    writes { r_s.heap.top }
    writes { r_s.heap.arr }
    writes { r_s.heap.car }
    writes { r_s.heap.cdr }
    writes { r_s.heap.slots }
    writes { r_s.heap.length }
    writes { r_s.heap.cell_value }
    writes { r_s.heap.cell_rep }
    writes { r_s.alloct }
    writes { r_s.pool }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_self0 = old (singleton l_self) in
              let r_self0 = old (singleton r_self) in
              (agree_allfields
                 l_s
                 r_s
                 pi
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_self0) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_self0) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               Rgn.subset (Rgn.diff (l_s.heap.rep[l_self]) (singleton null)) (Rgn.diff l_s.alloct.M.domain oa)) /\
                (let oa = old r_s.alloct.M.domain in
                 Rgn.subset (Rgn.diff (r_s.heap.rep[r_self]) (singleton null)) (Rgn.diff r_s.alloct.M.domain oa)) }
    ensures { (let opool = old l_s.pool in
               l_s.pool = (Rgn.union opool (singleton l_self))) /\
                (let opool = old r_s.pool in
                 r_s.pool = (Rgn.union opool (singleton r_self))) }
    ensures { ((l_s.heap.contents[l_self]) = ArrayStack.STACK.nil) /\ ((r_s.heap.contents[r_self]) = ListStack.STACK.nil) }
    ensures { ((l_s.heap.size[l_self]) = 0) /\ ((r_s.heap.size[r_self]) = 0) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
  
  val isEmpty (l_s: state) (r_s: state) (pi3: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi3 }
    requires { true /\ true }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { PreRefperm.idRef pi3 l_self r_self }
    requires { (agree_allfields l_s r_s pi3 (singleton l_self)) /\ (agree_allfields r_s l_s (PreRefperm.invert pi3) (singleton r_self)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi3 }
    ensures { true /\ true }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields
                 l_s
                 r_s
                 pi3
                 (Rgn.diff (Rgn.diff l_s.alloct.M.domain l_s_alloc) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi3)
                   (Rgn.diff (Rgn.diff r_s.alloct.M.domain r_s_alloc) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((l_result <-> ((l_s.heap.size[l_self]) = 0)) /\ (r_result <-> ((r_s.heap.size[r_self]) = 0)))
              end }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
  
  val push (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { (agree_allfields
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (PreRefperm.idRef pi l_self r_self) /\ (l_k = r_k) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz < l_s.maxSize) /\ (let sz = r_s.heap.size[r_self] in
                                      sz < r_s.maxSize) }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.contents }
    writes { l_s.heap.slots }
    writes { l_s.heap.head }
    writes { l_s.heap.cdr }
    writes { l_s.heap.arr }
    writes { l_s.heap.car }
    writes { l_s.heap.rep }
    writes { l_s.heap.cell_rep }
    writes { l_s.heap.top }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.cell_value }
    writes { l_s.alloct }
    writes { r_s.heap.contents }
    writes { r_s.heap.slots }
    writes { r_s.heap.head }
    writes { r_s.heap.cdr }
    writes { r_s.heap.arr }
    writes { r_s.heap.car }
    writes { r_s.heap.rep }
    writes { r_s.heap.cell_rep }
    writes { r_s.heap.top }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.cell_value }
    writes { r_s.alloct }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_snap_r1 = old (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) in
              let r_snap_r1 = old (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) in
              (agree_allfields
                 l_s
                 r_s
                 pi
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_snap_r1) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_snap_r1) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               let orep = old (l_s.heap.rep[l_self]) in
               Rgn.subset (l_s.heap.rep[l_self]) (Rgn.union orep (Rgn.diff l_s.alloct.M.domain oa))) /\
                (let oa = old r_s.alloct.M.domain in
                 let orep = old (r_s.heap.rep[r_self]) in
                 Rgn.subset (r_s.heap.rep[r_self]) (Rgn.union orep (Rgn.diff r_s.alloct.M.domain oa))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               Rgn.subset (Rgn.diff l_s.alloct.M.domain oa) (l_s.heap.rep[l_self])) /\
                (let oa = old r_s.alloct.M.domain in
                 Rgn.subset (Rgn.diff r_s.alloct.M.domain oa) (r_s.heap.rep[r_self])) }
    ensures { (let xs = old (l_s.heap.contents[l_self]) in
               (l_s.heap.contents[l_self]) = (ArrayStack.STACK.cons l_k xs)) /\
                (let xs = old (r_s.heap.contents[r_self]) in
                 (r_s.heap.contents[r_self]) = (ListStack.STACK.cons r_k xs)) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end }
  
  val pop (l_s: state) (r_s: state) (pi4: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi4 }
    requires { true /\ true }
    requires { (agree_allfields
                  l_s
                  r_s
                  pi4
                  (Rgn.diff (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi4)
                    (Rgn.diff (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { PreRefperm.idRef pi4 l_self r_self }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.contents }
    writes { l_s.heap.slots }
    writes { l_s.heap.head }
    writes { l_s.heap.cdr }
    writes { l_s.heap.arr }
    writes { l_s.heap.car }
    writes { l_s.heap.rep }
    writes { l_s.heap.cell_rep }
    writes { l_s.heap.top }
    writes { l_s.heap.size }
    writes { l_s.heap.length }
    writes { l_s.heap.cell_value }
    writes { r_s.heap.contents }
    writes { r_s.heap.slots }
    writes { r_s.heap.head }
    writes { r_s.heap.cdr }
    writes { r_s.heap.arr }
    writes { r_s.heap.car }
    writes { r_s.heap.rep }
    writes { r_s.heap.cell_rep }
    writes { r_s.heap.top }
    writes { r_s.heap.size }
    writes { r_s.heap.length }
    writes { r_s.heap.cell_value }
    ensures { match result with | (l_result, _) -> (hasCellType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasCellType r_s r_result) end }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { okRefperm l_s r_s pi4 }
    ensures { true /\ true }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (let l_r = l_result in
                     let r_r = r_result in
                     let l_c = l_s.heap.cell_value[l_r] in
                     let r_c = r_s.heap.cell_value[r_r] in
                     l_c = r_c)
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_snap_r1 = old (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) in
              let r_snap_r1 = old (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) in
              (agree_allfields
                 l_s
                 r_s
                 pi4
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_snap_r1) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi4)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_snap_r1) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let rep5 = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = rep5) /\
                (let rep6 = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = rep6) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep7 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep7) /\
                       (let rep8 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep8))
              end }
    ensures { (let ostk = old (l_s.heap.contents[l_self]) in
               (l_s.heap.contents[l_self]) = (ArrayStack.STACK.tl ostk)) /\
                (let ostk = old (r_s.heap.contents[r_self]) in
                 (r_s.heap.contents[r_self]) = (ListStack.STACK.tl ostk)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let oxs = old (l_s.heap.contents[l_self]) in
                      let t = ArrayStack.STACK.hd oxs in
                      (l_s.heap.cell_value[l_result]) = t) /\
                       (let oxs = old (r_s.heap.contents[r_self]) in
                        let t = ListStack.STACK.hd oxs in
                        (r_s.heap.cell_value[r_result]) = t))
              end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end }
  
  val getCellValue (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_c: reference) (r_c: reference) : 
    (int, int)
    requires { hasCellType l_s l_c }
    requires { l_c <> null }
    requires { hasCellType r_s r_c }
    requires { r_c <> null }
    requires { okRefperm l_s r_s pi }
    requires { true /\ true }
    requires { let l_v = l_s.heap.cell_value[l_c] in
               let r_v = r_s.heap.cell_value[r_c] in
               l_v = r_v }
    ensures { okRefperm l_s r_s pi }
    ensures { true /\ true }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
end

module CLIENT_REL
  
  use prelude.Prelude
  use State
  use Client1
  use Client2
  use REL_STACK_biinterface
  
  let prog (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_n: int) (r_n: int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_s.pool = emptyRgn) /\ (r_s.pool = emptyRgn) }
    requires { ((l_s.maxSize > l_n) /\ (r_s.maxSize > r_n)) /\ (((l_n >= 0) /\ (r_n >= 0)) /\ (l_n = r_n)) }
    writes { pi }
    writes { l_s.alloct }
    writes { l_s.pool }
    writes { r_s.alloct }
    writes { r_s.pool }
    writes { l_s.heap.arr }
    writes { l_s.heap.car }
    writes { l_s.heap.cdr }
    writes { l_s.heap.cell_rep }
    writes { l_s.heap.cell_value }
    writes { l_s.heap.contents }
    writes { l_s.heap.head }
    writes { l_s.heap.length }
    writes { l_s.heap.rep }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { l_s.heap.top }
    writes { r_s.heap.arr }
    writes { r_s.heap.car }
    writes { r_s.heap.cdr }
    writes { r_s.heap.cell_rep }
    writes { r_s.heap.cell_value }
    writes { r_s.heap.contents }
    writes { r_s.heap.head }
    writes { r_s.heap.length }
    writes { r_s.heap.rep }
    writes { r_s.heap.size }
    writes { r_s.heap.slots }
    writes { r_s.heap.top }
    ensures { [@expl:wr (pool union pool`rep union {})`contents]
              wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep)`cdr] wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep union {})`arr]
              wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep)`car] wrs_to_car_framed_by (old l_s) l_s (Rgn.union l_s.pool (img_rep l_s l_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep union {})`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`cell_rep]
              wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`top]
              wrs_to_top_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`cell_value]
              wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (Rgn.union l_s.pool (img_rep l_s l_s.pool)) emptyRgn) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr (pool union pool`rep union {})`contents]
              wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep)`slots] wrs_to_slots_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep union {})`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`cdr]
              wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`arr]
              wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`car]
              wrs_to_car_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`cell_rep]
              wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`top]
              wrs_to_top_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep union {})`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { [@expl:wr (pool union pool`rep)`length] wrs_to_length_framed_by (old r_s) r_s (Rgn.union r_s.pool (img_rep r_s r_s.pool)) }
    ensures { [@expl:wr (pool union pool`rep union {})`cell_value]
              wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (Rgn.union r_s.pool (img_rep r_s r_s.pool)) emptyRgn) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end } diverges =
    label INIT in
      let l_result = ref 0 in
      (let r_result = ref 0 in
       (let l_n = ref l_n in
        (let r_n = ref r_n in
         (let l_stk = ref null in
          (let r_stk = ref null in
           (let l_i = ref 0 in
            (let r_i = ref 0 in
             (let l_c = ref null in
              (let r_c = ref null in
               (((((l_stk := ([@expl:stk := new Stack] mk_Stack l_s));
                   (r_stk := ([@expl:stk := new Stack] mk_Stack r_s))));
                 (PreRefperm.updateRefperm pi (! l_stk) (! r_stk));
                 (match [@expl:Stack(stk)] REL_STACK_biinterface.init_Stack l_s r_s pi (! l_stk) (! r_stk) with | _ -> () end);
                 (while (! l_i) < (! l_n) do
                    invariant { [@expl:locals type invariant left] (hasCellType l_s (! l_c)) /\ (hasStackType l_s (! l_stk)) }
                    invariant { [@expl:locals type invariant right] (hasCellType r_s (! r_c)) /\ (hasStackType r_s (! r_stk)) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`contents]
                      wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`slots]
                      wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`head]
                      wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cdr]
                      wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`arr]
                      wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`car]
                      wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`rep]
                      wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                      wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`top]
                      wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`size]
                      wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`length]
                      wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_value]
                      wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant { alloc_does_not_shrink (old l_s) l_s }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`contents]
                      wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`slots]
                      wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`head]
                      wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cdr]
                      wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`arr]
                      wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`car]
                      wrs_to_car_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`rep]
                      wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                      wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`top]
                      wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`size]
                      wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`length]
                      wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_value]
                      wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant { alloc_does_not_shrink (old r_s) r_s }
                    invariant { okRefperm l_s r_s pi }
                    invariant {
                      ((0 <= (! l_i)) /\ (0 <= (! r_i))) /\
                        ((((! l_i) <= (! l_n)) /\ ((! r_i) <= (! r_n))) /\
                           ((Rgn.mem (! l_stk) l_s.pool) /\ (Rgn.mem (! r_stk) r_s.pool))) }
                    invariant {
                      ((! l_i) = (! r_i)) /\
                        (((! l_n) = (! r_n)) /\
                           (((0 <= (! l_n)) /\ (0 <= (! r_n))) /\ (((! l_n) < l_s.maxSize) /\ ((! r_n) < r_s.maxSize)))) }
                    invariant { let l_xs = l_s.heap.contents[! l_stk] in
                                let r_xs = r_s.heap.contents[! r_stk] in
                                l_xs = r_xs }
                    invariant {
                      (let sz = l_s.heap.size[! l_stk] in
                       sz = (! l_i)) /\ (let sz = r_s.heap.size[! r_stk] in
                                         sz = (! r_i)) }
                    invariant { (Client1.ArrayStack.STACK.stackPub l_s) /\ (Client2.ListStack.STACK.stackPub r_s) }
                    invariant {
                      (let oa = old l_s.alloct.M.domain in
                       Rgn.subset
                          (Rgn.diff (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) (singleton null))
                          (Rgn.diff l_s.alloct.M.domain oa)) /\
                        (let oa = old r_s.alloct.M.domain in
                         Rgn.subset
                            (Rgn.diff (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) (singleton null))
                            (Rgn.diff r_s.alloct.M.domain oa)) }
                    invariant { [@expl:lockstep] ((! l_i) < (! l_n)) = ((! r_i) < (! r_n)) }
                    ((match [@expl:push(stk,i)] REL_STACK_biinterface.push l_s r_s pi (! l_stk) (! l_i) (! r_stk) (! r_i)
                      with | _ -> () end);
                     (l_i := ([@expl:i := i + 1] (! l_i) + 1));
                     (r_i := ([@expl:i := i + 1] (! r_i) + 1)))
                  done);
                 (((l_i := ([@expl:i := 0] 0));
                   (r_i := ([@expl:i := 0] 0))));
                 (assert { (! l_result) = (! r_result) });
                 (while (! l_i) < (! l_n) do
                    invariant { [@expl:locals type invariant left] (hasCellType l_s (! l_c)) /\ (hasStackType l_s (! l_stk)) }
                    invariant { [@expl:locals type invariant right] (hasCellType r_s (! r_c)) /\ (hasStackType r_s (! r_stk)) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`contents]
                      wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`slots]
                      wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`head]
                      wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cdr]
                      wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`arr]
                      wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`car]
                      wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`rep]
                      wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                      wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`top]
                      wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`size]
                      wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`length]
                      wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_value]
                      wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`contents]
                      wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`slots]
                      wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`head]
                      wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cdr]
                      wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`arr]
                      wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`car]
                      wrs_to_car_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`rep]
                      wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_rep]
                      wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`top]
                      wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`size]
                      wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`length]
                      wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant {
                      [@expl:wr ({stk} union {stk}`rep)`cell_value]
                      wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) }
                    invariant { okRefperm l_s r_s pi }
                    invariant { ((0 <= (! l_i)) /\ (0 <= (! r_i))) /\ (((! l_i) <= (! l_n)) /\ ((! r_i) <= (! r_n))) }
                    invariant { ((! l_i) = (! r_i)) /\ ((! l_n) = (! r_n)) }
                    invariant {
                      ((Rgn.mem (! l_stk) l_s.pool) /\ (Rgn.mem (! r_stk) r_s.pool)) /\
                        (((0 <= (! l_n)) /\ (0 <= (! r_n))) /\ (((! l_n) < l_s.maxSize) /\ ((! r_n) < r_s.maxSize))) }
                    invariant {
                      (let sz = l_s.heap.size[! l_stk] in
                       sz = ((! l_n) - (! l_i))) /\
                        (let sz = r_s.heap.size[! r_stk] in
                         sz = ((! r_n) - (! r_i))) }
                    invariant {
                      (((! l_c) = null) \/ (let rep9 = l_s.heap.rep[! l_stk] in
                                            Rgn.mem (! l_c) rep9)) /\
                        (((! r_c) = null) \/ (let rep10 = r_s.heap.rep[! r_stk] in
                                              Rgn.mem (! r_c) rep10)) }
                    invariant { (Client1.ArrayStack.STACK.stackPub l_s) /\ (Client2.ListStack.STACK.stackPub r_s) }
                    invariant { let l_xs = l_s.heap.contents[! l_stk] in
                                let r_xs = r_s.heap.contents[! r_stk] in
                                l_xs = r_xs }
                    invariant { (! l_result) = (! r_result) }
                    invariant {
                      (let oa = l_s.alloct.M.domain at INIT in
                       Rgn.subset
                          (Rgn.diff (Rgn.union (singleton (! l_stk)) (l_s.heap.rep[! l_stk])) (singleton null))
                          (Rgn.diff l_s.alloct.M.domain oa)) /\
                        (let oa = r_s.alloct.M.domain at INIT in
                         Rgn.subset
                            (Rgn.diff (Rgn.union (singleton (! r_stk)) (r_s.heap.rep[! r_stk])) (singleton null))
                            (Rgn.diff r_s.alloct.M.domain oa)) }
                    invariant { [@expl:lockstep] ((! l_i) < (! l_n)) = ((! r_i) < (! r_n)) }
                    ((match REL_STACK_biinterface.pop l_s r_s pi (! l_stk) (! r_stk)
                      with
                        | (l_pop_res, r_pop_res) ->
                            (((l_c := ([@expl:c := pop(stk)] l_pop_res));
                              (r_c := ([@expl:c := pop(stk)] r_pop_res))))
                      end);
                     (let l_v = ref 0 in
                      (let r_v = ref 0 in
                       (((match REL_STACK_biinterface.getCellValue l_s r_s pi (! l_c) (! r_c)
                          with
                            | (l_getCellValue_res, r_getCellValue_res) ->
                                (((l_v := ([@expl:v := getCellValue(c)] l_getCellValue_res));
                                  (r_v := ([@expl:v := getCellValue(c)] r_getCellValue_res))))
                          end);
                         (((l_result := ([@expl:result := result + v] (! l_result) + (! l_v)));
                           (r_result := ([@expl:result := result + v] (! r_result) + (! r_v)))));
                         (l_i := ([@expl:i := i + 1] (! l_i) + 1));
                         (r_i := ([@expl:i := i + 1] (! r_i) + 1)))))))
                  done);
                 (! l_result, ! r_result))))))))))))
end

module REL_STACK
  
  use prelude.Prelude
  use State
  use ArrayStack
  use ListStack
  use export stack_theory.Stack_theory
  
  predicate stackCoupling (l_s: state) (r_s: state) (pi: PreRefperm.t) =
    (okRefperm l_s r_s pi) ->
      (((ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s)) /\
         ((ArrayStack.arrayStackPriv l_s) /\
            ((ListStack.listStackPriv r_s) /\
               ((l_s.maxSize = r_s.maxSize) /\
                  ((PreRefperm.idRgn pi l_s.pool r_s.pool) /\
                     (forall l_s11: reference, r_s12: reference.
                        (isAllocated l_s l_s11) ->
                          ((hasStackType l_s l_s11) ->
                             ((Rgn.mem l_s11 l_s.pool) ->
                                ((isAllocated r_s r_s12) ->
                                   ((hasStackType r_s r_s12) ->
                                      ((Rgn.mem r_s12 r_s.pool) ->
                                         ((PreRefperm.idRef pi l_s11 r_s12) ->
                                            (let l_stk = l_s.heap.contents[l_s11] in
                                             let r_stk = r_s.heap.contents[r_s12] in
                                             l_stk = r_stk)))))))))))))
  
  let init_Stack (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (unit, unit)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { stackCoupling l_s r_s pi }
    requires { (agree_allfields l_s r_s pi (Rgn.diff (singleton l_self) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (singleton r_self) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { PreRefperm.idRef pi l_self r_self }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (not (Rgn.mem l_self l_s.pool)) /\ (not (Rgn.mem r_self r_s.pool)) }
    writes { l_s.alloct }
    writes { l_s.pool }
    writes { r_s.pool }
    writes { l_s.heap.arr }
    writes { l_s.heap.contents }
    writes { l_s.heap.length }
    writes { l_s.heap.rep }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { l_s.heap.top }
    writes { r_s.heap.contents }
    writes { r_s.heap.head }
    writes { r_s.heap.rep }
    writes { r_s.heap.size }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr ({self} union {})`slots] wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) emptyRgn) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old l_s) l_s (singleton l_self) }
    ensures { [@expl:wr ({self} union {})`length] wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) emptyRgn) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old l_s) l_s (singleton l_self) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old r_s) r_s (singleton r_self) }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old r_s) r_s (singleton r_self) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { stackCoupling l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_self0 = old (singleton l_self) in
              let r_self0 = old (singleton r_self) in
              (agree_allfields
                 l_s
                 r_s
                 pi
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_self0) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_self0) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               Rgn.subset (Rgn.diff (l_s.heap.rep[l_self]) (singleton null)) (Rgn.diff l_s.alloct.M.domain oa)) /\
                (let oa = old r_s.alloct.M.domain in
                 Rgn.subset (Rgn.diff (r_s.heap.rep[r_self]) (singleton null)) (Rgn.diff r_s.alloct.M.domain oa)) }
    ensures { (let opool = old l_s.pool in
               l_s.pool = (Rgn.union opool (singleton l_self))) /\
                (let opool = old r_s.pool in
                 r_s.pool = (Rgn.union opool (singleton r_self))) }
    ensures { ((l_s.heap.contents[l_self]) = ArrayStack.STACK.nil) /\ ((r_s.heap.contents[r_self]) = ListStack.STACK.nil) }
    ensures { ((l_s.heap.size[l_self]) = 0) /\ ((r_s.heap.size[r_self]) = 0) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    label INIT in
      let l_result = ref () in
      (let r_result = ref () in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let l_arr = ref null in
          (let ghost l_rep = ref emptyRgn in
           (((((l_s.heap.rep <- ([@expl:self.rep := {}] M.add (! l_self) emptyRgn l_s.heap.rep));
               (r_s.heap.rep <- ([@expl:self.rep := {null}] M.add (! r_self) (singleton null) r_s.heap.rep));
               (r_s.heap.head <- ([@expl:self.head := null] M.add (! r_self) null r_s.heap.head))));
             (((l_s.heap.contents <- ([@expl:self.contents := nil] M.add (! l_self) ArrayStack.STACK.nil l_s.heap.contents));
               (r_s.heap.contents <- ([@expl:self.contents := nil] M.add (! r_self) ListStack.STACK.nil r_s.heap.contents))));
             (assert { let l_stk = l_s.heap.contents[! l_self] in
                       let r_stk = r_s.heap.contents[! r_self] in
                       l_stk = r_stk });
             (((l_s.heap.size <- ([@expl:self.size := 0] M.add (! l_self) 0 l_s.heap.size));
               (r_s.heap.size <- ([@expl:self.size := 0] M.add (! r_self) 0 r_s.heap.size))));
             (((((l_s.heap.top <- ([@expl:self.top := - 1] M.add (! l_self) (0 - 1) l_s.heap.top));
                 (((l_arr := ([@expl:arr := new(CellArray){maxSize}] mk_CellArray l_s));
                   (l_s.heap.length <- ([@expl:arr := new(CellArray){maxSize}] M.add (! l_arr) l_s.maxSize l_s.heap.length));
                   (l_s.heap.slots <- ([@expl:arr := new(CellArray){maxSize}] M.add (! l_arr) (A.make l_s.maxSize null) l_s.heap.slots))));
                 (l_s.heap.arr <- ([@expl:self.arr := arr] M.add (! l_self) (! l_arr) l_s.heap.arr));
                 (l_rep := ([@expl:rep := self.rep] l_s.heap.rep[! l_self]));
                 (l_s.heap.rep <-
                    ([@expl:self.rep := rep union {arr}] M.add (! l_self) (Rgn.union (! l_rep) (singleton (! l_arr))) l_s.heap.rep))));
               ()));
             (((l_s.pool <- ([@expl:pool := pool union {self}] Rgn.union l_s.pool (singleton (! l_self))));
               (r_s.pool <- ([@expl:pool := pool union {self}] Rgn.union r_s.pool (singleton (! r_self))))));
             (assume {
                ((ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s)) /\
                  ((ArrayStack.arrayStackPriv l_s) /\ (ListStack.listStackPriv r_s)) });
             (assume {
                (let oa = old l_s.alloct.M.domain in
                 Rgn.subset (Rgn.diff (l_s.heap.rep[! l_self]) (singleton null)) (Rgn.diff l_s.alloct.M.domain oa)) /\
                  (let oa = old r_s.alloct.M.domain in
                   Rgn.subset (Rgn.diff (r_s.heap.rep[! r_self]) (singleton null)) (Rgn.diff r_s.alloct.M.domain oa)) });
             (! l_result, ! r_result))))))))
  
  let isEmpty (l_s: state) (r_s: state) (pi13: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (bool, bool)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi13 }
    requires { stackCoupling l_s r_s pi13 }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { PreRefperm.idRef pi13 l_self r_self }
    requires { (agree_allfields l_s r_s pi13 (singleton l_self)) /\
                 (agree_allfields r_s l_s (PreRefperm.invert pi13) (singleton r_self)) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    ensures { okRefperm l_s r_s pi13 }
    ensures { stackCoupling l_s r_s pi13 }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              (agree_allfields
                 l_s
                 r_s
                 pi13
                 (Rgn.diff (Rgn.diff l_s.alloct.M.domain l_s_alloc) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi13)
                   (Rgn.diff (Rgn.diff r_s.alloct.M.domain r_s_alloc) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((l_result <-> ((l_s.heap.size[l_self]) = 0)) /\ (r_result <-> ((r_s.heap.size[r_self]) = 0)))
              end }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) } =
    label INIT in
      let l_result = ref false in
      (let r_result = ref false in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let l_sz = ref 0 in
          (let r_sz = ref 0 in
           (((((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
               (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
             (l_result := ([@expl:result := sz = 0] (! l_sz) = 0));
             (r_result := ([@expl:result := sz = 0] (! r_sz) = 0));
             (! l_result, ! r_result))))))))
  
  let push (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { stackCoupling l_s r_s pi }
    requires { (agree_allfields
                  l_s
                  r_s
                  pi
                  (Rgn.diff (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi)
                    (Rgn.diff (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { (PreRefperm.idRef pi l_self r_self) /\ (l_k = r_k) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz < l_s.maxSize) /\ (let sz = r_s.heap.size[r_self] in
                                      sz < r_s.maxSize) }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { pi }
    writes { l_s.alloct }
    writes { r_s.alloct }
    writes { l_s.heap.arr }
    writes { l_s.heap.cell_rep }
    writes { l_s.heap.cell_value }
    writes { l_s.heap.contents }
    writes { l_s.heap.rep }
    writes { l_s.heap.size }
    writes { l_s.heap.slots }
    writes { l_s.heap.top }
    writes { r_s.heap.arr }
    writes { r_s.heap.car }
    writes { r_s.heap.cdr }
    writes { r_s.heap.cell_rep }
    writes { r_s.heap.cell_value }
    writes { r_s.heap.contents }
    writes { r_s.heap.head }
    writes { r_s.heap.length }
    writes { r_s.heap.rep }
    writes { r_s.heap.size }
    writes { r_s.heap.slots }
    writes { r_s.heap.top }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`cell_rep]
              wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`cell_value]
              wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) emptyRgn) }
    ensures { alloc_does_not_shrink (old l_s) l_s }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`cdr]
              wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`car]
              wrs_to_car_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`cell_rep]
              wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep union {})`cell_value]
              wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) emptyRgn) }
    ensures { alloc_does_not_shrink (old r_s) r_s }
    ensures { okRefperm l_s r_s pi }
    ensures { stackCoupling l_s r_s pi }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_snap_r1 = old (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) in
              let r_snap_r1 = old (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) in
              (agree_allfields
                 l_s
                 r_s
                 pi
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_snap_r1) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_snap_r1) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               let orep = old (l_s.heap.rep[l_self]) in
               Rgn.subset (l_s.heap.rep[l_self]) (Rgn.union orep (Rgn.diff l_s.alloct.M.domain oa))) /\
                (let oa = old r_s.alloct.M.domain in
                 let orep = old (r_s.heap.rep[r_self]) in
                 Rgn.subset (r_s.heap.rep[r_self]) (Rgn.union orep (Rgn.diff r_s.alloct.M.domain oa))) }
    ensures { (let oa = old l_s.alloct.M.domain in
               Rgn.subset (Rgn.diff l_s.alloct.M.domain oa) (l_s.heap.rep[l_self])) /\
                (let oa = old r_s.alloct.M.domain in
                 Rgn.subset (Rgn.diff r_s.alloct.M.domain oa) (r_s.heap.rep[r_self])) }
    ensures { (let xs = old (l_s.heap.contents[l_self]) in
               (l_s.heap.contents[l_self]) = (ArrayStack.STACK.cons l_k xs)) /\
                (let xs = old (r_s.heap.contents[r_self]) in
                 (r_s.heap.contents[r_self]) = (ListStack.STACK.cons r_k xs)) }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz + 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz + 1)) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    label INIT in
      let l_result = ref () in
      (let r_result = ref () in
       (let l_self = ref l_self in
        (let l_k = ref l_k in
         (let r_self = ref r_self in
          (let r_k = ref r_k in
           (let l_a = ref null in
            (let l_t = ref 0 in
             (let l_v = ref null in
              (let r_v = ref null in
               (let r_n = ref null in
                (let r_tmp = ref null in
                 (let l_sz = ref 0 in
                  (let r_sz = ref 0 in
                   (let ghost l_rep = ref emptyRgn in
                    (let ghost r_rep = ref emptyRgn in
                     (let ghost l_contents = ref (any intList) in
                      (let ghost r_contents = ref (any intList) in
                       (((((((l_a := ([@expl:a := self.arr] l_s.heap.arr[! l_self]));
                             (l_t := ([@expl:t := self.top] l_s.heap.top[! l_self]));
                             (l_s.heap.top <- ([@expl:self.top := t + 1] M.add (! l_self) ((! l_t) + 1) l_s.heap.top))));
                           ()));
                         (((l_v := ([@expl:v := new Cell] mk_Cell l_s));
                           (r_v := ([@expl:v := new Cell] mk_Cell r_s))));
                         (PreRefperm.updateRefperm pi (! l_v) (! r_v));
                         (((((l_s.heap.cell_value <- ([@expl:v.cell_value := k] M.add (! l_v) (! l_k) l_s.heap.cell_value));
                             (l_s.heap.cell_rep <- ([@expl:v.cell_rep := {v}] M.add (! l_v) (singleton (! l_v)) l_s.heap.cell_rep))));
                           ([@expl:Cell(v,k)] ListStack.STACK.CELL.init_Cell r_s (! r_v) (! r_k))));
                         (((((l_s.heap.slots <-
                                ([@expl:a.{t + 1} := v]
                                 M.add (! l_a) (A.set (l_s.heap.slots[! l_a]) ((! l_t) + 1) (! l_v)) l_s.heap.slots));
                             (l_s.heap.arr <- ([@expl:self.arr := a] M.add (! l_self) (! l_a) l_s.heap.arr))));
                           ()));
                         ((();
                           (r_n := ([@expl:n := new Node] mk_Node r_s));
                           (r_s.heap.car <- ([@expl:n.car := v] M.add (! r_n) (! r_v) r_s.heap.car));
                           (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]));
                           (r_s.heap.cdr <- ([@expl:n.cdr := tmp] M.add (! r_n) (! r_tmp) r_s.heap.cdr));
                           (r_s.heap.head <- ([@expl:self.head := n] M.add (! r_self) (! r_n) r_s.heap.head))));
                         (((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                           (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                         (((l_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! l_self) ((! l_sz) + 1) l_s.heap.size));
                           (r_s.heap.size <- ([@expl:self.size := sz + 1] M.add (! r_self) ((! r_sz) + 1) r_s.heap.size))));
                         (((l_rep := ([@expl:rep := self.rep] l_s.heap.rep[! l_self]));
                           (r_rep := ([@expl:rep := self.rep] r_s.heap.rep[! r_self]))));
                         (((l_s.heap.rep <-
                              ([@expl:self.rep := rep union {v}]
                               M.add (! l_self) (Rgn.union (! l_rep) (singleton (! l_v))) l_s.heap.rep));
                           (r_s.heap.rep <-
                              ([@expl:self.rep := rep union {v} union {n}]
                               M.add (! r_self) (Rgn.union (Rgn.union (! r_rep) (singleton (! r_v))) (singleton (! r_n))) r_s.heap.rep))));
                         (((l_contents := ([@expl:contents := self.contents] l_s.heap.contents[! l_self]));
                           (r_contents := ([@expl:contents := self.contents] r_s.heap.contents[! r_self]))));
                         (((l_s.heap.contents <-
                              ([@expl:self.contents := cons(k,contents)]
                               M.add (! l_self) (ArrayStack.STACK.cons (! l_k) (! l_contents)) l_s.heap.contents));
                           (r_s.heap.contents <-
                              ([@expl:self.contents := cons(k,contents)]
                               M.add (! r_self) (ListStack.STACK.cons (! r_k) (! r_contents)) r_s.heap.contents))));
                         (assume {
                            ((ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s)) /\
                              ((ArrayStack.arrayStackPriv l_s) /\ (ListStack.listStackPriv r_s)) });
                         (assume {
                            (let oa = old l_s.alloct.M.domain in
                             Rgn.subset (Rgn.diff l_s.alloct.M.domain oa) (l_s.heap.rep[! l_self])) /\
                              (let oa = old r_s.alloct.M.domain in
                               Rgn.subset (Rgn.diff r_s.alloct.M.domain oa) (r_s.heap.rep[! r_self])) });
                         (assume {
                            (let oa = old l_s.alloct.M.domain in
                             let orep = old (l_s.heap.rep[! l_self]) in
                             Rgn.subset (l_s.heap.rep[! l_self]) (Rgn.union orep (Rgn.diff l_s.alloct.M.domain oa))) /\
                              (let oa = old r_s.alloct.M.domain in
                               let orep = old (r_s.heap.rep[! r_self]) in
                               Rgn.subset (r_s.heap.rep[! r_self]) (Rgn.union orep (Rgn.diff r_s.alloct.M.domain oa))) });
                         (! l_result, ! r_result))))))))))))))))))))
  
  let pop (l_s: state) (r_s: state) (pi14: PreRefperm.t) (l_self: reference) (r_self: reference) : 
    (reference, reference)
    requires { hasStackType l_s l_self }
    requires { l_self <> null }
    requires { hasStackType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi14 }
    requires { stackCoupling l_s r_s pi14 }
    requires { (agree_allfields
                  l_s
                  r_s
                  pi14
                  (Rgn.diff (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                 (agree_allfields
                    r_s
                    l_s
                    (PreRefperm.invert pi14)
                    (Rgn.diff (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    requires { PreRefperm.idRef pi14 l_self r_self }
    requires { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    requires { (let sz = l_s.heap.size[l_self] in
                sz > 0) /\ (let sz = r_s.heap.size[r_self] in
                            sz > 0) }
    requires { (Rgn.mem l_self l_s.pool) /\ (Rgn.mem r_self r_s.pool) }
    writes { l_s.heap.contents }
    writes { l_s.heap.size }
    writes { l_s.heap.top }
    writes { r_s.heap.contents }
    writes { r_s.heap.head }
    writes { r_s.heap.size }
    ensures { match result with | (l_result, _) -> (hasCellType l_s l_result) end }
    ensures { match result with | (_, r_result) -> (hasCellType r_s r_result) end }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old l_s) l_s (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`contents]
              wrs_to_contents_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`slots]
              wrs_to_slots_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`head]
              wrs_to_head_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cdr]
              wrs_to_cdr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`arr]
              wrs_to_arr_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`car]
              wrs_to_car_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`rep]
              wrs_to_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_rep]
              wrs_to_cell_rep_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`top]
              wrs_to_top_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`size]
              wrs_to_size_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`length]
              wrs_to_length_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { [@expl:wr ({self} union {self}`rep)`cell_value]
              wrs_to_cell_value_framed_by (old r_s) r_s (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) }
    ensures { okRefperm l_s r_s pi14 }
    ensures { stackCoupling l_s r_s pi14 }
    ensures { match result
              with
                | (l_result, r_result) ->
                    (let l_r = l_result in
                     let r_r = r_result in
                     let l_c = l_s.heap.cell_value[l_r] in
                     let r_c = r_s.heap.cell_value[r_r] in
                     l_c = r_c)
              end }
    ensures { let l_s_alloc = old l_s.alloct.M.domain in
              let r_s_alloc = old r_s.alloct.M.domain in
              let l_snap_r1 = old (Rgn.union (singleton l_self) (l_s.heap.rep[l_self])) in
              let r_snap_r1 = old (Rgn.union (singleton r_self) (r_s.heap.rep[r_self])) in
              (agree_allfields
                 l_s
                 r_s
                 pi14
                 (Rgn.diff (Rgn.union (Rgn.diff l_s.alloct.M.domain l_s_alloc) l_snap_r1) (Rgn.union l_s.pool (img_rep l_s l_s.pool)))) /\
                (agree_allfields
                   r_s
                   l_s
                   (PreRefperm.invert pi14)
                   (Rgn.diff (Rgn.union (Rgn.diff r_s.alloct.M.domain r_s_alloc) r_snap_r1) (Rgn.union r_s.pool (img_rep r_s r_s.pool)))) }
    ensures { (ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s) }
    ensures { (let rep15 = old (l_s.heap.rep[l_self]) in
               (l_s.heap.rep[l_self]) = rep15) /\
                (let rep16 = old (r_s.heap.rep[r_self]) in
                 (r_s.heap.rep[r_self]) = rep16) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let rep17 = l_s.heap.rep[l_self] in
                      Rgn.mem l_result rep17) /\
                       (let rep18 = r_s.heap.rep[r_self] in
                        Rgn.mem r_result rep18))
              end }
    ensures { (let ostk = old (l_s.heap.contents[l_self]) in
               (l_s.heap.contents[l_self]) = (ArrayStack.STACK.tl ostk)) /\
                (let ostk = old (r_s.heap.contents[r_self]) in
                 (r_s.heap.contents[r_self]) = (ListStack.STACK.tl ostk)) }
    ensures { match result
              with
                | (l_result, r_result) ->
                    ((let oxs = old (l_s.heap.contents[l_self]) in
                      let t = ArrayStack.STACK.hd oxs in
                      (l_s.heap.cell_value[l_result]) = t) /\
                       (let oxs = old (r_s.heap.contents[r_self]) in
                        let t = ListStack.STACK.hd oxs in
                        (r_s.heap.cell_value[r_result]) = t))
              end }
    ensures { (let osz = old (l_s.heap.size[l_self]) in
               (l_s.heap.size[l_self]) = (osz - 1)) /\
                (let osz = old (r_s.heap.size[r_self]) in
                 (r_s.heap.size[r_self]) = (osz - 1)) }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) }
    ensures { match result with | (l_result, r_result) -> ((not (l_result = null)) /\ (not (r_result = null))) end } =
    label INIT in
      let l_result = ref null in
      (let r_result = ref null in
       (let l_self = ref l_self in
        (let r_self = ref r_self in
         (let l_a = ref null in
          (let l_t = ref 0 in
           (let r_tmp = ref null in
            (let r_nxt = ref null in
             (let l_sz = ref 0 in
              (let r_sz = ref 0 in
               (let ghost l_contents = ref (any intList) in
                (let ghost r_contents = ref (any intList) in
                 (((((((l_a := ([@expl:a := self.arr] l_s.heap.arr[! l_self]));
                       (l_t := ([@expl:t := self.top] l_s.heap.top[! l_self]))));
                     (r_tmp := ([@expl:tmp := self.head] r_s.heap.head[! r_self]))));
                   (assert { let stk = r_s.heap.contents[! r_self] in
                             exists h: int, t: intList. stk = (ListStack.STACK.cons h t) });
                   (assert { (! r_tmp) <> null });
                   (assert { (ArrayStack.arrayStackPriv l_s) /\ ((ListStack.listStackPriv r_s) /\ (stackCoupling l_s r_s pi14)) });
                   (((l_result := ([@expl:result := a.{t}] A.get (l_s.heap.slots[! l_a]) (! l_t)));
                     (r_result := ([@expl:result := tmp.car] r_s.heap.car[! r_tmp]))));
                   (assert { stackCoupling l_s r_s pi14 });
                   (assert { let l_sz = l_s.heap.size[! l_self] in
                             let r_sz = r_s.heap.size[! r_self] in
                             l_sz = r_sz });
                   (((l_s.heap.top <- ([@expl:self.top := t - 1] M.add (! l_self) ((! l_t) - 1) l_s.heap.top));
                     (r_nxt := ([@expl:nxt := tmp.cdr] r_s.heap.cdr[! r_tmp]));
                     (r_s.heap.head <- ([@expl:self.head := nxt] M.add (! r_self) (! r_nxt) r_s.heap.head))));
                   (((l_sz := ([@expl:sz := self.size] l_s.heap.size[! l_self]));
                     (r_sz := ([@expl:sz := self.size] r_s.heap.size[! r_self]))));
                   (((l_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! l_self) ((! l_sz) - 1) l_s.heap.size));
                     (r_s.heap.size <- ([@expl:self.size := sz - 1] M.add (! r_self) ((! r_sz) - 1) r_s.heap.size))));
                   (assert { let l_sz = l_s.heap.size[! l_self] in
                             let r_sz = r_s.heap.size[! r_self] in
                             l_sz = r_sz });
                   (((l_contents := ([@expl:contents := self.contents] l_s.heap.contents[! l_self]));
                     (r_contents := ([@expl:contents := self.contents] r_s.heap.contents[! r_self]))));
                   (((l_s.heap.contents <-
                        ([@expl:self.contents := tl(contents)] M.add (! l_self) (ArrayStack.STACK.tl (! l_contents)) l_s.heap.contents));
                     (r_s.heap.contents <-
                        ([@expl:self.contents := tl(contents)] M.add (! r_self) (ListStack.STACK.tl (! r_contents)) r_s.heap.contents))));
                   (assume {
                      ((ArrayStack.STACK.stackPub l_s) /\ (ListStack.STACK.stackPub r_s)) /\
                        ((ArrayStack.arrayStackPriv l_s) /\ (ListStack.listStackPriv r_s)) });
                   (assume {
                      (let rep19 = l_s.heap.rep[! l_self] in
                       Rgn.mem (! l_result) rep19) /\
                        (let rep20 = r_s.heap.rep[! r_self] in
                         Rgn.mem (! r_result) rep20) });
                   (! l_result, ! r_result))))))))))))))
  
  let getCellValue (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_c: reference) (r_c: reference) : 
    (int, int)
    requires { hasCellType l_s l_c }
    requires { l_c <> null }
    requires { hasCellType r_s r_c }
    requires { r_c <> null }
    requires { okRefperm l_s r_s pi }
    requires { stackCoupling l_s r_s pi }
    requires { let l_v = l_s.heap.cell_value[l_c] in
               let r_v = r_s.heap.cell_value[r_c] in
               l_v = r_v }
    ensures { okRefperm l_s r_s pi }
    ensures { stackCoupling l_s r_s pi }
    ensures { match result with | (l_result, r_result) -> (l_result = r_result) end }
    ensures { (let bsnap_r25 = old (Rgn.union l_s.pool (img_rep l_s l_s.pool)) in
               Rgn.subset bsnap_r25 (Rgn.union l_s.pool (img_rep l_s l_s.pool))) /\
                (let bsnap_r25 = old (Rgn.union r_s.pool (img_rep r_s r_s.pool)) in
                 Rgn.subset bsnap_r25 (Rgn.union r_s.pool (img_rep r_s r_s.pool))) } =
    label INIT in
      let l_result = ref 0 in
      (let r_result = ref 0 in
       (let l_c = ref l_c in
        (let r_c = ref r_c in
         (((l_result := ([@expl:result := c.cell_value] l_s.heap.cell_value[! l_c]));
           (r_result := ([@expl:result := c.cell_value] r_s.heap.cell_value[! r_c]));
           (! l_result, ! r_result))))))
  
  lemma boundary_frames_coupling_REL_STACK : forall s: state, t: state, s': state, t': state, pi21: 
                                               PreRefperm.t, pi': PreRefperm.t, rho: 
                                               PreRefperm.t.
                                               (okRefperm s t pi21) ->
                                                 ((okRefperm s' t' pi') ->
                                                    ((PreRefperm.identity pi21 s.alloct.M.domain t.alloct.M.domain) ->
                                                       ((PreRefperm.identity pi' s'.alloct.M.domain t'.alloct.M.domain) ->
                                                          ((okRefperm s s' rho) ->
                                                             ((okRefperm t t' rho) ->
                                                                ((s.maxSize = t.maxSize) ->
                                                                   ((PreRefperm.idRgn pi21 s.pool t.pool) ->
                                                                    ((agree_allfields s t pi21 (Rgn.union s.pool (img_rep s s.pool))) ->
                                                                    ((s'.maxSize = t'.maxSize) ->
                                                                    ((PreRefperm.idRgn pi' s'.pool t'.pool) ->
                                                                    ((agree_allfields
                                                                    s'
                                                                    t'
                                                                    pi'
                                                                    (Rgn.union s'.pool (img_rep s' s'.pool))) ->
                                                                    ((stackCoupling s s' rho) -> (stackCoupling t t' rho)))))))))))))
  
  lemma stackCoupling_is_refperm_monotonic : forall s: state, t: state, pi22: 
                                               PreRefperm.t.
                                               (okRefperm s t pi22) ->
                                                 ((stackCoupling s t pi22) ->
                                                    (forall rho: PreRefperm.t.
                                                       (okRefperm s t rho) ->
                                                         ((PreRefperm.extends pi22 rho) -> (stackCoupling s t rho))))
end

module CLIENT_REL_biinterface
  
  use prelude.Prelude
  use State
  use Client1
  use Client2
  use REL_STACK
end

module Cell
  use prelude.Prelude
  use State
  use CELL
  
  let init_Cell (s: state) (self: reference) (k: int) : unit
    requires { hasCellType s self }
    requires { self <> null }
    writes { s.heap.cell_rep }
    writes { s.heap.cell_value }
    ensures { result = () }
    ensures { [@expl:wr {self}`cell_rep] wrs_to_cell_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cell_value] wrs_to_cell_value_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`length] wrs_to_length_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`slots] wrs_to_slots_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`cdr] wrs_to_cdr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`car] wrs_to_car_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`arr] wrs_to_arr_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`top] wrs_to_top_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`contents] wrs_to_contents_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`size] wrs_to_size_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`rep] wrs_to_rep_framed_by (old s) s (singleton self) }
    ensures { [@expl:wr {self}`head] wrs_to_head_framed_by (old s) s (singleton self) }
    ensures { (s.heap.cell_value[self]) = k }
    ensures { (s.heap.cell_rep[self]) = (singleton self) } =
    label INIT in
      let result = ref () in
      (let self = ref self in
       (let k = ref k in
        (((s.heap.cell_value <- ([@expl:self.cell_value := k] M.add (! self) (! k) s.heap.cell_value));
          (s.heap.cell_rep <- ([@expl:self.cell_rep := {self}] M.add (! self) (singleton (! self)) s.heap.cell_rep));
          (! result)))))
end

module MAIN
  
  use prelude.Prelude
  use State
end

