module State
  
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
    | K
  
  type heap = {
    mutable b : M.t int ;
    mutable a : M.t int
  }
  
  type state = {
    mutable heap : heap ;
    mutable ghost alloct : M.t reftype
  }invariant { not (null \: alloct) }
  invariant { forall p: reference. (p \: alloct) -> (((alloct[p]) = K) -> ((p \: heap.b) /\ (p \: heap.a))) }
   by { heap = (any heap) ;
  alloct = (M.create ()) }
  
  predicate isAllocated (s: state) (p: reference) = p \: s.alloct
  
  predicate typeofRgn (s: state) (r: rgn) (t: reftype) =
    forall p: reference. (Rgn.mem p r) -> ((p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = t)))
  
  predicate hasKType (s: state) (p: reference) = (p = null) \/ ((p \: s.alloct) /\ ((s.alloct[p]) = K))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    (forall p: reference. (p \: pi.lor) -> (p \: sl.alloct)) /\
      ((forall q: reference. (q \: pi.rol) -> (q \: sr.alloct)) /\
         (forall p: reference, q: reference. (p \: pi.lor) -> (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))
  
  val mk_K (s: state) : reference
    writes { s.alloct }
    writes { s.heap.b }
    writes { s.heap.a }
    ensures { not (result \: (old s.alloct)) }
    ensures { s.alloct = (M.add result K (old s.alloct)) }
    ensures { forall p: reference. (p \: (old s.alloct)) -> ((p \: s.alloct) /\ (((old s.alloct)[p]) = (s.alloct[p]))) }
    ensures { result <> null }
    ensures { hasKType s result }
    ensures { s.heap.b = (M.add result 0 (old s.heap.b)) }
    ensures { s.heap.a = (M.add result 0 (old s.heap.a)) }
  
  function img_b : state -> (rgn -> rgn)
  
  axiom img_b_ax : forall s: state, r: rgn. (img_b s r) = emptyRgn
  
  function img_a : state -> (rgn -> rgn)
  
  axiom img_a_ax : forall s: state, r: rgn. (img_a s r) = emptyRgn
  
  predicate agree_b (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasKType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.b[o]) = (sr.heap.b[pi.lor[o]]))))))
  
  predicate agree_a (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (okRefperm sl sr pi) /\
      (forall o: reference.
         (isAllocated sl o) ->
           ((hasKType sl o) ->
              ((Rgn.mem o w) -> ((o \: pi.lor) /\ ([@expl:sl(o) ~ sr(pi(o))] (sl.heap.a[o]) = (sr.heap.a[pi.lor[o]]))))))
end
module A
  
  use prelude.Prelude
  use State
  
  val f (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.a }
    ensures { result = () }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { (s.heap.a[self]) = k }
  
  val g (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.b }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { (s.heap.b[self]) = k }
  
  val m (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.b }
    writes { s.heap.a }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { ((s.heap.a[self]) = k) /\ ((s.heap.b[self]) = k) }
end

module A0
  
  use prelude.Prelude
  use State
  use A
  
  let f (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.a }
    ensures { result = () }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { (s.heap.a[self]) = k } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (((s.heap.a <- ([@expl:self.a := k] M.add (! self) (! k) s.heap.a));
        (! result)))))
  
  let g (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.b }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { (s.heap.b[self]) = k } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (((s.heap.b <- ([@expl:self.b := k] M.add (! self) (! k) s.heap.b));
        (! result)))))
  
  let m (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.a }
    writes { s.heap.b }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { ((s.heap.a[self]) = k) /\ ((s.heap.b[self]) = k) } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      ((([@expl:f(self,k)] f s (! self) (! k));
        ([@expl:g(self,k)] g s (! self) (! k));
        (! result)))))
end

module A1
  
  use prelude.Prelude
  use State
  use A
  
  let f (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.a }
    ensures { result = () }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { (s.heap.a[self]) = k } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (((s.heap.a <- ([@expl:self.a := k] M.add (! self) (! k) s.heap.a));
        (! result)))))
  
  let g (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.b }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { (s.heap.b[self]) = k } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      (((s.heap.b <- ([@expl:self.b := k] M.add (! self) (! k) s.heap.b));
        (! result)))))
  
  let m (s: state) (self: reference) (k: int) : unit
    requires { hasKType s self }
    requires { self <> null }
    writes { s.heap.a }
    writes { s.heap.b }
    ensures { result = () }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.b[p]) = ((old s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old s.alloct)) -> (((s.alloct[p]) = K) -> ((p <> self) -> ((s.heap.a[p]) = ((old s.heap.a)[p])))) }
    ensures { ((s.heap.a[self]) = k) /\ ((s.heap.b[self]) = k) } =
    let result = ref () in
    (let self = ref self in
     (let k = ref k in
      ((([@expl:g(self,k)] g s (! self) (! k));
        ([@expl:f(self,k)] f s (! self) (! k));
        (! result)))))
end

module A_REL
  
  use prelude.Prelude
  use State
  use A0
  use A1
  
  let f (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasKType l_s l_self }
    requires { l_self <> null }
    requires { hasKType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_self r_self }
    writes { l_s.heap.a }
    writes { r_s.heap.a }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.a[p]) = ((old l_s.heap.a)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.a[p]) = ((old r_s.heap.a)[p])))) }
    ensures { okRefperm l_s r_s pi }
    ensures { (agree_a l_s r_s pi (singleton l_self)) /\ (agree_a r_s l_s (PreRefperm.invert pi) (singleton r_self)) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let r_self = ref r_self in
        (let r_k = ref r_k in
         (((l_s.heap.a <- ([@expl:self.a := k] M.add (! l_self) (! l_k) l_s.heap.a));
           (r_s.heap.a <- ([@expl:self.a := k] M.add (! r_self) (! r_k) r_s.heap.a));
           (! l_result, ! r_result))))))))
  
  let g (l_s: state) (r_s: state) (pi1: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasKType l_s l_self }
    requires { l_self <> null }
    requires { hasKType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi1 }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi1 l_self r_self }
    writes { l_s.heap.b }
    writes { r_s.heap.b }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.b[p]) = ((old l_s.heap.b)[p])))) }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.b[p]) = ((old r_s.heap.b)[p])))) }
    ensures { okRefperm l_s r_s pi1 }
    ensures { (agree_b l_s r_s pi1 (singleton l_self)) /\ (agree_b r_s l_s (PreRefperm.invert pi1) (singleton r_self)) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let r_self = ref r_self in
        (let r_k = ref r_k in
         (((l_s.heap.b <- ([@expl:self.b := k] M.add (! l_self) (! l_k) l_s.heap.b));
           (r_s.heap.b <- ([@expl:self.b := k] M.add (! r_self) (! r_k) r_s.heap.b));
           (! l_result, ! r_result))))))))
  
  let m (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasKType l_s l_self }
    requires { l_self <> null }
    requires { hasKType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi l_self r_self }
    writes { l_s.heap.a }
    writes { l_s.heap.b }
    writes { r_s.heap.a }
    writes { r_s.heap.b }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.b[p]) = ((old l_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.a[p]) = ((old l_s.heap.a)[p])))) }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.b[p]) = ((old r_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.a[p]) = ((old r_s.heap.a)[p])))) }
    ensures { okRefperm l_s r_s pi }
    ensures { ((agree_a l_s r_s pi (singleton l_self)) /\ (agree_a r_s l_s (PreRefperm.invert pi) (singleton r_self))) /\
                ((agree_b l_s r_s pi (singleton l_self)) /\ (agree_b r_s l_s (PreRefperm.invert pi) (singleton r_self))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let r_self = ref r_self in
        (let r_k = ref r_k in
         ((((([@expl:f(self,k)] A0.f l_s (! l_self) (! l_k));
             ([@expl:g(self,k)] A1.g r_s (! r_self) (! r_k))));
           ([@expl:g(self,k)] A0.g l_s (! l_self) (! l_k));
           ([@expl:f(self,k)] A1.f r_s (! r_self) (! r_k));
           (! l_result, ! r_result))))))))
  
  let m2 (l_s: state) (r_s: state) (pi2: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasKType l_s l_self }
    requires { l_self <> null }
    requires { hasKType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi2 }
    requires { l_k = r_k }
    requires { PreRefperm.idRef pi2 l_self r_self }
    writes { l_s.heap.a }
    writes { l_s.heap.b }
    writes { r_s.heap.a }
    writes { r_s.heap.b }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.b[p]) = ((old l_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.a[p]) = ((old l_s.heap.a)[p])))) }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.b[p]) = ((old r_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.a[p]) = ((old r_s.heap.a)[p])))) }
    ensures { okRefperm l_s r_s pi2 }
    ensures { ((agree_a l_s r_s pi2 (singleton l_self)) /\ (agree_a r_s l_s (PreRefperm.invert pi2) (singleton r_self))) /\
                ((agree_b l_s r_s pi2 (singleton l_self)) /\ (agree_b r_s l_s (PreRefperm.invert pi2) (singleton r_self))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let r_self = ref r_self in
        (let r_k = ref r_k in
         ((((([@expl:f(self,k)] A0.f l_s (! l_self) (! l_k));
             ([@expl:g(self,k)] A0.g l_s (! l_self) (! l_k))));
           ([@expl:g(self,k)] A1.g r_s (! r_self) (! r_k));
           ([@expl:f(self,k)] A1.f r_s (! r_self) (! r_k));
           (! l_result, ! r_result))))))))
  
  let m3 (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_self: reference) (l_k: int) (r_self: reference) (r_k: int) : 
    (unit, unit)
    requires { hasKType l_s l_self }
    requires { l_self <> null }
    requires { hasKType r_s r_self }
    requires { r_self <> null }
    requires { okRefperm l_s r_s pi }
    requires { l_k = r_k }
    writes { l_s.heap.a }
    writes { l_s.heap.b }
    writes { r_s.heap.a }
    writes { r_s.heap.b }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.b[p]) = ((old l_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old l_s.alloct)) -> (((l_s.alloct[p]) = K) -> ((p <> l_self) -> ((l_s.heap.a[p]) = ((old l_s.heap.a)[p])))) }
    ensures { [@expl:write frame b]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.b[p]) = ((old r_s.heap.b)[p])))) }
    ensures { [@expl:write frame a]
              forall p: reference.
                (p \: (old r_s.alloct)) -> (((r_s.alloct[p]) = K) -> ((p <> r_self) -> ((r_s.heap.a[p]) = ((old r_s.heap.a)[p])))) }
    ensures { okRefperm l_s r_s pi }
    ensures { ((agree_a l_s r_s pi (singleton l_self)) /\ (agree_a r_s l_s (PreRefperm.invert pi) (singleton r_self))) /\
                ((agree_b l_s r_s pi (singleton l_self)) /\ (agree_b r_s l_s (PreRefperm.invert pi) (singleton r_self))) }
    ensures { match result with | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ())) end } =
    let l_result = ref () in
    (let r_result = ref () in
     (let l_self = ref l_self in
      (let l_k = ref l_k in
       (let r_self = ref r_self in
        (let r_k = ref r_k in
         ((((([@expl:f(self,k)] A0.f l_s (! l_self) (! l_k));
             ([@expl:g(self,k)] A0.g l_s (! l_self) (! l_k))));
           ([@expl:g(self,k)] A1.g r_s (! r_self) (! r_k));
           ([@expl:f(self,k)] A1.f r_s (! r_self) (! r_k));
           (! l_result, ! r_result))))))))
end

