(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.NthLength.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v),
  (forall (x:k), set.Fset.mem x (domain m1) <-> set.Fset.mem x (domain m2)) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))) ->
  (m1 = m2).

Axiom mem_mapsto : True.

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (x:k), ~ set.Fset.mem x (domain (empty : fmap k v)).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), set.Fset.mem k11 (domain m) ->
  ~ (k11 = k1) -> ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), set.Fset.mem k1 (domain m) ->
  ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), set.Fset.mem k11 (domain m) ->
  ~ (k11 = k1) -> ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a),
  ((0%Z < (length self))%Z \/ (0%Z = (length self))) /\
  ((set.Fset.cardinal (domain (to_fmap (elts self)))) = (length self)) /\
  (forall (i:Numbers.BinNums.Z),
   ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length self))%Z ->
   set.Fset.mem i (domain (to_fmap (elts self)))).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get (set a1 i v) i) = v).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  forall (j:Numbers.BinNums.Z),
  ((0%Z < j)%Z \/ (0%Z = j)) /\ (j < (length a1))%Z -> ~ (j = i) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z < n)%Z \/ (0%Z = n) ->
  forall (i:Numbers.BinNums.Z), ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < n)%Z ->
  ((get (make n v) i) = v).

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z < n)%Z \/ (0%Z = n) ->
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((0%Z < j)%Z \/ (0%Z = j)) /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  ((0%Z < i)%Z \/ (0%Z = i)) /\ (i < (length a1))%Z ->
  ((0%Z < j)%Z \/ (0%Z = j)) /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  ((0%Z < k)%Z \/ (0%Z = k)) /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) <-> (r1 = r2).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) <-> ~ (r1 = r2).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) <-> (b1 = b2).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) <-> (u1 = u2).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), set.Fset.mem k (domain (to_fmap1 m)) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), set.Fset.mem k (domain (to_fmap1 m)) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (set.Fset.mem k (domain (to_fmap1 m)) \/
   ~ set.Fset.mem k (domain (to_fmap1 m)) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   set.Fset.mem k (domain (to_fmap1 m))) /\
  (set.Fset.mem k (domain (to_fmap1 m)) ->
   ~ set.Fset.mem k (domain (to_fmap1 m)) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  set.Fset.mem k (domain (to_fmap1 m)) \/
  ~ set.Fset.mem k (domain (to_fmap1 m)) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  (set.Fset.mem k (domain (to_fmap1 m)) \/
   ~ set.Fset.mem k (domain (to_fmap1 m)) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   set.Fset.mem k (domain (to_fmap1 m))) /\
  (set.Fset.mem k (domain (to_fmap1 m)) ->
   ~ set.Fset.mem k (domain (to_fmap1 m)) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom add_map_others_unchanged :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) -> forall (q:reference),
  set.Fset.mem q (domain (to_fmap1 m)) \/
  ~ set.Fset.mem q (domain (to_fmap1 m)) /\
  (Init.Datatypes.false = Init.Datatypes.true) -> ~ (q = p) ->
  ((mixfix_lbrb m' q) = (mixfix_lbrb m q)).

Axiom add_map_lookup :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) ->
  (~ set.Fset.mem p (domain (to_fmap1 m')) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb m' p) = v).

(* Why3 assumption *)
Definition rgn := set.Fset.fset reference.

Parameter eqRgn:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom eqRgn'spec :
  forall (s1:set.Fset.fset reference) (s2:set.Fset.fset reference),
  ((eqRgn s1 s2) = Init.Datatypes.true) <->
  (forall (x:reference), set.Fset.mem x s1 <-> set.Fset.mem x s2).

Parameter singleton: reference -> set.Fset.fset reference.

Axiom singleton'spec'0 :
  forall (x:reference),
  ((singleton x) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))).

Axiom singleton'spec :
  forall (x:reference), ((set.Fset.cardinal (singleton x)) = 1%Z).

Axiom rgn_extensionality :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (r1 = r2) <->
  (forall (x:reference), set.Fset.mem x r1 <-> set.Fset.mem x r2).

Axiom rgn_union_emptyRgn_id_right :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.empty : set.Fset.fset reference)) = r).

Axiom rgn_union_emptyRgn_id_left :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union (set.Fset.empty : set.Fset.fset reference) r) = r).

Axiom rgn_union_same :
  forall (r:set.Fset.fset reference), ((set.Fset.union r r) = r).

Axiom rgn_union_assoc :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union (set.Fset.union r r') r'')).

Axiom rgn_union_swap1 :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union r' (set.Fset.union r r''))).

Axiom rgn_union_comm :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference),
  ((set.Fset.union r r') = (set.Fset.union r' r)).

Axiom rgn_inter_remove_sngl :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference) (p:reference),
  (r1 = (set.Fset.union r2 (singleton p))) -> ~ set.Fset.mem p r3 ->
  ((set.Fset.inter r1 r3) = (set.Fset.inter r2 r3)).

Axiom rgn_remove_not_in :
  forall (r:set.Fset.fset reference) (x:reference), ~ set.Fset.mem x r ->
  ((set.Fset.remove x r) = r).

Axiom rgn_disjoint_union :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((forall (x:reference),
    set.Fset.mem x (set.Fset.inter (set.Fset.union r1 r2) r3) ->
    set.Fset.mem x (singleton nullConst)) \/
   ~ (forall (x:reference),
      set.Fset.mem x (set.Fset.inter (set.Fset.union r1 r2) r3) ->
      set.Fset.mem x (singleton nullConst)) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   (~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r1 r3) ->
       set.Fset.mem x (singleton nullConst)) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   (~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r2 r3) ->
       set.Fset.mem x (singleton nullConst)) ->
    (Init.Datatypes.false = Init.Datatypes.true))) /\
  (((forall (x:reference), set.Fset.mem x (set.Fset.inter r1 r3) ->
     set.Fset.mem x (singleton nullConst)) \/
    ~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r1 r3) ->
       set.Fset.mem x (singleton nullConst)) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   ((forall (x:reference), set.Fset.mem x (set.Fset.inter r2 r3) ->
     set.Fset.mem x (singleton nullConst)) \/
    ~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r2 r3) ->
       set.Fset.mem x (singleton nullConst)) /\
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   ~ (forall (x:reference),
      set.Fset.mem x (set.Fset.inter (set.Fset.union r1 r2) r3) ->
      set.Fset.mem x (singleton nullConst)) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom rgn_disjoint_inter :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((forall (x:reference),
    set.Fset.mem x (set.Fset.inter (set.Fset.inter r1 r2) r3) ->
    set.Fset.mem x (singleton nullConst)) \/
   ~ (forall (x:reference),
      set.Fset.mem x (set.Fset.inter (set.Fset.inter r1 r2) r3) ->
      set.Fset.mem x (singleton nullConst)) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   ~ (forall (x:reference),
      set.Fset.mem x
      (set.Fset.inter (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) ->
      set.Fset.mem x (singleton nullConst)) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((forall (x:reference),
    set.Fset.mem x
    (set.Fset.inter (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) ->
    set.Fset.mem x (singleton nullConst)) \/
   ~ (forall (x:reference),
      set.Fset.mem x
      (set.Fset.inter (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) ->
      set.Fset.mem x (singleton nullConst)) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   ~ (forall (x:reference),
      set.Fset.mem x (set.Fset.inter (set.Fset.inter r1 r2) r3) ->
      set.Fset.mem x (singleton nullConst)) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom rgn_disjoint_singleton :
  forall (x:reference) (r:set.Fset.fset reference), ~ (x = nullConst) ->
  ((forall (x1:reference),
    set.Fset.mem x1 (set.Fset.inter (singleton x) r) ->
    set.Fset.mem x1 (singleton nullConst)) \/
   ~ (forall (x1:reference),
      set.Fset.mem x1 (set.Fset.inter (singleton x) r) ->
      set.Fset.mem x1 (singleton nullConst)) /\
   (Init.Datatypes.false = Init.Datatypes.true) -> ~ set.Fset.mem x r) /\
  (~ set.Fset.mem x r ->
   ~ (forall (x1:reference),
      set.Fset.mem x1 (set.Fset.inter (singleton x) r) ->
      set.Fset.mem x1 (singleton nullConst)) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom rgn_disjoint_comm :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (forall (x:reference), set.Fset.mem x (set.Fset.inter r1 r2) ->
   set.Fset.mem x (singleton nullConst)) \/
  ~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r1 r2) ->
     set.Fset.mem x (singleton nullConst)) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ~ (forall (x:reference), set.Fset.mem x (set.Fset.inter r2 r1) ->
     set.Fset.mem x (singleton nullConst)) ->
  (Init.Datatypes.false = Init.Datatypes.true).

Parameter rgnSubK:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset reference -> t1 a -> a ->
  set.Fset.fset reference.

Axiom rgnSubK'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (r:reference),
  set.Fset.mem r (rgnSubK s m v) <->
  ~ (r = nullConst) /\ set.Fset.mem r s /\ ((mixfix_lbrb m r) = v).

Axiom rgnSubK_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (x:reference),
  set.Fset.mem x (rgnSubK s m v) <->
  ~ (x = nullConst) /\ set.Fset.mem x s /\ ((mixfix_lbrb m x) = v).

Axiom rgnSubK_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (x:reference),
  set.Fset.mem x (rgnSubK s m v) -> set.Fset.mem x s.

Axiom rgnSubK_idempotent :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  ((rgnSubK (rgnSubK s m v) m v) = (rgnSubK s m v)).

Axiom rgnSubK_monotonic :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (s':set.Fset.fset reference) (m:t1 a)
    (v:a),
  (forall (x:reference), set.Fset.mem x s -> set.Fset.mem x s') ->
  forall (x:reference), set.Fset.mem x (rgnSubK s m v) ->
  set.Fset.mem x (rgnSubK s' m v).

Axiom rgnSubK_twice_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((rgnSubK (rgnSubK s m v) m v') =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom rgnSubK_inter_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((set.Fset.inter (rgnSubK s m v) (rgnSubK s m v')) =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant :
  forall (self:t2),
  (((set.Fset.cardinal (domain (to_fmap1 (lor self)))) =
    (set.Fset.cardinal (domain (to_fmap1 (rol self))))) /\
   (forall (x:reference),
    set.Fset.mem x (domain (to_fmap1 (lor self))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor self))) /\
    (Init.Datatypes.false = Init.Datatypes.true) ->
    ~ set.Fset.mem (mixfix_lbrb (lor self) x) (domain (to_fmap1 (rol self))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   (forall (y:reference),
    set.Fset.mem y (domain (to_fmap1 (rol self))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol self))) /\
    (Init.Datatypes.false = Init.Datatypes.true) ->
    ~ set.Fset.mem (mixfix_lbrb (rol self) y) (domain (to_fmap1 (lor self))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   (forall (x:reference),
    set.Fset.mem x (domain (to_fmap1 (lor self))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor self))) /\
    (Init.Datatypes.false = Init.Datatypes.true) ->
    ((mixfix_lbrb (rol self) (mixfix_lbrb (lor self) x)) = x)) /\
   (forall (y:reference),
    set.Fset.mem y (domain (to_fmap1 (rol self))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol self))) /\
    (Init.Datatypes.false = Init.Datatypes.true) ->
    ((mixfix_lbrb (lor self) (mixfix_lbrb (rol self) y)) = y))) /\
  ~ (set.Fset.mem nullConst (domain (to_fmap1 (lor self))) \/
     ~ set.Fset.mem nullConst (domain (to_fmap1 (lor self))) /\
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (set.Fset.mem nullConst (domain (to_fmap1 (rol self))) \/
     ~ set.Fset.mem nullConst (domain (to_fmap1 (rol self))) /\
     (Init.Datatypes.false = Init.Datatypes.true)).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
  ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) ->
  (y = nullConst) /\ (x' = nullConst) \/
  ~ (x' = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x' (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x' (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x') = y) -> (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) ->
  (y' = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y' = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y') -> (y = y').

Axiom idRgn_left :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h) ->
  forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
  set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) h.

Axiom idRgn_right :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h) ->
  forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
  set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
  ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) g.

Axiom idRgn_empty :
  forall (pi:t2),
  (forall (x:reference), ~ (x = nullConst) ->
   set.Fset.mem x (set.Fset.empty : set.Fset.fset reference) ->
   (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x)
   (set.Fset.empty : set.Fset.fset reference)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   set.Fset.mem y (set.Fset.empty : set.Fset.fset reference) ->
   (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y)
   (set.Fset.empty : set.Fset.fset reference)).

Axiom idRgn_sub_rgnSubK :
  forall {a:Type} {a_WT:WhyType a},
  forall (pi:t2) (m:t1 a) (m':t1 a) (v:a) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) ->
   (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   set.Fset.mem x (domain (to_fmap1 m)) \/
   ~ set.Fset.mem x (domain (to_fmap1 m)) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   set.Fset.mem y (domain (to_fmap1 m')) \/
   ~ set.Fset.mem y (domain (to_fmap1 m')) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   (~ set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb m p) = (mixfix_lbrb m' q))) ->
  ((forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
    set.Fset.mem x g ->
    (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
   (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
    set.Fset.mem y h ->
    (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
     ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (rol pi) y) g) ->
   (forall (x:reference), ~ (x = nullConst) ->
    set.Fset.mem x (rgnSubK g m v) ->
    (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (lor pi) x) (rgnSubK h m' v)) /\
   (forall (y:reference), ~ (y = nullConst) ->
    set.Fset.mem y (rgnSubK h m' v) ->
    (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (rol pi) y) (rgnSubK g m v)) /\
   (set.Fset.mem nullConst (rgnSubK g m v) <->
    set.Fset.mem nullConst (rgnSubK h m' v))) /\
  ((forall (x:reference), ~ (x = nullConst) ->
    set.Fset.mem x (rgnSubK g m v) ->
    (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (lor pi) x) (rgnSubK h m' v)) /\
   (forall (y:reference), ~ (y = nullConst) ->
    set.Fset.mem y (rgnSubK h m' v) ->
    (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
     ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (rol pi) y) (rgnSubK g m v)) /\
   (set.Fset.mem nullConst (rgnSubK g m v) <->
    set.Fset.mem nullConst (rgnSubK h m' v)) ->
   (forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
    set.Fset.mem x g ->
    (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
   (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
    set.Fset.mem y h ->
    (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
    set.Fset.mem (mixfix_lbrb (rol pi) y) g)).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec'6 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  (~ set.Fset.mem x (domain (to_fmap1 (lor (updateRefperm0 pi x y)))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  (~ set.Fset.mem y (domain (to_fmap1 (rol (updateRefperm0 pi x y)))) ->
   (Init.Datatypes.false = Init.Datatypes.true)).

Axiom updateRefperm0'spec'5 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  ((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y) /\
  ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x).

Axiom updateRefperm0'spec'4 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  forall (x1:reference),
  set.Fset.mem x1 (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x1 (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ~ set.Fset.mem x1 (domain (to_fmap1 (lor (updateRefperm0 pi x y)))) ->
  (Init.Datatypes.false = Init.Datatypes.true).

Axiom updateRefperm0'spec'3 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  forall (y1:reference),
  set.Fset.mem y1 (domain (to_fmap1 (rol pi))) \/
  ~ set.Fset.mem y1 (domain (to_fmap1 (rol pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ~ set.Fset.mem y1 (domain (to_fmap1 (rol (updateRefperm0 pi x y)))) ->
  (Init.Datatypes.false = Init.Datatypes.true).

Axiom updateRefperm0'spec'2 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  forall (x1:reference),
  set.Fset.mem x1 (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x1 (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom updateRefperm0'spec'1 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  forall (y1:reference),
  set.Fset.mem y1 (domain (to_fmap1 (rol pi))) \/
  ~ set.Fset.mem y1 (domain (to_fmap1 (rol pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi) y1) =
   (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1)).

Axiom updateRefperm0'spec'0 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))).

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) /\
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

Axiom extends_refl : True.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2),
  (forall (x:reference),
   (~ set.Fset.mem x (domain (to_fmap1 (lor pi0))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi1))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi1))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x))) ->
  (forall (x:reference),
   (~ set.Fset.mem x (domain (to_fmap1 (lor pi1))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi2))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi2))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   ((mixfix_lbrb (lor pi1) x) = (mixfix_lbrb (lor pi2) x))) ->
  forall (x:reference),
  set.Fset.mem x (domain (to_fmap1 (lor pi0))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi0))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  (~ set.Fset.mem x (domain (to_fmap1 (lor pi2))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi2) x)).

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) ->
  ~ (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  ~ (~ set.Fset.mem y (domain (to_fmap1 (rol pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
  forall (x1:reference),
  set.Fset.mem x1 (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x1 (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  (~ set.Fset.mem x1 (domain (to_fmap1 (lor (updateRefperm0 pi x y)))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom extends_idRgn :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h) -> forall (rho:t2),
  (forall (x:reference),
   (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   (set.Fset.mem x (domain (to_fmap1 (lor rho))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor rho))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   ((mixfix_lbrb (lor pi) x) = (mixfix_lbrb (lor rho) x))) ->
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   (~ set.Fset.mem x (domain (to_fmap1 (lor rho))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor rho) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   (~ set.Fset.mem y (domain (to_fmap1 (rol rho))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol rho) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h).

Axiom extends_idRef :
  forall (pi:t2) (x:reference) (y:reference),
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) -> forall (rho:t2),
  (forall (x1:reference),
   (~ set.Fset.mem x1 (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) ->
   (set.Fset.mem x1 (domain (to_fmap1 (lor rho))) \/
    ~ set.Fset.mem x1 (domain (to_fmap1 (lor rho))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   ((mixfix_lbrb (lor pi) x1) = (mixfix_lbrb (lor rho) x1))) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (~ set.Fset.mem x (domain (to_fmap1 (lor rho))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor rho) x) = y).

Axiom extends_exists :
  forall (pi:t2),
  exists pi0:t2,
  forall (x:reference),
  set.Fset.mem x (domain (to_fmap1 (lor pi0))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi0))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi) x)).

Parameter invert: t2 -> t2.

Axiom invert'spec :
  forall (pi:t2),
  ((lor (invert pi)) = (rol pi)) /\ ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) ->
  (x = nullConst) /\ (y = nullConst) \/
  ~ (y = nullConst) /\
  ~ (x = nullConst) /\
  (~ set.Fset.mem y (domain (to_fmap1 (lor (invert pi)))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor (invert pi)) y) = x).

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) ->
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = y) ->
  (z = nullConst) /\ (y = nullConst) \/
  ~ (y = nullConst) /\
  ~ (z = nullConst) /\
  (set.Fset.mem y (domain (to_fmap1 (lor (invert pi)))) \/
   ~ set.Fset.mem y (domain (to_fmap1 (lor (invert pi)))) /\
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor (invert pi)) y) = z) -> (x = z).

Axiom identity_in_refperm :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  set.Fset.mem x (set.Fset.inter g1 g2) ->
  (~ set.Fset.mem x (domain (to_fmap1 (lor pi))) ->
   (Init.Datatypes.false = Init.Datatypes.true)) /\
  ((mixfix_lbrb (lor pi) x) = x).

Axiom identity_in_inter :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  set.Fset.mem x (set.Fset.inter g1 g2).

Axiom identity_ref_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
  ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
  (Init.Datatypes.false = Init.Datatypes.true) ->
  (x = (mixfix_lbrb (lor pi) x)).

Axiom identity_rgn_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (h1:set.Fset.fset reference) (h2:set.Fset.fset reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x h1 ->
   (set.Fset.mem x (domain (to_fmap1 (lor pi))) \/
    ~ set.Fset.mem x (domain (to_fmap1 (lor pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h2) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h2 ->
   (set.Fset.mem y (domain (to_fmap1 (rol pi))) \/
    ~ set.Fset.mem y (domain (to_fmap1 (rol pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) h1) /\
  (set.Fset.mem nullConst h1 <-> set.Fset.mem nullConst h2) -> (h1 = h2).

Axiom identity_null_notin :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  ~ set.Fset.mem nullConst (set.Fset.inter g1 g2).

Axiom identity_sym :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  (forall (o:reference),
   (set.Fset.mem o g1 /\ set.Fset.mem o g2 \/
    (~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    (set.Fset.mem o g1 /\ set.Fset.mem o g2) /\
    (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
     ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
     (Init.Datatypes.false = Init.Datatypes.true))) /\
   ((~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
     (Init.Datatypes.false = Init.Datatypes.true)) ->
    ((mixfix_lbrb (lor pi) o) = o))) ->
  forall (o:reference),
  ((set.Fset.mem o g2 /\ set.Fset.mem o g1 ->
    ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) ->
    (Init.Datatypes.false = Init.Datatypes.true)) /\
   (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
    ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
    (Init.Datatypes.false = Init.Datatypes.true) ->
    set.Fset.mem o g2 /\ set.Fset.mem o g1)) /\
  (set.Fset.mem o (domain (to_fmap1 (lor pi))) \/
   ~ set.Fset.mem o (domain (to_fmap1 (lor pi))) /\
   (Init.Datatypes.false = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) o) = o)).

(* Why3 assumption *)
Definition intList := Init.Datatypes.list Numbers.BinNums.Z.

Parameter nil: Init.Datatypes.list Numbers.BinNums.Z.

Axiom nil_ax : (nil = Init.Datatypes.nil).

Parameter listNth:
  Numbers.BinNums.Z -> Init.Datatypes.list Numbers.BinNums.Z ->
  Numbers.BinNums.Z.

Axiom listNth'def :
  forall (n:Numbers.BinNums.Z) (xs:Init.Datatypes.list Numbers.BinNums.Z),
  ((0%Z < n)%Z \/ (0%Z = n)) /\ (n < (list.Length.length xs))%Z ->
  match list.Nth.nth n xs with
  | Init.Datatypes.Some v => ((listNth n xs) = v)
  | _ => False
  end.

Parameter is_sorted3: Init.Datatypes.list Numbers.BinNums.Z -> Prop.

Axiom is_sorted3'def :
  forall (xs:Init.Datatypes.list Numbers.BinNums.Z),
  ((list.Length.length xs) = 3%Z) ->
  let q1_ := listNth 1%Z xs in
  is_sorted3 xs <->
  (((listNth 0%Z xs) < q1_)%Z \/ ((listNth 0%Z xs) = q1_)) /\
  ((q1_ < (listNth 2%Z xs))%Z \/ (q1_ = (listNth 2%Z xs))).

Parameter upd_list:
  Numbers.BinNums.Z -> Numbers.BinNums.Z ->
  Init.Datatypes.list Numbers.BinNums.Z ->
  Init.Datatypes.list Numbers.BinNums.Z.

Axiom upd_list'def :
  forall (k:Numbers.BinNums.Z) (v:Numbers.BinNums.Z)
    (xs:Init.Datatypes.list Numbers.BinNums.Z),
  ((0%Z < k)%Z \/ (0%Z = k)) /\ (k < (list.Length.length xs))%Z ->
  match xs with
  | nil1 => ((upd_list k v xs) = nil1)
  | Init.Datatypes.cons h t3 =>
      ((k = 0%Z) -> ((upd_list k v xs) = (Init.Datatypes.cons v t3))) /\
      (~ (k = 0%Z) ->
       ((upd_list k v xs) =
        (Init.Datatypes.cons h (upd_list (k + (-1%Z)%Z)%Z v t3))))
  end.

Axiom reftype : Type.
Parameter reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter alloct: state -> t1 reftype.

Axiom state'invariant :
  forall (self:state),
  ~ set.Fset.mem nullConst (domain (to_fmap1 (alloct self))).

Parameter agree_allfields:
  state -> state -> t2 -> set.Fset.fset reference -> Prop.

Parameter l_s: state.

Parameter r_s: state.

Parameter pi: t2.

Parameter l_l: Init.Datatypes.list Numbers.BinNums.Z.

Parameter r_l: Init.Datatypes.list Numbers.BinNums.Z.

Axiom H :
  forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  set.Fset.mem p (domain (to_fmap1 (alloct l_s))).

Axiom H1 :
  forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
  set.Fset.mem q (domain (to_fmap1 (alloct r_s))).

Axiom H2 :
  forall (p:reference) (q:reference),
  set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  ((mixfix_lbrb (lor pi) p) = q) ->
  ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q)).

Axiom Requires :
  (forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   set.Fset.mem p (domain (to_fmap1 (alloct l_s)))) /\
  (forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
   set.Fset.mem q (domain (to_fmap1 (alloct r_s)))) /\
  (forall (p:reference) (q:reference),
   set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q))) ->
  ((listNth 0%Z l_l) = (listNth 0%Z r_l)).

Axiom Requires1 :
  (forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   set.Fset.mem p (domain (to_fmap1 (alloct l_s)))) /\
  (forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
   set.Fset.mem q (domain (to_fmap1 (alloct r_s)))) /\
  (forall (p:reference) (q:reference),
   set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q))) ->
  ((listNth 1%Z l_l) = (listNth 1%Z r_l)).

Axiom Requires2 :
  (forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   set.Fset.mem p (domain (to_fmap1 (alloct l_s)))) /\
  (forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
   set.Fset.mem q (domain (to_fmap1 (alloct r_s)))) /\
  (forall (p:reference) (q:reference),
   set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q))) ->
  ((listNth 2%Z l_l) = (listNth 2%Z r_l)).

Axiom H3 : ((list.Length.length l_l) = 3%Z).

Axiom H4 : ((list.Length.length r_l) = 3%Z).

Parameter o: Init.Datatypes.list Numbers.BinNums.Z.

Parameter o1: Init.Datatypes.list Numbers.BinNums.Z.

Parameter o2: Init.Datatypes.list Numbers.BinNums.Z.

Parameter o3: Init.Datatypes.list Numbers.BinNums.Z.

Parameter o4: Init.Datatypes.list Numbers.BinNums.Z.

Parameter l_sort_ret: Init.Datatypes.list Numbers.BinNums.Z.

Parameter fst1: Numbers.BinNums.Z.

Axiom H5 : (fst1 = (listNth 0%Z l_l)).

Parameter fst2: Numbers.BinNums.Z.

Axiom H6 : (fst2 = (listNth 0%Z l_sort_ret)).

Parameter snd1: Numbers.BinNums.Z.

Axiom H7 : (snd1 = (listNth 1%Z l_l)).

Parameter snd2: Numbers.BinNums.Z.

Axiom H8 : (snd2 = (listNth 1%Z l_sort_ret)).

Parameter third1: Numbers.BinNums.Z.

Axiom H9 : (third1 = (listNth 2%Z l_l)).

Parameter third2: Numbers.BinNums.Z.

Axiom H10 : (third2 = (listNth 2%Z l_sort_ret)).

Axiom H11 :
  (fst1 = fst2) /\ (snd1 = snd2) /\ (third1 = third2) \/
  (fst1 = fst2) /\ (snd1 = third2) /\ (third1 = snd2) \/
  (fst1 = snd2) /\ (snd1 = fst2) /\ (third1 = third2) \/
  (fst1 = snd2) /\ (snd1 = third2) /\ (third1 = fst2) \/
  (fst1 = third2) /\ (snd1 = fst2) /\ (third1 = snd2) \/
  (fst1 = third2) /\ (snd1 = snd2) /\ (third1 = fst2).

Axiom Assume : is_sorted3 o4.

Parameter fst11: Numbers.BinNums.Z.

Axiom H12 : (fst11 = (listNth 0%Z r_l)).

Parameter fst21: Numbers.BinNums.Z.

Axiom H13 : (fst21 = (listNth 0%Z o4)).

Parameter snd11: Numbers.BinNums.Z.

Axiom H14 : (snd11 = (listNth 1%Z r_l)).

Parameter snd21: Numbers.BinNums.Z.

Axiom H15 : (snd21 = (listNth 1%Z o4)).

Parameter third11: Numbers.BinNums.Z.

Axiom H16 : (third11 = (listNth 2%Z r_l)).

Parameter third21: Numbers.BinNums.Z.

Axiom H17 : (third21 = (listNth 2%Z o4)).

Axiom H18 :
  (fst11 = fst21) /\ (snd11 = snd21) /\ (third11 = third21) \/
  (fst11 = fst21) /\ (snd11 = third21) /\ (third11 = snd21) \/
  (fst11 = snd21) /\ (snd11 = fst21) /\ (third11 = third21) \/
  (fst11 = snd21) /\ (snd11 = third21) /\ (third11 = fst21) \/
  (fst11 = third21) /\ (snd11 = fst21) /\ (third11 = snd21) \/
  (fst11 = third21) /\ (snd11 = snd21) /\ (third11 = fst21).

Parameter r_shuffle_ret: Init.Datatypes.list Numbers.BinNums.Z.

Parameter fst12: Numbers.BinNums.Z.

Axiom H19 : (fst12 = (listNth 0%Z r_shuffle_ret)).

Parameter fst22: Numbers.BinNums.Z.

Axiom H20 : (fst22 = (listNth 0%Z o4)).

Parameter snd12: Numbers.BinNums.Z.

Axiom H21 : (snd12 = (listNth 1%Z r_shuffle_ret)).

Parameter snd22: Numbers.BinNums.Z.

Axiom H22 : (snd22 = (listNth 1%Z o4)).

Parameter third12: Numbers.BinNums.Z.

Axiom H23 : (third12 = (listNth 2%Z r_shuffle_ret)).

Parameter third22: Numbers.BinNums.Z.

Axiom H24 : (third22 = (listNth 2%Z o4)).

Axiom H25 : (fst12 = fst22).

Axiom H26 : (snd12 = snd22).

Axiom H27 : (third12 = third22).

Parameter r_shuffle_ret1: Init.Datatypes.list Numbers.BinNums.Z.

Parameter fst13: Numbers.BinNums.Z.

Axiom H28 : (fst13 = (listNth 0%Z r_shuffle_ret1)).

Parameter fst23: Numbers.BinNums.Z.

Axiom H29 : (fst23 = (listNth 0%Z o4)).

Parameter snd13: Numbers.BinNums.Z.

Axiom H30 : (snd13 = (listNth 1%Z r_shuffle_ret1)).

Parameter snd23: Numbers.BinNums.Z.

Axiom H31 : (snd23 = (listNth 1%Z o4)).

Parameter third13: Numbers.BinNums.Z.

Axiom H32 : (third13 = (listNth 2%Z r_shuffle_ret1)).

Parameter third23: Numbers.BinNums.Z.

Axiom H33 : (third23 = (listNth 2%Z o4)).

Axiom H34 : (fst13 = fst23).

Axiom H35 : (snd13 = snd23).

Axiom H36 : (third13 = third23).

Parameter l_l1: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures : (l_l1 = l_sort_ret).

Parameter r_l1: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures1 : (r_l1 = r_shuffle_ret1).

Parameter l_l2: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures2 :
  (l_l2 =
   (upd_list 2%Z ((listNth 2%Z l_l1) + 3%Z)%Z
    (upd_list 1%Z ((listNth 1%Z l_l1) + 3%Z)%Z
     (upd_list 0%Z ((listNth 0%Z l_l1) + 3%Z)%Z l_l1)))).

Parameter r_l2: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures3 :
  (r_l2 =
   (upd_list 2%Z ((listNth 2%Z r_l1) + 3%Z)%Z
    (upd_list 1%Z ((listNth 1%Z r_l1) + 3%Z)%Z
     (upd_list 0%Z ((listNth 0%Z r_l1) + 3%Z)%Z r_l1)))).

Parameter l_result: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures4 : (l_result = l_l2).

Parameter r_result: Init.Datatypes.list Numbers.BinNums.Z.

Axiom Ensures5 : (r_result = r_l2).

Axiom H37 :
  forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  set.Fset.mem p (domain (to_fmap1 (alloct l_s))).

Axiom H38 :
  forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
  set.Fset.mem q (domain (to_fmap1 (alloct r_s))).

Axiom H39 :
  forall (p:reference) (q:reference),
  set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  ((mixfix_lbrb (lor pi) p) = q) ->
  ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q)).

Axiom H40 :
  forall (p:reference), set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  set.Fset.mem p (domain (to_fmap1 (alloct l_s))).

Axiom H41 :
  forall (q:reference), set.Fset.mem q (domain (to_fmap1 (rol pi))) ->
  set.Fset.mem q (domain (to_fmap1 (alloct r_s))).

Axiom H42 :
  forall (p:reference) (q:reference),
  set.Fset.mem p (domain (to_fmap1 (lor pi))) ->
  ((mixfix_lbrb (lor pi) p) = q) ->
  ((mixfix_lbrb (alloct l_s) p) = (mixfix_lbrb (alloct r_s) q)).

(* Why3 goal *)
Theorem prog'vc : ((listNth 0%Z l_result) = (listNth 0%Z r_result)).
Proof.


Qed.

