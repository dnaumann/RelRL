(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require HighOrd.
Require int.Int.
Require int.Abs.
Require int.ComputerDivision.
Require map.Map.
Require list.List.
Require list.Length.
Require list.Mem.
Require set.Fset.
Require list.Nth.
Require option.Option.
Require list.HdTl.
Require list.NthHdTl.
Require list.Append.
Require list.Reverse.
Require list.RevAppend.
Require list.NumOcc.
Require list.Permut.

(* Why3 assumption *)
Inductive ref (a:Type) :=
  | ref'mk : a -> ref a.
Axiom ref_WhyType : forall (a:Type) {a_WT:WhyType a}, WhyType (ref a).
Existing Instance ref_WhyType.
Arguments ref'mk {a}.

(* Why3 assumption *)
Definition contents {a:Type} {a_WT:WhyType a} (v:ref a) : a :=
  match v with
  | ref'mk x => x
  end.

Axiom fmap : forall (k:Type) (v:Type), Type.
Parameter fmap_WhyType :
  forall (k:Type) {k_WT:WhyType k} (v:Type) {v_WT:WhyType v}, WhyType (fmap k
  v).
Existing Instance fmap_WhyType.

Parameter contents1:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  k -> v.

Parameter domain:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v ->
  set.Fset.fset k.

(* Why3 assumption *)
Definition infix_eqeq {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m1:fmap k v) (m2:fmap k v) : Prop :=
  set.Fset.infix_eqeq (domain m1) (domain m2) /\
  (forall (k1:k), set.Fset.mem k1 (domain m1) ->
   ((contents1 m1 k1) = (contents1 m2 k1))).

Axiom extensionality :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (m1:fmap k v) (m2:fmap k v), infix_eqeq m1 m2 -> (m1 = m2).

(* Why3 assumption *)
Definition mem {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} (k1:k)
    (m:fmap k v) : Prop :=
  set.Fset.mem k1 (domain m).

(* Why3 assumption *)
Definition mapsto {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v} 
    (k1:k) (v1:v) (m:fmap k v) : Prop :=
  mem k1 m /\ ((contents1 m k1) = v1).

Axiom mem_mapsto :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> mapsto k1 (contents1 m k1) m.

(* Why3 assumption *)
Definition is_empty {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Prop :=
  set.Fset.is_empty (domain m).

Parameter mk:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  set.Fset.fset k -> (k -> v) -> fmap k v.

Axiom mk_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v), ((domain (mk d m)) = d).

Axiom mk_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (d:set.Fset.fset k) (m:k -> v) (k1:k), set.Fset.mem k1 d ->
  ((contents1 (mk d m) k1) = (m k1)).

Parameter empty:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, fmap k v.

Axiom is_empty_empty :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  is_empty (empty : fmap k v).

Parameter add:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k -> v ->
  fmap k v -> fmap k v.

Axiom add_contents_k :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v), ((contents1 (add k1 v1 m) k1) = v1).

Axiom add_contents_other :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (add k1 v1 m) k11) = (contents1 m k11)).

Axiom add_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (v1:v) (m:fmap k v),
  ((domain (add k1 v1 m)) = (set.Fset.add k1 (domain m))).

Parameter find:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> v.

Axiom find_def :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v), mem k1 m -> ((find k1 m) = (contents1 m k1)).

Parameter remove:
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}, k ->
  fmap k v -> fmap k v.

Axiom remove_contents :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v) (k11:k), mem k11 m -> ~ (k11 = k1) ->
  ((contents1 (remove k1 m) k11) = (contents1 m k11)).

Axiom remove_domain :
  forall {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v},
  forall (k1:k) (m:fmap k v),
  ((domain (remove k1 m)) = (set.Fset.remove k1 (domain m))).

(* Why3 assumption *)
Definition size {k:Type} {k_WT:WhyType k} {v:Type} {v_WT:WhyType v}
    (m:fmap k v) : Numbers.BinNums.Z :=
  set.Fset.cardinal (domain m).

Axiom t : forall (v:Type), Type.
Parameter t_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t v).
Existing Instance t_WhyType.

Parameter to_fmap:
  forall {v:Type} {v_WT:WhyType v}, t v -> fmap Numbers.BinNums.Z v.

Axiom array : forall (a:Type), Type.
Parameter array_WhyType :
  forall (a:Type) {a_WT:WhyType a}, WhyType (array a).
Existing Instance array_WhyType.

Parameter elts: forall {a:Type} {a_WT:WhyType a}, array a -> t a.

Parameter length:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z.

Axiom array'invariant :
  forall {a:Type} {a_WT:WhyType a},
  forall (self:array a),
  (0%Z <= (length self))%Z /\
  ((size (to_fmap (elts self))) = (length self)) /\
  (forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < (length self))%Z ->
   mem i (to_fmap (elts self))).

Parameter get:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a.

Axiom get'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (contents1 (to_fmap (elts a1)) i)).

Axiom get'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get a1 i) = (find i (to_fmap (elts a1)))).

Parameter set:
  forall {a:Type} {a_WT:WhyType a}, array a -> Numbers.BinNums.Z -> a ->
  array a.

Axiom set'spec'1 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom set'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> forall (j:Numbers.BinNums.Z),
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (j = i) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom set'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((length a1) = (length (set a1 i v))).

Parameter make:
  forall {a:Type} {a_WT:WhyType a}, Numbers.BinNums.Z -> a -> array a.

Axiom make'spec'0 :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  forall (i:Numbers.BinNums.Z), (0%Z <= i)%Z /\ (i < n)%Z ->
  ((get (make n v) i) = v).

Axiom make'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (n:Numbers.BinNums.Z) (v:a), (0%Z <= n)%Z ->
  ((length (make n v)) = n).

Axiom array_set_get_eq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> ((get (set a1 i v) i) = v).

Axiom array_set_get_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  ((get (set a1 i v) j) = (get a1 j)).

Axiom array_set_idem :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v) i) = (get (set a1 i v) i)).

Axiom array_set_shadow :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (v:a) (v':a),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  ((get (set (set a1 i v) i v') i) = (get (set a1 i v') i)).

Axiom array_index_val :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z -> exists v:a, ((get a1 i) = v).

Axiom array_set_permut :
  forall {a:Type} {a_WT:WhyType a},
  forall (a1:array a) (i:Numbers.BinNums.Z) (j:Numbers.BinNums.Z),
  (0%Z <= i)%Z /\ (i < (length a1))%Z ->
  (0%Z <= j)%Z /\ (j < (length a1))%Z -> ~ (i = j) ->
  forall (v:a) (v':a) (k:Numbers.BinNums.Z),
  (0%Z <= k)%Z /\ (k < (length a1))%Z ->
  ((get (set (set a1 i v) j v') k) = (get (set (set a1 j v') i v) k)).

Axiom reference : Type.
Parameter reference_WhyType : WhyType reference.
Existing Instance reference_WhyType.

Parameter nullConst: reference.

Parameter infix_eqdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_eqdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_eqdt r1 r2) = Init.Datatypes.true) <-> (r1 = r2).

Parameter infix_lsgtdt: reference -> reference -> Init.Datatypes.bool.

Axiom infix_lsgtdt'spec :
  forall (r1:reference) (r2:reference),
  ((infix_lsgtdt r1 r2) = Init.Datatypes.true) <-> ~ (r1 = r2).

Parameter eqBool:
  Init.Datatypes.bool -> Init.Datatypes.bool -> Init.Datatypes.bool.

Axiom eqBool'spec :
  forall (b1:Init.Datatypes.bool) (b2:Init.Datatypes.bool),
  ((eqBool b1 b2) = Init.Datatypes.true) <-> (b1 = b2).

Parameter eqUnit:
  Init.Datatypes.unit -> Init.Datatypes.unit -> Init.Datatypes.bool.

Axiom eqUnit'spec :
  forall (u1:Init.Datatypes.unit) (u2:Init.Datatypes.unit),
  ((eqUnit u1 u2) = Init.Datatypes.true) <-> (u1 = u2).

Axiom t1 : forall (v:Type), Type.
Parameter t1_WhyType : forall (v:Type) {v_WT:WhyType v}, WhyType (t1 v).
Existing Instance t1_WhyType.

Parameter to_fmap1:
  forall {v:Type} {v_WT:WhyType v}, t1 v -> fmap reference v.

Parameter mixfix_lbrb:
  forall {a:Type} {a_WT:WhyType a}, t1 a -> reference -> a.

Axiom mixfix_lbrb'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (contents1 (to_fmap1 m) k)).

Axiom mixfix_lbrb'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), mem k (to_fmap1 m) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Parameter infix_bscl:
  forall {a:Type} {a_WT:WhyType a}, reference -> t1 a -> Init.Datatypes.bool.

Axiom infix_bscl'def :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  (mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.true)) /\
  (~ mem k (to_fmap1 m) -> ((infix_bscl k m) = Init.Datatypes.false)).

Axiom infix_bscl'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (k:reference) (m:t1 a),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom find_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference), ((infix_bscl k m) = Init.Datatypes.true) ->
  ((mixfix_lbrb m k) = (find k (to_fmap1 m))).

Axiom mem_syntax :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (k:reference),
  ((infix_bscl k m) = Init.Datatypes.true) <-> mem k (to_fmap1 m).

Axiom add_map_others_unchanged :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) -> forall (q:reference),
  ((infix_bscl q m) = Init.Datatypes.true) -> ~ (q = p) ->
  ((mixfix_lbrb m' q) = (mixfix_lbrb m q)).

Axiom add_map_lookup :
  forall {a:Type} {a_WT:WhyType a},
  forall (m:t1 a) (m':t1 a) (p:reference) (v:a),
  ((to_fmap1 m') = (add p v (to_fmap1 m))) ->
  ((infix_bscl p m') = Init.Datatypes.true) /\ ((mixfix_lbrb m' p) = v).

(* Why3 assumption *)
Definition rgn := set.Fset.fset reference.

Parameter eqRgn:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom eqRgn'spec :
  forall (s1:set.Fset.fset reference) (s2:set.Fset.fset reference),
  ((eqRgn s1 s2) = Init.Datatypes.true) <-> set.Fset.infix_eqeq s1 s2.

Parameter singleton: reference -> set.Fset.fset reference.

Axiom singleton'spec'0 :
  forall (x:reference),
  ((singleton x) =
   (set.Fset.add x (set.Fset.empty : set.Fset.fset reference))).

Axiom singleton'spec :
  forall (x:reference), ((set.Fset.cardinal (singleton x)) = 1%Z).

Axiom rgn_extensionality :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (r1 = r2) <-> set.Fset.infix_eqeq r1 r2.

Axiom rgn_union_emptyRgn_id_right :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.empty : set.Fset.fset reference)) = r).

Axiom rgn_union_emptyRgn_id_left :
  forall (r:set.Fset.fset reference),
  ((set.Fset.union (set.Fset.empty : set.Fset.fset reference) r) = r).

Axiom rgn_union_same :
  forall (r:set.Fset.fset reference), ((set.Fset.union r r) = r).

Axiom rgn_union_assoc :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union (set.Fset.union r r') r'')).

Axiom rgn_union_swap1 :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference)
    (r'':set.Fset.fset reference),
  ((set.Fset.union r (set.Fset.union r' r'')) =
   (set.Fset.union r' (set.Fset.union r r''))).

Axiom rgn_union_comm :
  forall (r:set.Fset.fset reference) (r':set.Fset.fset reference),
  ((set.Fset.union r r') = (set.Fset.union r' r)).

Axiom rgn_inter_remove_sngl :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference) (p:reference),
  (r1 = (set.Fset.union r2 (singleton p))) -> ~ set.Fset.mem p r3 ->
  ((set.Fset.inter r1 r3) = (set.Fset.inter r2 r3)).

Axiom rgn_remove_not_in :
  forall (r:set.Fset.fset reference) (x:reference), ~ set.Fset.mem x r ->
  ((set.Fset.remove x r) = r).

Parameter infix_bssh:
  set.Fset.fset reference -> set.Fset.fset reference -> Init.Datatypes.bool.

Axiom infix_bssh'def :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  (set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.true)) /\
  (~ set.Fset.subset (set.Fset.inter r1 r2) (singleton nullConst) ->
   ((infix_bssh r1 r2) = Init.Datatypes.false)).

Axiom rgn_disjoint_union :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.union r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh r1 r3) = Init.Datatypes.true) /\
  ((infix_bssh r2 r3) = Init.Datatypes.true).

Axiom rgn_disjoint_inter :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference)
    (r3:set.Fset.fset reference),
  ((infix_bssh (set.Fset.inter r1 r2) r3) = Init.Datatypes.true) <->
  ((infix_bssh (set.Fset.inter r1 r3) (set.Fset.inter r2 r3)) =
   Init.Datatypes.true).

Axiom rgn_disjoint_singleton :
  forall (x:reference) (r:set.Fset.fset reference), ~ (x = nullConst) ->
  ((infix_bssh (singleton x) r) = Init.Datatypes.true) <-> ~ set.Fset.mem x r.

Axiom rgn_disjoint_comm :
  forall (r1:set.Fset.fset reference) (r2:set.Fset.fset reference),
  ((infix_bssh r1 r2) = Init.Datatypes.true) ->
  ((infix_bssh r2 r1) = Init.Datatypes.true).

Parameter rgnSubK:
  forall {a:Type} {a_WT:WhyType a}, set.Fset.fset reference -> t1 a -> a ->
  set.Fset.fset reference.

Axiom rgnSubK'spec :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a), forall (r:reference),
  set.Fset.mem r (rgnSubK s m v) <->
  ~ (r = nullConst) /\ set.Fset.mem r s /\ ((mixfix_lbrb m r) = v).

Axiom rgnSubK_mem :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (x:reference),
  set.Fset.mem x (rgnSubK s m v) <->
  ~ (x = nullConst) /\ set.Fset.mem x s /\ ((mixfix_lbrb m x) = v).

Axiom rgnSubK_subset :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  set.Fset.subset (rgnSubK s m v) s.

Axiom rgnSubK_idempotent :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a),
  ((rgnSubK (rgnSubK s m v) m v) = (rgnSubK s m v)).

Axiom rgnSubK_monotonic :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (s':set.Fset.fset reference) (m:t1 a)
    (v:a),
  set.Fset.subset s s' -> set.Fset.subset (rgnSubK s m v) (rgnSubK s' m v).

Axiom rgnSubK_twice_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((rgnSubK (rgnSubK s m v) m v') =
   (set.Fset.empty : set.Fset.fset reference)).

Axiom rgnSubK_inter_neq :
  forall {a:Type} {a_WT:WhyType a},
  forall (s:set.Fset.fset reference) (m:t1 a) (v:a) (v':a), ~ (v = v') ->
  ((set.Fset.inter (rgnSubK s m v) (rgnSubK s m v')) =
   (set.Fset.empty : set.Fset.fset reference)).

(* Why3 assumption *)
Definition partialBijection (mTo:t1 reference) (mOf:t1 reference) : Prop :=
  ((size (to_fmap1 mTo)) = (size (to_fmap1 mOf))) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mTo x) mOf) = Init.Datatypes.true)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((infix_bscl (mixfix_lbrb mOf y) mTo) = Init.Datatypes.true)) /\
  (forall (x:reference), ((infix_bscl x mTo) = Init.Datatypes.true) ->
   ((mixfix_lbrb mOf (mixfix_lbrb mTo x)) = x)) /\
  (forall (y:reference), ((infix_bscl y mOf) = Init.Datatypes.true) ->
   ((mixfix_lbrb mTo (mixfix_lbrb mOf y)) = y)).

Axiom t2 : Type.
Parameter t2_WhyType : WhyType t2.
Existing Instance t2_WhyType.

Parameter lor: t2 -> t1 reference.

Parameter rol: t2 -> t1 reference.

Axiom t'invariant :
  forall (self:t2),
  partialBijection (lor self) (rol self) /\
  ~ ((infix_bscl nullConst (lor self)) = Init.Datatypes.true) /\
  ~ ((infix_bscl nullConst (rol self)) = Init.Datatypes.true).

Axiom noNullInImg :
  forall (pi:t2) (x:reference),
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (lor pi) x) = nullConst).

Axiom noNullInDom :
  forall (pi:t2) (y:reference),
  ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ~ ((mixfix_lbrb (rol pi) y) = nullConst).

(* Why3 assumption *)
Definition idRef (pi:t2) (x:reference) (y:reference) : Prop :=
  (y = nullConst) /\ (x = nullConst) \/
  ~ (x = nullConst) /\
  ~ (y = nullConst) /\
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex1 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> ((mixfix_lbrb (lor pi) x) = y).

Axiom idRef_ex2 :
  forall (pi:t2) (x:reference) (x':reference) (y:reference),
  ~ (x = nullConst) -> ~ (x' = nullConst) -> idRef pi x y -> idRef pi x' y ->
  (x = x').

Axiom idRef_ex3 :
  forall (pi:t2) (x:reference) (y:reference) (y':reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef pi x y' -> (y = y').

(* Why3 assumption *)
Definition idRgn (pi:t2) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g) /\
  (set.Fset.mem nullConst g <-> set.Fset.mem nullConst h).

Axiom idRgn_left :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (x:reference), ~ (x = nullConst) ->
  set.Fset.mem x g -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (lor pi) x) h.

Axiom idRgn_right :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (y:reference), ~ (y = nullConst) ->
  set.Fset.mem y h -> ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  set.Fset.mem (mixfix_lbrb (rol pi) y) g.

Axiom idRgn_empty :
  forall (pi:t2),
  idRgn pi (set.Fset.empty : set.Fset.fset reference)
  (set.Fset.empty : set.Fset.fset reference).

(* Why3 assumption *)
Definition idRgn_sub {a:Type} {a_WT:WhyType a} (pi:t2) (m:t1 a) (m':t1 a)
    (v:a) (g:set.Fset.fset reference) (h:set.Fset.fset reference) : Prop :=
  (forall (x:reference), ~ (x = nullConst) -> ((mixfix_lbrb m x) = v) ->
   set.Fset.mem x g ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (lor pi) x) h) /\
  (forall (y:reference), ~ (y = nullConst) -> ((mixfix_lbrb m' y) = v) ->
   set.Fset.mem y h ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) /\
   set.Fset.mem (mixfix_lbrb (rol pi) y) g).

Axiom idRgn_sub_rgnSubK :
  forall {a:Type} {a_WT:WhyType a},
  forall (pi:t2) (m:t1 a) (m':t1 a) (v:a) (g:set.Fset.fset reference)
    (h:set.Fset.fset reference),
  (forall (x:reference), ~ (x = nullConst) ->
   ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
   ((infix_bscl x m) = Init.Datatypes.true)) /\
  (forall (y:reference), ~ (y = nullConst) ->
   ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
   ((infix_bscl y m') = Init.Datatypes.true)) /\
  (forall (p:reference) (q:reference),
   ((infix_bscl p (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb m p) = (mixfix_lbrb m' q))) ->
  idRgn_sub pi m m' v g h <-> idRgn pi (rgnSubK g m v) (rgnSubK h m' v).

Parameter updateRefperm0: t2 -> reference -> reference -> t2.

Axiom updateRefperm0'spec'6 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor (updateRefperm0 pi x y))) = Init.Datatypes.true) /\
  ((infix_bscl y (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'5 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor (updateRefperm0 pi x y)) x) = y) /\
  ((mixfix_lbrb (rol (updateRefperm0 pi x y)) y) = x).

Axiom updateRefperm0'spec'4 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((infix_bscl x1 (lor (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'3 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((infix_bscl y1 (rol (updateRefperm0 pi x y))) = Init.Datatypes.true).

Axiom updateRefperm0'spec'2 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (x1:reference),
  ((infix_bscl x1 (lor pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (lor pi) x1) =
   (mixfix_lbrb (lor (updateRefperm0 pi x y)) x1)).

Axiom updateRefperm0'spec'1 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) -> forall (y1:reference),
  ((infix_bscl y1 (rol pi)) = Init.Datatypes.true) ->
  ((mixfix_lbrb (rol pi) y1) =
   (mixfix_lbrb (rol (updateRefperm0 pi x y)) y1)).

Axiom updateRefperm0'spec'0 :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (lor (updateRefperm0 pi x y))) = (add x y (to_fmap1 (lor pi)))).

Axiom updateRefperm0'spec :
  forall (pi:t2) (x:reference) (y:reference),
  ~ (x = nullConst) /\ ~ (y = nullConst) ->
  ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  ((to_fmap1 (rol (updateRefperm0 pi x y))) = (add y x (to_fmap1 (rol pi)))).

(* Why3 assumption *)
Definition extends (pi0:t2) (pi1:t2) : Prop :=
  forall (x:reference), ((infix_bscl x (lor pi0)) = Init.Datatypes.true) ->
  ((infix_bscl x (lor pi1)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi0) x) = (mixfix_lbrb (lor pi1) x)).

Axiom extends_refl : forall (pi0:t2), extends pi0 pi0.

Axiom extends_trans :
  forall (pi0:t2) (pi1:t2) (pi2:t2), extends pi0 pi1 -> extends pi1 pi2 ->
  extends pi0 pi2.

Axiom extends_update0 :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  ~ (y = nullConst) -> ~ ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  ~ ((infix_bscl y (rol pi)) = Init.Datatypes.true) ->
  extends pi (updateRefperm0 pi x y).

Axiom extends_idRgn :
  forall (pi:t2) (g:set.Fset.fset reference) (h:set.Fset.fset reference),
  idRgn pi g h -> forall (rho:t2), extends pi rho -> idRgn rho g h.

Axiom extends_idRef :
  forall (pi:t2) (x:reference) (y:reference), idRef pi x y ->
  forall (rho:t2), extends pi rho -> idRef rho x y.

Axiom extends_exists : forall (pi:t2), exists pi0:t2, extends pi0 pi.

Parameter invert: t2 -> t2.

Axiom invert'spec :
  forall (pi:t2),
  ((lor (invert pi)) = (rol pi)) /\ ((rol (invert pi)) = (lor pi)).

Axiom idRef_invert :
  forall (pi:t2) (x:reference) (y:reference), ~ (x = nullConst) ->
  idRef pi x y -> idRef (invert pi) y x.

Axiom idRef_invert2 :
  forall (pi:t2) (x:reference) (y:reference) (z:reference),
  ~ (x = nullConst) -> idRef pi x y -> idRef (invert pi) y z -> (x = z).

(* Why3 assumption *)
Definition identity (pi:t2) (g1:set.Fset.fset reference)
    (g2:set.Fset.fset reference) : Prop :=
  forall (o:reference),
  (set.Fset.mem o g1 /\ set.Fset.mem o g2 <->
   ((infix_bscl o (lor pi)) = Init.Datatypes.true)) /\
  (((infix_bscl o (lor pi)) = Init.Datatypes.true) ->
   ((mixfix_lbrb (lor pi) o) = o)).

Axiom identity_in_refperm :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> set.Fset.mem x (set.Fset.inter g1 g2) ->
  ((infix_bscl x (lor pi)) = Init.Datatypes.true) /\
  ((mixfix_lbrb (lor pi) x) = x).

Axiom identity_in_inter :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  set.Fset.mem x (set.Fset.inter g1 g2).

Axiom identity_ref_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (x:reference),
  identity pi g1 g2 -> ((infix_bscl x (lor pi)) = Init.Datatypes.true) ->
  (x = (mixfix_lbrb (lor pi) x)).

Axiom identity_rgn_eq :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference)
    (h1:set.Fset.fset reference) (h2:set.Fset.fset reference),
  identity pi g1 g2 -> idRgn pi h1 h2 -> (h1 = h2).

Axiom identity_null_notin :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> ~ set.Fset.mem nullConst (set.Fset.inter g1 g2).

Axiom identity_sym :
  forall (pi:t2) (g1:set.Fset.fset reference) (g2:set.Fset.fset reference),
  identity pi g1 g2 -> identity pi g2 g1.

Axiom reftype : Type.
Parameter reftype_WhyType : WhyType reftype.
Existing Instance reftype_WhyType.

Axiom state : Type.
Parameter state_WhyType : WhyType state.
Existing Instance state_WhyType.

Parameter alloct: state -> t1 reftype.

Parameter high: state -> Numbers.BinNums.Z.

Parameter low: state -> Numbers.BinNums.Z.

Axiom state'invariant :
  forall (self:state), ~ mem nullConst (to_fmap1 (alloct self)).

(* Why3 assumption *)
Definition isAllocated (s:state) (p:reference) : Prop :=
  mem p (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition isValidRgn (s:state) (r:set.Fset.fset reference) : Prop :=
  forall (q:reference), set.Fset.mem q r ->
  (q = nullConst) \/ mem q (to_fmap1 (alloct s)).

(* Why3 assumption *)
Definition typeofRgn (s:state) (r:set.Fset.fset reference)
    (types:Init.Datatypes.list reftype) : Prop :=
  forall (p:reference), set.Fset.mem p r ->
  (p = nullConst) \/
  mem p (to_fmap1 (alloct s)) /\
  list.Mem.mem (mixfix_lbrb (alloct s) p) types.

(* Why3 assumption *)
Definition okRefperm (sl:state) (sr:state) (pi:t2) : Prop :=
  (forall (p:reference), mem p (to_fmap1 (lor pi)) ->
   mem p (to_fmap1 (alloct sl))) /\
  (forall (q:reference), mem q (to_fmap1 (rol pi)) ->
   mem q (to_fmap1 (alloct sr))) /\
  (forall (p:reference) (q:reference), mem p (to_fmap1 (lor pi)) ->
   ((mixfix_lbrb (lor pi) p) = q) ->
   ((mixfix_lbrb (alloct sl) p) = (mixfix_lbrb (alloct sr) q))).

(* Why3 assumption *)
Definition alloc_does_not_shrink (pre:state) (post:state) : Prop :=
  forall (p:reference), mem p (to_fmap1 (alloct pre)) ->
  mem p (to_fmap1 (alloct post)) /\
  ((mixfix_lbrb (alloct pre) p) = (mixfix_lbrb (alloct post) p)).

Parameter agree_allfields:
  state -> state -> t2 -> set.Fset.fset reference -> Prop.

Parameter l_s: state.

Parameter r_s: state.

Parameter pi: t2.

Parameter pi_rol: t1 reference.

Parameter pi_lor: t1 reference.

Axiom H : (pi_rol = (rol pi)) /\ (pi_lor = (lor pi)).

Axiom Requires : okRefperm l_s r_s pi.

Axiom Requires1 : ((low l_s) = (low r_s)).

Axiom H1 : ~ ((low l_s) < (high l_s))%Z.

Parameter l_s1: state.

Axiom H2 : ((alloct l_s1) = (alloct l_s)).

Axiom H3 : ((high l_s1) = (high l_s)).

Axiom Ensures : ((low l_s1) = 1%Z).

Axiom H4 : ~ ((low r_s) < (high r_s))%Z.

Parameter r_s1: state.

Axiom H5 : ((alloct r_s1) = (alloct r_s)).

Axiom H6 : ((high r_s1) = (high r_s)).

Axiom Ensures1 : ((low r_s1) = 1%Z).

Parameter l_flipcoin_ret: Numbers.BinNums.Z.

Axiom Assume : (0%Z = l_flipcoin_ret) \/ (l_flipcoin_ret = 1%Z).

Axiom Assert :
  exists r_flipcoin_ret:Numbers.BinNums.Z,
  (((low l_s1) = (low r_s1)) -> (l_flipcoin_ret = r_flipcoin_ret)) /\
  ~ ((low l_s1) = (low r_s1)) -> (l_flipcoin_ret = (1%Z - r_flipcoin_ret)%Z).

Parameter r_flipcoin_ret: Numbers.BinNums.Z.

Axiom Assume1 :
  (((low l_s1) = (low r_s1)) -> (l_flipcoin_ret = r_flipcoin_ret)) /\
  ~ ((low l_s1) = (low r_s1)) -> (l_flipcoin_ret = (1%Z - r_flipcoin_ret)%Z).

Axiom H7 : (l_flipcoin_ret = 0%Z).

Parameter l_s2: state.

Axiom H8 : ((alloct l_s2) = (alloct l_s1)).

Axiom H9 : ((high l_s2) = (high l_s1)).

Axiom Ensures2 : ((low l_s2) = (1%Z - (low l_s1))%Z).

Axiom H10 : ~ (r_flipcoin_ret = 0%Z).

Axiom Ensures3 : okRefperm l_s2 r_s1 pi.

(* Why3 goal *)
Theorem prog'vc : ((low l_s2) = (low r_s1)).
Proof.
pose Assume1 as H.
Set Printing All.

Qed.

