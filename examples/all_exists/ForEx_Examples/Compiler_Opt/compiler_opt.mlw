module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = {  }
  
  type state = private { mutable ghost alloct : M.t reftype }
    invariant { not (M.mem null alloct) }
    by { alloct = (().M.create) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn)
end

module I
  use prelude.Prelude
  use State
  
  val compiler_opt (s: state) (time: int) : int
end

module A
  use prelude.Prelude
  use State
  use I
  
  let compiler_opt (s : state) (time : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let time = ref time in
      let x = ref 0 in
      let s0 = ref 0 in
      let t = ref 0 in
      (x := ([@expl:x := time] (! time)));
      (result := ([@expl:result := 0] 0));
      while ((! x) > 0) do
        invariant { alloc_does_not_shrink (old s) s }
        (x := ([@expl:x := x - 1] ((! x) - 1)));
        (t := ([@expl:havoc t] (any int)));
        while ((! t) > 0) do
          invariant { alloc_does_not_shrink (old s) s }
          (t := ([@expl:t := t - 1] ((! t) - 1)));
          (s0 := ([@expl:havoc s0] (any int)));
          (result := ([@expl:result := result + s0] ((! result) + (! s0))))
        done
      done;
      (! result)
end

module B
  use prelude.Prelude
  use State
  use I
  
  let compiler_opt (s : state) (time : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let time = ref time in
      let x = ref 0 in
      let s0 = ref 0 in
      (x := ([@expl:x := time] (! time)));
      (result := ([@expl:result := 0] 0));
      while ((! x) > 0) do
        invariant { alloc_does_not_shrink (old s) s }
        (x := ([@expl:x := x - 1] ((! x) - 1)));
        (s0 := ([@expl:havoc s0] (any int)));
        (result := ([@expl:result := result + s0] ((! result) + (! s0))))
      done;
      (! result)
end

module FREL
  use prelude.Prelude
  use State
  use A
  use B
  
  let compiler_opt (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_time : int) (r_time : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_time = r_time) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_time = ref l_time in
      let r_time = ref r_time in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let l_s0 = ref 0 in
      let r_s0 = ref 0 in
      let l_t = ref 0 in
      (l_x := ([@expl:x := time] (! l_time)));
      (r_x := ([@expl:x := time] (! r_time)));
      (l_result := ([@expl:result := 0] 0));
      (r_result := ([@expl:result := 0] 0));
      while ((! l_x) > 0) do
        invariant { okRefperm l_s r_s pi }
        invariant { ((! l_result) = (! r_result)) }
        invariant { ((! l_time) = (! r_time)) }
        invariant { ((! l_x) = (! r_x)) }
        invariant { [@expl:lockstep] (((! l_x) > 0) = ((! r_x) > 0)) }
        (l_x := ([@expl:x := x - 1] ((! l_x) - 1)));
        (r_x := ([@expl:x := x - 1] ((! r_x) - 1)));
        (l_t := ([@expl:havoc t] (any int)));
        while ((! l_t) > 0) do
          invariant { okRefperm l_s r_s pi }
          (l_t := ([@expl:t := t - 1] ((! l_t) - 1)));
          (l_s0 := ([@expl:havoc s0] (any int)));
          (l_result
             := ([@expl:result := result + s0] ((! l_result) + (! l_s0))))
        done;
        assert { exists r_s0 : int. r_s0 = (! l_result) - (! r_result) };
        (r_s0 := ([@expl:havoc s0] (any int)));
        assume { (! r_s0) = (! l_result) - (! r_result) };
        (r_result := ([@expl:result := result + s0] ((! r_result) + (! r_s0))))
      done;
      ((! l_result), (! r_result))
end

module FREL_biinterface
  use prelude.Prelude
  use State
  use A
  use B
  
  val compiler_opt (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_time: int) (r_time: int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { (l_time = r_time) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
end

module MAIN
  use prelude.Prelude
  use State
end

