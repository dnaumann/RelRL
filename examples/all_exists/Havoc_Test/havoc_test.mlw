module State
  use prelude.Prelude
  use prelude.PreRefperm
  
  type reftype = 
      | Cell
  
  type state = private {
              mutable ghost alloct : M.t reftype;
              mutable value : M.t int;
              mutable ghost rep : M.t rgn;
              mutable y : int;
              mutable x : int
              }
    invariant { not (M.mem null alloct) }
    invariant {
      forall p : reference.
        ((M.mem p alloct) ->
           (((alloct[p]) = Cell) ->
              (((M.mem p value) /\ (M.mem p rep)) /\
                 (forall q : reference.
                    ((Rgn.mem q (rep[p])) -> ((q = null) \/ (M.mem q alloct))))))) }
    invariant { not (M.mem null value) }
    invariant { not (M.mem null rep) }
    by
      { alloct = (().M.create) ;
        value = (().M.create) ;
        rep = (().M.create) ;
        y = (any int) ;
        x = (any int) }
  
  predicate isAllocated (s: state) (p: reference) = M.mem p s.alloct
  
  predicate isValidRgn (s: state) (r: rgn) =
    forall q : reference. ((Rgn.mem q r) -> ((q = null) \/ (M.mem q s.alloct)))
  
  predicate typeofRgn (s: state) (r: rgn) (types: L.list reftype) =
    forall p : reference.
      ((Rgn.mem p r) ->
         ((p = null) \/ ((M.mem p s.alloct) /\ (L.mem (s.alloct[p]) types))))
  
  predicate hasCellType (s: state) (p: reference) =
    ((p = null) \/ ((M.mem p s.alloct) /\ ((s.alloct[p]) = Cell)))
  
  predicate okRefperm (sl: state) (sr: state) (pi: PreRefperm.t) =
    ((forall p : reference. ((M.mem p pi.lor) -> (M.mem p sl.alloct))) /\
       ((forall q : reference. ((M.mem q pi.rol) -> (M.mem q sr.alloct))) /\
          (forall p : reference, q : reference.
             ((M.mem p pi.lor) ->
                (((pi.lor[p]) = q) -> ((sl.alloct[p]) = (sr.alloct[q])))))))
  
  val mk_Cell (s: state) : reference
    writes { s.alloct, s.value, s.rep }
    ensures { not (M.mem result (old s.alloct)) }
    
    ensures { (s.alloct = (M.add result Cell (old s.alloct))) }
    
    ensures { forall p : reference.
                ((M.mem p (old s.alloct)) ->
                   ((M.mem p s.alloct) /\
                      (((old s.alloct)[p]) = (s.alloct[p])))) }
    
    ensures { (result <> null) }
    
    ensures { hasCellType s result }
    
    ensures { (s.value = (M.add result 0 (old s.value))) }
    
    ensures { (s.rep = (M.add result emptyRgn (old s.rep))) }
  
  val set_y (s: state) (v: int) : unit
    writes { s.y }
    ensures { (s.y = v) }
  
  val set_x (s: state) (v: int) : unit
    writes { s.x }
    ensures { (s.x = v) }
  
  val set_value (s: state) (o: reference) (v: int) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    writes { s.value }
    ensures { (s.value = (M.add o v (old s.value))) }
  
  val set_rep (s: state) (o: reference) (ghost v: rgn) : unit
    requires { (o <> null) }
    requires { hasCellType s o }
    requires { isValidRgn s v }
    writes { s.rep }
    ensures { (s.rep = (M.add o v (old s.rep))) }
  
  function img_value : state -> (rgn -> rgn)
  
  axiom img_value_ax: forall s : state, r : rgn. ((img_value s r) = emptyRgn)
  
  function img_rep : state -> (rgn -> rgn)
  
  axiom img_rep_ax:
    forall s : state, r : rgn, p : reference.
      ((Rgn.mem p (img_rep s r)) <->
         (exists q : reference.
            ((M.mem q s.alloct) /\
               (((s.alloct[q]) = Cell) /\
                  ((Rgn.mem q r) /\ (Rgn.mem p (s.rep[q])))))))
  
  predicate alloc_does_not_shrink (pre: state) (post: state) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         ((M.mem p post.alloct) /\ ((pre.alloct[p]) = (post.alloct[p]))))
  
  predicate wr_frame_value (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.value[p]) = (post.value[p])))))
  
  predicate wr_frame_rep (pre: state) (post: state) (r: rgn) =
    forall p : reference.
      ((M.mem p pre.alloct) ->
         (((post.alloct[p]) = Cell) ->
            ((not (Rgn.mem p r)) -> ((pre.rep[p]) = (post.rep[p])))))
  
  predicate agree_value (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       ((sl.value[o]) = (sr.value[pi.lor[o]])))))))))
  
  predicate agree_rep (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    ((okRefperm sl sr pi) /\
       (forall o : reference.
          ((isAllocated sl o) ->
             ((hasCellType sl o) ->
                ((Rgn.mem o w) ->
                   ((M.mem o pi.lor) /\
                      ([@expl:sl(o) ~ sr(pi(o))]
                       (PreRefperm.idRgn pi (sl.rep[o]) (sr.rep[pi.lor[o]])))))))))
  
  predicate agree_allfields (sl: state) (sr: state) (pi: PreRefperm.t) (w: rgn) =
    (agree_value sl sr pi w) /\ (agree_rep sl sr pi w)
end

module I
  use prelude.Prelude
  use State
end

module A
  use prelude.Prelude
  use State
  use I
  
  let test2 (s : state) (n : int) : int
  = label INIT in
      let result = ref 0 in
      let n = ref n in
      let x1 = ref 0 in
      (x1 := ([@expl:x1 := n] (! n)));
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module B
  use prelude.Prelude
  use State
  use I
  
  let test2 (s : state) (n : int) : int
    diverges
  = label INIT in
      let result = ref 0 in
      let n = ref n in
      let x1 = ref 0 in
      let b = ref 0 in
      (x1 := ([@expl:x1 := 0] 0));
      (b := ([@expl:havoc b] (any int)));
      while not ((! b) = 0) do
        invariant { alloc_does_not_shrink (old s) s }
        (x1 := ([@expl:x1 := x1 + 1] ((! x1) + 1)));
        (b := ([@expl:havoc b] (any int)))
      done;
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module AB
  use prelude.Prelude
  use State
  use A
  use B
  
  let test2 (l_s : state) (r_s : state) (pi : PreRefperm.t) (l_n : int) (r_n : int) : 
    (int, int)
    requires { okRefperm l_s r_s pi }
    requires { ((l_n >= 0) /\ (r_n >= 0)) }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
    diverges
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_n = ref l_n in
      let r_n = ref r_n in
      let l_x = ref 0 in
      let r_x = ref 0 in
      let r_b = ref 0 in
      (l_x := ([@expl:x := n] (! l_n)));
      (r_x := ([@expl:x := 0] 0));
      assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
      (r_b := ([@expl:havoc b] (any int)));
      assume { (! r_b) = (! l_x) - (! r_x) };
      while not ((! r_b) = 0) do
        invariant { okRefperm l_s r_s pi }
        invariant { (! l_x) >= (! r_x) }
        invariant { (! r_b) = (! l_x) - (! r_x) }
        let r_q__vnt1 = ref 0 in
        let r_q__b2 = ref false in
        (r_q__vnt1 := ([@expl:havoc q__vnt1] (any int)));
        assume { (! r_q__vnt1) = (! r_b) };
        (r_q__b2 := ([@expl:havoc q__b2] (any bool)));
        assume {
          (! r_q__b2)
            <->
            (not (false /\ (false /\ false)))
            /\
            ((! r_b) <> 0)
            /\
            (true /\ true) };
        (r_x := ([@expl:x := x + 1] ((! r_x) + 1)));
        assert { exists r_b : int. r_b = (! l_x) - (! r_x) };
        (r_b := ([@expl:havoc b] (any int)));
        assume { (! r_b) = (! l_x) - (! r_x) };
        assert { (! r_q__b2) -> (0 <= (! r_q__vnt1)) };
        assert { (! r_q__b2) -> ((! r_b) < (! r_q__vnt1)) }
      done;
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
end

module AB_biinterface
  use prelude.Prelude
  use State
  use A
  use B
end

module Impl
  use prelude.Prelude
  use State
  use I
  
  let test1 (s : state) : int
  = label INIT in
      let result = ref 0 in
      let x1 = ref 0 in
      (x1 := ([@expl:havoc x1] (any int)));
      (result := ([@expl:result := x1] (! x1)));
      (! result)
end

module ImplREL
  use prelude.Prelude
  use State
  use Impl
  
  let test1 (l_s : state) (r_s : state) (pi : PreRefperm.t) : (int, int)
    requires { okRefperm l_s r_s pi }
    ensures { okRefperm l_s r_s pi }
    
    ensures { match result with
              | (l_result, r_result) -> (l_result = r_result)
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (l_x := ([@expl:havoc x] (any int)));
      assert { exists r_x : int. ((! l_x) = r_x) };
      (r_x := ([@expl:havoc x] (any int)));
      assume { ((! l_x) = (! r_x)) };
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
  
  predicate sameParity (l_s: state) (r_s: state) (pi1: PreRefperm.t) (l_n: int) (r_n: int) =
    (okRefperm l_s r_s pi1) -> ((mod l_n 2) = (mod r_n 2))
  
  let test1_again (l_s : state) (r_s : state) (pi2 : PreRefperm.t) : 
    (int, int)
    requires { okRefperm l_s r_s pi2 }
    ensures { okRefperm l_s r_s pi2 }
    
    ensures { match result with
              | (l_result, r_result) ->
                  sameParity l_s r_s pi2 l_result r_result
              end }
  = label INIT in
      let r_result = ref 0 in
      let l_result = ref 0 in
      let l_x = ref 0 in
      let r_x = ref 0 in
      (l_x := ([@expl:havoc x] (any int)));
      assert { exists r_x : int. sameParity l_s r_s pi2 (! l_x) r_x };
      (r_x := ([@expl:havoc x] (any int)));
      assume { sameParity l_s r_s pi2 (! l_x) (! r_x) };
      (l_result := ([@expl:result := x] (! l_x)));
      (r_result := ([@expl:result := x] (! r_x)));
      ((! l_result), (! r_result))
  
  let test1_again2 (l_s : state) (r_s : state) (pi : PreRefperm.t) : 
    (unit, unit)
    requires { okRefperm l_s r_s pi }
    ensures { okRefperm l_s r_s pi }
    
    ensures { (l_s.x = r_s.x) /\ (l_s.y = r_s.y) }
    
    ensures { match result with
              | (l_result, r_result) -> ((l_result = ()) /\ (r_result = ()))
              end }
  = label INIT in
      let r_result = ref () in
      let l_result = ref () in
      (set_x l_s ([@expl:havoc x] (any int)));
      (set_y l_s ([@expl:havoc y] (any int)));
      assert { exists r_y : int. (l_s.y = r_y) };
      (set_y r_s ([@expl:havoc y] (any int)));
      assume { (l_s.y = r_s.y) };
      assert { exists r_x : int. (l_s.x = r_x) /\ (l_s.y = r_s.y) };
      (set_x r_s ([@expl:havoc x] (any int)));
      assume { (l_s.x = r_s.x) /\ (l_s.y = r_s.y) };
      ((! l_result), (! r_result))
  
  let testing (l_s : state) (r_s : state) (pi3 : PreRefperm.t) (l_p : reference) (r_r : rgn) : 
    (unit, reference)
    requires { hasCellType l_s l_p }
    requires { (l_p <> null) }
    requires { okRefperm l_s r_s pi3 }
    requires { exists r_q : reference.
                 (isAllocated r_s r_q)
                   /\
                   (hasCellType r_s r_q)
                   /\
                   (Rgn.mem r_q r_r)
                   /\
                   (PreRefperm.idRef pi3 l_p r_q)
    }
    ensures { match result with
              | (_, r_result) -> hasCellType r_s r_result
              end }
    
    ensures { okRefperm l_s r_s pi3 }
    
    ensures { match result with
              | (l_result, r_result) ->
                  (Rgn.mem r_result r_r) /\ (PreRefperm.idRef pi3 l_p r_result)
              end }
  = label INIT in
      let r_result = ref null in
      let l_result = ref () in
      let l_p = ref l_p in
      let r_r = ref r_r in
      let r_q = ref null in
      assert {
        exists r_q : reference.
          (hasCellType r_s r_q)
            /\
            (Rgn.mem r_q (! r_r))
            /\
            (PreRefperm.idRef pi3 (! l_p) r_q) };
      (r_q := ([@expl:havoc q] (any reference)));
      assume {
        (Rgn.mem (! r_q) (! r_r)) /\ (PreRefperm.idRef pi3 (! l_p) (! r_q)) };
      (r_result := ([@expl:result := q] (! r_q)));
      ((! l_result), (! r_result))
end

module ImplREL_biinterface
  use prelude.Prelude
  use State
  use Impl
  
  predicate sameParity (l_s: state) (r_s: state) (pi: PreRefperm.t) (l_n: int) (r_n: int) =
    (okRefperm l_s r_s pi) -> ((mod l_n 2) = (mod r_n 2))
end

module MAIN
  use prelude.Prelude
  use State
end

